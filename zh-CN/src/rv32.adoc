[[rv32]]
== RV32I 基本整数指令集，版本 2.1

本章介绍了 RV32I 基本整数指令集。

[TIP]
====
RV32I 旨在成为编译器目标，并支持现代操作系统环境。 此指令集架构还旨在减少最低限度实现所需的硬件。 RV32I 包含 40 条独特的指令，尽管简单实现可能用一个始终陷入的 SYSTEM 硬指令涵盖 ECALL/EBREAK 指令，并可能将 FENCE 指令实现为 NOP，从而将基本指令数减少到总计 38。 RV32I 可以模拟几乎任何其他指令集架构扩展（除 A 扩展外，它需要额外的硬件支持以实现原子性）。

实践中，包括机器模式特权架构在内的硬件实现还需要 6 条 CSR 指令。

基本整数指令集架构的子集可能在教学目的上有用，但基本集已定义，不应有太多动力在真正的硬件实现中使用子集，除了省略对未对齐内存访问的支持并将所有 SYSTEM 指令视为单一陷阱。
====

[NOTE]
====
标准 RISC-V 汇编语言语法记录在《汇编程序员手册》cite:[riscv-asm-manual] 中。
====

[NOTE]
====
RV32I 的大部分评论也适用于 RV64I 基本集。
====

=== 基本整数指令集架构的程序员模型

<<gprs>> 显示了基本整数ISA的非特权状态。 对于 RV32I，32 个 `x` 寄存器每个宽 32 位，即 `XLEN=32`。 寄存器 `x0` 硬接线为所有位均为 0。
通用寄存器 `x1-x31` 存储各种指令解释为布尔值集合或二进制补码整数或无符号二进制整数的值。

还有一个额外的非特权寄存器：程序计数器 `pc` 存放当前指令的地址。

[[gprs]]
.RISC-V 基本非特权整数寄存器状态。
[cols="<,^,>", options="header", width="50%", align="center", grid="rows"]
|===
<|[.small]#XLEN-1#
|
>|[.small]#0#

3+^|[.small]#x0/zero#

3+^|[.small]#x1#

3+^|[.small]#x2#

3+^|[.small]#x3#

3+^|[.small]#x4#

3+^|[.small]#x5#

3+^|[.small]#x6#

3+^|[.small]#x7#

3+^|[.small]#x8#

3+^|[.small]#x9#

3+^|[.small]#x10#

3+^|[.small]#x11#

3+^|[.small]#x12#

3+^|[.small]#x13#

3+^|[.small]#x14#

3+^|[.small]#x15#

3+^|[.small]#x16#

3+^|[.small]#x17#

3+^|[.small]#x18#

3+^|[.small]#x19#

3+^|[.small]#x20#

3+^|[.small]#x21#

3+^|[.small]#x22#

3+^|[.small]#x23#

3+^|[.small]#x24#

3+^|[.small]#x25#

3+^|[.small]#x26#

3+^|[.small]#x27#

3+^|[.small]#x28#

3+^|[.small]#x29#

3+^|[.small]#x30#

3+^|[.small]#x31#

3+^|[.small]#XLEN#

|[.small]#XLEN-1# | >|[.small]#0#

3+^|[.small]#pc#

3+^|[.small]#XLEN#
|===

[NOTE]
====
基本整数指令集架构中没有专用的堆栈指针或子程序返回地址链接寄存器；指令编码允许使用任何 `x` 寄存器来实现这些目的。 但是，标准软件调用约定使用寄存器 `x1` 来存储调用的返回地址，寄存器 `x5` 可用作备用链接寄存器。 标准调用约定使用寄存器 `x2` 作为堆栈指针。

硬件可以选择加速使用 `x1` 或 `x5` 的函数调用和返回。 请参阅 JAL 和 JALR 指令的说明。

可选的压缩 16 位指令格式设计的假设是 `x1` 是返回地址寄存器，`x2` 是堆栈指针。 使用其他约定的软件将正确运行，但可能会使代码大小更大。

可用的架构寄存器数量会对代码大小、性能和能耗产生重大影响。 尽管可以认为 16 个寄存器对于运行编译代码的整数指令集足够，但使用 3 地址格式在 16 位指令中编码完整指令集是不可能的。 虽然可以采用 2 地址格式，但这会增加指令数并降低效率。
我们希望避免中间指令大小（如 Xtensa 的 24 位指令），以简化基本硬件实现，一旦采用 32 位指令大小，就可以很容易地支持 32 个整数寄存器。 更多的整数寄存器也有助于提高高性能代码的性能，这些代码中可能会广泛使用循环展开、软件流水线和缓存切片。

出于这些原因，我们为 RV32I 选择了 32 个整数寄存器的常规大小。 动态寄存器使用往往由几个经常访问的寄存器主导，并且寄存器文件实现可以优化以减少频繁访问寄存器的访问能耗 cite:[jtseng:sbbci]。 可选的压缩 16 位指令格式大多仅访问 8 个寄存器，因此可以提供密集的指令编码，而如果需要，额外的指令集扩展可以支持更大的寄存器空间（平面或层次结构）。

对于资源受限的嵌入式应用，我们定义了 RV32E 子集，其中只有 16 个寄存器
(<<rv32e>>)。
====

=== 基本指令格式

在基本 RV32I ISA 中，有四种核心指令格式 (R/I/S/U)，如 <<base_instr>> 所示。 它们长度均为固定的 32 位。 基本指令集具有 `IALIGN=32`，意味着指令必须在内存中对齐到四字节边界。 如果目标地址没有对齐到 `IALIGN-bit`，则在执行分支或无条件跳转时会生成指令地址未对齐异常。
该异常是在分支或跳转指令上报告的，而不是目标指令。 对于未执行的条件分支，不会生成指令地址未对齐异常。

[NOTE]
====
当添加具有 16 位长度或其他奇数倍 16 位长度的指令扩展时，基本指令集的对齐约束放宽到两字节边界（即 IALIGN=16）。

指令地址未对齐异常在会导致指令未对齐的分支或跳转指令上报告，以帮助调试，并简化 IALIGN=32 的系统的硬件设计，这些是未对齐可能发生的唯一位置。
====

对于保留指令的解码行为未指定。

[NOTE]
====
某些平台可能要求保留用于标准用途的操作码引发非法指令异常。 其他平台可能允许保留的操作码空间用于不符合规范的扩展。
====

RISC-V ISA 在所有格式中保持源（_rs1_ 和 _rs2_）和目标（_rd_）寄存器在同一位置以简化解码。
除 CSR 指令中使用的 5 位立即数 (<<csrinsts>>) 外，即时数始终为符号扩展，并且通常填充到指令中最左可用的位并已分配以减少硬件复杂性。 特别是，所有立即数的符号位始终位于指令的第 31 位以加快符号扩展电路。

include::images/wavedrom/instruction_formats.adoc[]

[[base_instr, Base instruction formats]]
RISC-V 基本指令格式。 每个立即数子字段用正在生成的立即数中的位位置 (imm[x]) 标记，而不是通常在指令的立即字段内的位位置。

[NOTE]
====
解码寄存器说明符通常在实现中的关键路径上，因此选择了指令格式，以保持所有寄存器说明符在所有格式中的相同位置，代价是必须在格式之间移动立即数位（与 RISC-IV aka 共享的属性）。 SPUR cite:[spur-jsscc1989]）。

在实践中，大多数立即数要么很小，要么需要所有 XLEN 位。
我们选择不对称的立即数分割（常规指令为 12 位加上一个特殊的载入上部立即数指令为 20 位）以增加可用于常规指令的操作码空间。

立即数是符号扩展的，因为我们没有发现使用零扩展一些立即数（如在 MIPS ISA 中）的益处，并且希望保持 ISA 尽可能简单。
====

=== 立即数编码变体

基于立即数处理，还有两个指令格式变体（B/J），如 <<baseinstformatsimm>> 中所示。

include::images/wavedrom/immediate_variants.adoc[]

//.RISC-V base instruction formats showing immediate variants.

S 和 B 格式之间的唯一区别在于 B 格式中 12 位立即字段用于编码以 2 的倍数的分支偏移。 与惯常做法不同，未将指令编码的立即数所有位在硬件中左移一位，而是中间位 (imm[10:1]) 和符号位保持在固定位置中，而 S 格式中的最低位 (inst[7]) 在 B 格式中编码为高位。

类似地，U 和 J 格式之间的唯一区别在于 20 位立即数左移 12 位形成 U 立即数，并左移1位形成 J 立即数。 U 和 J 格式立即数中的指令位位置选择最大化与其他格式和彼此的重叠。

<<immtypes>> 显示每种基本指令格式产生的立即数，并标记说明哪个指令位 (inst[_y_]) 产生立即数值的每个位。

include::images/wavedrom/immediate.adoc[]

这些字段用用于构造其值的指令位标记。  符号扩展始终使用 inst[31]。

[NOTE]
====
符号扩展是立即数上最关键的操作之一（特别是对于 XLEN>32），在 RISC-V 中，所有立即数的符号位始终位于指令的第 31 位，以允许符号扩展与指令解码并行进行。

尽管更复杂的实现可能会有独立的加法器用于分支和跳转计算，因此不会从在各种指令中保持立即数位位置不变中获益，我们希望降低最简单实现实现的硬件成本。 通过旋转 B 和 J 立即数的指令编码中的位而不是使用动态硬件多路复用器将立即数乘以 2，我们将指令信号扇出和立即多路复用器成本减少了约 2 倍。 混乱的立即数编码几乎不会增加静态或预编译时间。 对于动态生成指令，有一些小的额外开销，但最常见的短向前分支具有简单的立即数字编码。
====

=== 整数计算指令

大多数整数计算指令操作在整数寄存器文件中持有的 `XLEN` 位值上。 整数计算指令要么以 I 型格式编码为寄存器-立即操作，要么以 R 型格式编码为寄存器-寄存器操作。 寄存器-立即指令和寄存器-寄存器指令的目标寄存器均为 _rd_。 没有整数计算指令会导致算术异常。

[TIP]
====
我们没有在基本指令集中包括用于整数算术操作的溢出检查的特殊指令集支持，因为许多溢出检查可以通过 RISC-V 分支廉价实现。
无符号加法的溢出检查仅在加法后需要一个额外的分支指令：
`add t0, t1, t2; bltu t0, t1, overflow`。

对于符号相同的加法，如果已知一个操作数的符号，溢出检查只需要一个加法后的分支：
`addi t0, t1, +imm; blt t0, t1, overflow`。 这涵盖了带有立即子操作数的加法的常见情况。

对于一般符号相同的加法，除了加法后需要三个额外的指令，利用了这样的观察：只有当另外一个操作数是负数时，和才应该小于其中一个操作数。

[source,text]
....
         add t0, t1, t2
         slti t3, t2, 0
         slt t4, t0, t1
         bne t3, t4, overflow
....

在 RV64I 中，通过比较操作数上的 ADD 和 ADDW 的结果，可以进一步优化 32 位符号相同加法的检查。
====

==== 整数寄存器-立即指令

include::images/wavedrom/integer_computational.adoc[]

//.Integer Computational Instructions

ADDI 将符号扩展的 12 位立即数添加到寄存器 _rs1_。
算术溢出被忽略，结果只是结果的低 XLEN 位。 ADDI _rd, rs1, 0_ 用于实现 MV _rd, rs1_ 汇编伪指令。

如果寄存器 _rs1_ 小于符号扩展的立即数，SLTI（设置小于立即数）将值 1 放在寄存器 _rd_ 中（当两个都被视为有符号数时），否则将 0 写入 _rd_。 SLTIU 类似，但将值视为无符号数进行比较（即立即数首先符号扩展到 XLEN 位，然后视为无符号数）。
注意，如果 _rs1_ 等于零，SLTIU _rd, rs1, 1_ 将 _rd_ 设置为 1，否则将 _rd_ 设置为 0（汇编伪指令 SEQZ _rd, rs_）。

ANDI、ORI、XORI 是逻辑操作，在寄存器 _rs1_ 和符号扩展的 12 位立即数上执行按位与、或、异或运算，并将结果放入 _rd_。 请注意，XORI _rd, rs1, -1_ 对寄存器 _rs1_ 执行按位逻辑反转（汇编伪指令 NOT _rd, rs_）。

include::images/wavedrom/int-comp-slli-srli-srai.adoc[]

//.Integer register-immediate, SLLI, SRLI, SRAI

以常数为单位的移位被编码为 I 型格式的特化。 要移位的操作数位于 _rs1_ 中，移位量编码在 I-立即字段的低 5 位中。 右移类型编码在第 30 位。 SLLI 是逻辑左移（零被移入低位）；SRLI 是逻辑右移（零被移入高位）；SRAI 是算术右移（原来的符号位被复制到空出的高位中）。

include::images/wavedrom/int-comp-lui-aiupc.adoc[]

//.Integer register-immediate, U-immediate

LUI（载入上部立即数）用于构建 32 位常数，使用 U 型格式。 LUI 将 32 位 U-立即数值放入目标寄存器 _rd_，填充最低位 12 为零。

AUIPC（给 `pc` 增加上部立即数）用于构建 `pc` 相对地址，并使用 U 型格式。 AUIPC 从 U-立即数生成 32 位偏移量，填充最低 12 为零，将此偏移量加到 AUIPC 指令的地址，然后将结果放入寄存器 _rd_ 。

[NOTE]
====
`lui` 和 `auipc` 的汇编语法不表示 U-立即数的低 12 位，其始终为零。

AUIPC 指令支持两指令序列来访问 PC 的任意偏移量，无论控制流传输和数据访问。 AUIPC 与 JALR 中的 12 位立即数组合可以将控制转移到任何 32 位 PC 相对地址，而 AUIPC 加上常规加载或存储指令中的 12 位立即数偏移量可以访问任何 32 位 PC 相对数据地址。

通过将 U-立即数设置为 0 来获得当前 PC。 尽管 JAL +4 指令也可用于获取局部 PC（紧接 JAL 的指令），但它可能会在更简单的微架构中导致流水线中断或在更复杂的微架构中污染 BTB 结构。
====

==== 整数寄存器-寄存器操作

RV32I 定义了几种算术 R 型操作。 所有操作读取寄存器 _rs1_ 和 _rs2_ 作为源操作数，并将结果写入寄存 _rd_。 _funct7_ 和 _funct3_ 字段选择操作的类型。

include::images/wavedrom/int_reg-reg.adoc[]

//.Integer register-register

ADD 执行 _rs1_ 和 _rs2_ 的加法。 SUB 执行从 _rs1_ 中减去 _rs2_。 溢出被忽略，并且结果的低 XLEN 位被写入目标 _rd_。 SLT 和 SLTU 分别执行有符号和无符号比较，如果 _rs1_ < _rs2_ 则写入 1 到 _rd_，否则为 0。 注意，如果 _rs2_ 不等于零，SLTU _rd_, _x0_, _rs2_ 将 _rd_ 设置为 1，否则将 _rd_ 设置为零（汇编伪指令 SNEZ _rd, rs_）。 AND、OR 和 XOR 执行按位逻辑运算。

SLL、SRL 和 SRA 通过寄存器 _rs2_ 的低 5 位中的移位量对寄存器 _rs1_ 中的值执行逻辑左移、逻辑右移和算术右移。

==== NOP 指令

include::images/wavedrom/nop.adoc[]

//.NOP instructions

NOP 指令不会改变任何架构上可见的状态，除了推进 `pc` 和增加任何应用的性能计数器。 NOP 被编码为 ADDI _x0, x0, 0_。

[NOTE]
====
NOP 可用于将代码段与微架构上的重要地址边界对齐，或为内联代码修改留下空间。 尽管编码一个 NOP 有很多可能的方式，但我们定义了一个典型的 NOP 编码，以允许微架构优化以及更具可读性的反汇编输出。 其他 NOP 编码可用于 <<rv32i-hints>>。

选择 ADDI 作为 NOP 编码，因为这最可能占用最少的资源来跨不同的系统执行（如果没有在解码中优化掉）。 特别是，该指令只读取一个寄存器。
此外，在超标量设计中，更可能有一个 ADDI 功能单元，因为加法是最常见的操作。 特别是，地址生成功能单元可以使用基本+偏移地址计算所需的相同硬件执行 ADDI，而寄存器-寄存器加法或逻辑/移位操作则需要额外的硬件。
====

=== 控制传输指令

RV32I 提供两种类型的控制传输指令：无条件跳转和条件分支。 RV32I 中的控制传输指令 _没有_ 构架上可见的延迟槽。

如果在跳跃或采取分支的目标上发生指令访问故障或指令页故障异常，则该异常在目标指令上报告，而不是跳跃或分支指令。

==== 无条件跳转

跳跃和链接 (JAL) 指令使用 J 型格式，其中 J 立即数编码为 2 字节的倍数的带符号偏移量。 该偏移量符号扩展并加到跳转指令的地址上形成跳转目标地址。 因此跳转可以定位 ±1 MiB 范围。 JAL 将紧随跳转的指令（'pc'+4）的地址存储到寄存器 _rd_ 中。 标准软件调用约定使用 'x1' 作为返回地址寄存器，并使用 'x5' 作为备用链接寄存器。

[NOTE]
====
备用链接寄存器支持调用微代码例程（例如，用于在压缩代码中保存和恢复寄存器的例程），同时保留常规返回地址寄存器。 选择寄存器 `x5` 作为备用链接寄存器，因为它在标准调用约定中映射到一个临时寄存器，并且其编码只比常规链接寄存器多一个位。
====

普通无条件跳转（汇编伪指令 J）编码为 JAL，_rd_=`x0`。

include::images/wavedrom/ct-unconditional.adoc[]

//.The unconditional-jump instruction, JAL

间接跳转指令 JALR（跳转和链接寄存器）使用 I 型编码。 通过将符号扩展的 12 位 I-立即数添加到寄存器 _rs1_ 来获取目标地址，然后将结果的最低有效位设置为零。 跳转后指令的地址（`pc`+4）被写入寄存器 _rd_。
如果结果不需要，可以使用寄存器 `x0` 作为目标寄存器。

include::images/wavedrom/ct-unconditional-2.adoc[]

//.The indirect unconditional-jump instruction, JALR

[NOTE]
====
所有无条件跳转指令均使用 PC 相对寻址以帮助支持位置无关代码。 JALR 指令定义为能够在 32 位绝对地址范围内的任意位置跳转的两指令序列。 LUI 指令可以首先将目标地址的高 20 位加载到 _rs1_ 中，然后 JALR 可以添加低位。
类似地，AUIPC 然后 JALR 可以在 32 位 `pc` 相对地址范围内的任意位置跳转。

注意，JALR 指令不像条件分支指令那样将 12 位立即数视为 2 字节的倍数。 这样避免了硬件中多一个立即数格式。 实际上，大多数使用 JALR 的情况要么有一个零立即数，要么与 LUI 或 AUIPC 配对，因此范围的轻微减少并不显著。

在计算 JALR 目标地址时清除最低有效位既简化了硬件，又允许使用函数指针的低位来存储辅助信息。 虽然这种情况下可能会略微减少错误检查，但实际上跳转到错误指令地址通常会很快引发异常。

当与基 _rs1_=`x0` 一起使用时，JALR 可用于实现从地址空间的任何位置到最低或最高地址区域的单条指令子程序调用，这可以用来实现快速调用到小型运行时库。 或者，ABI 可专用通用寄存器以指向地址空间中其他位置的库。
====

如果目标地址未对齐到四字节边界，JAL 和 JALR 指令会生成指令地址未对齐异常。

[NOTE]
====
对于支持 16 位对齐指令扩展的机器，例如压缩指令集扩展 C，指令地址未对齐异常是不可能的。
====

返回地址预测栈是高性能指令获取单元的常见功能，但需要准确检测用于过程调用和返回的指令才能有效。
对于 RISC-V，关于指令用法的提示通过使用的寄存器号码隐式编码。 仅当 _rd_ 为 'x1' 或 `x5` 时，JAL 指令应将返回地址推入返回地址栈 (RAS)。 JALR 指令应按 <<rashints>> 中所示推入/弹出一个 RAS。

[[rashints]]
.JALR 指令的寄存器操作数中编码了返回地址栈预测提示。
[%autowidth, float="center", align="center", cols="^,^,^,<", options="header"]
|===
|_rd_ 是 _x1/x5_ |_rs1_ 是 _x1/x5_ |_rd_=_rs1_ |RAS 操作

|无 |无 |-- |无

|无 |是 |-- |弹出

|是 |无 |-- |入栈

|是 |是 |无 |先弹出，再入栈

|是 |是 |是 |入栈
|===

[NOTE]
====
其他一些指令集架构在它们的间接跳转指令中添加了显式提示位，以指导返回地址栈操作。 我们使用与寄存器号码和调用约定绑定的隐式提示来减少用于这些提示的编码空间。

当两个不同的链接寄存器（`x1` 和 `x5`）作为 _rs1_ 和 _rd_ 给出时，RAS 同时出栈和入栈以支持协程。 如果 _rs1_ 和 _rd_ 是相同的链接寄存器（`x1` 或 `x5`），则 RAS 仅推入以启用序列的宏操作融合：
`lui ra, imm20; jalr ra, imm12(ra)` 和 `auipc ra, imm20; jalr ra, imm12(ra)`
====

==== Conditional Branches

All branch instructions use the B-type instruction format. The 12-bit
B-immediate encodes signed offsets in multiples of 2 bytes. The offset
is sign-extended and added to the address of the branch instruction to
give the target address. The conditional branch range is
&#177;4 KiB.

include::images/wavedrom/ct-conditional.adoc[]

//.Conditional branches

Branch instructions compare two registers. BEQ and BNE take the branch
if registers _rs1_ and _rs2_ are equal or unequal respectively. BLT and
BLTU take the branch if _rs1_ is less than _rs2_, using signed and
unsigned comparison respectively. BGE and BGEU take the branch if _rs1_
is greater than or equal to _rs2_, using signed and unsigned comparison
respectively. Note, BGT, BGTU, BLE, and BLEU can be synthesized by
reversing the operands to BLT, BLTU, BGE, and BGEU, respectively.

[NOTE]
====
Signed array bounds may be checked with a single BLTU instruction, since
any negative index will compare greater than any nonnegative bound.
====

Software should be optimized such that the sequential code path is the
most common path, with less-frequently taken code paths placed out of
line. Software should also assume that backward branches will be
predicted taken and forward branches as not taken, at least the first
time they are encountered. Dynamic predictors should quickly learn any
predictable branch behavior.

Unlike some other architectures, the RISC-V jump (JAL with _rd_=`x0`)
instruction should always be used for unconditional branches instead of
a conditional branch instruction with an always-true condition. RISC-V
jumps are also PC-relative and support a much wider offset range than
branches, and will not pollute conditional-branch prediction tables.

[TIP]
====
The conditional branches were designed to include arithmetic comparison
operations between two registers (as also done in PA-RISC, Xtensa, and
MIPS R6), rather than use condition codes (x86, ARM, SPARC, PowerPC), or
to only compare one register against zero (Alpha, MIPS), or two
registers only for equality (MIPS). This design was motivated by the
observation that a combined compare-and-branch instruction fits into a
regular pipeline, avoids additional condition code state or use of a
temporary register, and reduces static code size and dynamic instruction
fetch traffic. Another point is that comparisons against zero require
non-trivial circuit delay (especially after the move to static logic in
advanced processes) and so are almost as expensive as arithmetic
magnitude compares. Another advantage of a fused compare-and-branch
instruction is that branches are observed earlier in the front-end
instruction stream, and so can be predicted earlier. There is perhaps an
advantage to a design with condition codes in the case where multiple
branches can be taken based on the same condition codes, but we believe
this case to be relatively rare.

We considered but did not include static branch hints in the instruction
encoding. These can reduce the pressure on dynamic predictors, but
require more instruction encoding space and software profiling for best
results, and can result in poor performance if production runs do not
match profiling runs.

We considered but did not include conditional moves or predicated
instructions, which can effectively replace unpredictable short forward
branches. Conditional moves are the simpler of the two, but are
difficult to use with conditional code that might cause exceptions
(memory accesses and floating-point operations). Predication adds
additional flag state to a system, additional instructions to set and
clear flags, and additional encoding overhead on every instruction. Both
conditional move and predicated instructions add complexity to
out-of-order microarchitectures, adding an implicit third source operand
due to the need to copy the original value of the destination
architectural register into the renamed destination physical register if
the predicate is false. Also, static compile-time decisions to use
predication instead of branches can result in lower performance on
inputs not included in the compiler training set, especially given that
unpredictable branches are rare, and becoming rarer as branch prediction
techniques improve.

We note that various microarchitectural techniques exist to dynamically
convert unpredictable short forward branches into internally predicated
code to avoid the cost of flushing pipelines on a branch mispredict cite:[heil-tr1996], cite:[Klauser-1998], cite:[Kim-micro2005] and
have been implemented in commercial processors  cite:[ibmpower7]. The simplest techniques
just reduce the penalty of recovering from a mispredicted short forward
branch by only flushing instructions in the branch shadow instead of the
entire fetch pipeline, or by fetching instructions from both sides using
wide instruction fetch or idle instruction fetch slots. More complex
techniques for out-of-order cores add internal predicates on
instructions in the branch shadow, with the internal predicate value
written by the branch instruction, allowing the branch and following
instructions to be executed speculatively and out-of-order with respect
to other code.
====

The conditional branch instructions will generate an
instruction-address-misaligned exception if the target address is not
aligned to a four-byte boundary and the branch condition evaluates to
true. If the branch condition evaluates to false, the
instruction-address-misaligned exception will not be raised.

[NOTE]
====
Instruction-address-misaligned exceptions are not possible on machines
that support extensions with 16-bit aligned instructions, such as the
compressed instruction-set extension, C.
====

[[ldst]]
=== Load and Store Instructions

RV32I is a load-store architecture, where only load and store
instructions access memory and arithmetic instructions only operate on
CPU registers. RV32I provides a 32-bit address space that is
byte-addressed. The EEI will define what portions of the address space
are legal to access with which instructions (e.g., some addresses might
be read only, or support word access only). Loads with a destination of
`x0` must still raise any exceptions and cause any other side effects
even though the load value is discarded.

The EEI will define whether the memory system is little-endian or
big-endian. In RISC-V, endianness is byte-address invariant.

[TIP]
====
In a system for which endianness is byte-address invariant, the
following property holds: if a byte is stored to memory at some address
in some endianness, then a byte-sized load from that address in any
endianness returns the stored value.

In a little-endian configuration, multibyte stores write the
least-significant register byte at the lowest memory byte address,
followed by the other register bytes in ascending order of their
significance. Loads similarly transfer the contents of the lesser memory
byte addresses to the less-significant register bytes.

In a big-endian configuration, multibyte stores write the
most-significant register byte at the lowest memory byte address,
followed by the other register bytes in descending order of their
significance. Loads similarly transfer the contents of the greater
memory byte addresses to the less-significant register bytes.
====

include::images/wavedrom/load_store.adoc[]

//.Load and store instructions

Load and store instructions transfer a value between the registers and
memory. Loads are encoded in the I-type format and stores are S-type.
The effective address is obtained by adding register _rs1_ to the
sign-extended 12-bit offset. Loads copy a value from memory to register
_rd_. Stores copy the value in register _rs2_ to memory.

The LW instruction loads a 32-bit value from memory into _rd_. LH loads
a 16-bit value from memory, then sign-extends to 32-bits before storing
in _rd_. LHU loads a 16-bit value from memory but then zero extends to
32-bits before storing in _rd_. LB and LBU are defined analogously for
8-bit values. The SW, SH, and SB instructions store 32-bit, 16-bit, and
8-bit values from the low bits of register _rs2_ to memory.

Regardless of EEI, loads and stores whose effective addresses are
naturally aligned shall not raise an address-misaligned exception. Loads
and stores whose effective address is not naturally aligned to the
referenced datatype (i.e., the effective address is not divisible by the
size of the access in bytes) have behavior dependent on the EEI.

An EEI may guarantee that misaligned loads and stores are fully
supported, and so the software running inside the execution environment
will never experience a contained or fatal address-misaligned trap. In
this case, the misaligned loads and stores can be handled in hardware,
or via an invisible trap into the execution environment implementation,
or possibly a combination of hardware and invisible trap depending on
address.

An EEI may not guarantee misaligned loads and stores are handled
invisibly. In this case, loads and stores that are not naturally aligned
may either complete execution successfully or raise an exception. The
exception raised can be either an address-misaligned exception or an
access-fault exception. For a memory access that would otherwise be able
to complete except for the misalignment, an access-fault exception can
be raised instead of an address-misaligned exception if the misaligned
access should not be emulated, e.g., if accesses to the memory region
have side effects. When an EEI does not guarantee misaligned loads and
stores are handled invisibly, the EEI must define if exceptions caused
by address misalignment result in a contained trap (allowing software
running inside the execution environment to handle the trap) or a fatal
trap (terminating execution).

[TIP]
====
Misaligned accesses are occasionally required when porting legacy code,
and help performance on applications when using any form of packed-SIMD
extension or handling externally packed data structures. Our rationale
for allowing EEIs to choose to support misaligned accesses via the
regular load and store instructions is to simplify the addition of
misaligned hardware support. One option would have been to disallow
misaligned accesses in the base ISAs and then provide some separate ISA
support for misaligned accesses, either special instructions to help
software handle misaligned accesses or a new hardware addressing mode
for misaligned accesses. Special instructions are difficult to use,
complicate the ISA, and often add new processor state (e.g., SPARC VIS
align address offset register) or complicate access to existing
processor state (e.g., MIPS LWL/LWR partial register writes). In
addition, for loop-oriented packed-SIMD code, the extra overhead when
operands are misaligned motivates software to provide multiple forms of
loop depending on operand alignment, which complicates code generation
and adds to loop startup overhead. New misaligned hardware addressing
modes take considerable space in the instruction encoding or require
very simplified addressing modes (e.g., register indirect only).
====

Even when misaligned loads and stores complete successfully, these
accesses might run extremely slowly depending on the implementation
(e.g., when implemented via an invisible trap). Furthermore, whereas
naturally aligned loads and stores are guaranteed to execute atomically,
misaligned loads and stores might not, and hence require additional
synchronization to ensure atomicity.

[NOTE]
====
We do not mandate atomicity for misaligned accesses so execution
environment implementations can use an invisible machine trap and a
software handler to handle some or all misaligned accesses. If hardware
misaligned support is provided, software can exploit this by simply
using regular load and store instructions. Hardware can then
automatically optimize accesses depending on whether runtime addresses
are aligned.
====

[[fence]]
=== Memory Ordering Instructions

include::images/wavedrom/mem_order.adoc[]

//.Memory ordering instructions

The FENCE instruction is used to order device I/O and memory accesses as
viewed by other RISC-V harts and external devices or coprocessors. Any
combination of device input (I), device output (O), memory reads \(R),
and memory writes (W) may be ordered with respect to any combination of
the same. Informally, no other RISC-V hart or external device can
observe any operation in the _successor_ set following a FENCE before
any operation in the _predecessor_ set preceding the FENCE.
<<memorymodel>> provides a precise description
of the RISC-V memory consistency model.

The FENCE instruction also orders memory reads and writes made by the
hart as observed by memory reads and writes made by an external device.
However, FENCE does not order observations of events made by an external
device using any other signaling mechanism.

[NOTE]
====
A device might observe an access to a memory location via some external
communication mechanism, e.g., a memory-mapped control register that
drives an interrupt signal to an interrupt controller. This
communication is outside the scope of the FENCE ordering mechanism and
hence the FENCE instruction can provide no guarantee on when a change in
the interrupt signal is visible to the interrupt controller. Specific
devices might provide additional ordering guarantees to reduce software
overhead but those are outside the scope of the RISC-V memory model.
====

The EEI will define what I/O operations are possible, and in particular,
which memory addresses when accessed by load and store instructions will
be treated and ordered as device input and device output operations
respectively rather than memory reads and writes. For example,
memory-mapped I/O devices will typically be accessed with uncached loads
and stores that are ordered using the I and O bits rather than the R and
W bits. Instruction-set extensions might also describe new I/O
instructions that will also be ordered using the I and O bits in a
FENCE.

[[fm]]
[float="center", align="center", cols="^1,^1,<3", options="header"]
.Fence mode encoding
|===
|_fm_ field
|Mnemonic
|Meaning

|0000 |_none_ |Normal Fence

|1000 |TSO |With `FENCE RW,RW`: exclude write-to-read ordering; otherwise: _Reserved for future use._

2+|_other_ |_Reserved for future use._
|===

The fence mode field _fm_ defines the semantics of the `FENCE`. A `FENCE`
with _fm_=`0000` orders all memory operations in its predecessor set
before all memory operations in its successor set.

The `FENCE.TSO` instruction is encoded as a `FENCE` instruction
with _fm_=`1000`, _predecessor_=`RW`, and _successor_=`RW`. `FENCE.TSO` orders
all load operations in its predecessor set before all memory operations
in its successor set, and all store operations in its predecessor set
before all store operations in its successor set. This leaves `non-AMO`
store operations in the `FENCE.TSO's` predecessor set unordered with
`non-AMO` loads in its successor set.

[NOTE]
====
Because FENCE RW,RW imposes a superset of the orderings that FENCE.TSO
imposes, it is correct to ignore the _fm_ field and implement FENCE.TSO as FENCE RW,RW.
====

The unused fields in the `FENCE` instructions--_rs1_ and _rd_--are reserved
for finer-grain fences in future extensions. For forward compatibility,
base implementations shall ignore these fields, and standard software
shall zero these fields. Likewise, many _fm_ and predecessor/successor
set settings in <<fm>> are also reserved for future use.
Base implementations shall treat all such reserved configurations as
normal fences with _fm_=0000, and standard software shall use only
non-reserved configurations.

[TIP]
====
We chose a relaxed memory model to allow high performance from simple
machine implementations and from likely future coprocessor or
accelerator extensions. We separate out I/O ordering from memory R/W
ordering to avoid unnecessary serialization within a device-driver hart
and also to support alternative non-memory paths to control added
coprocessors or I/O devices. Simple implementations may additionally
ignore the _predecessor_ and _successor_ fields and always execute a
conservative fence on all operations.
====

=== Environment Call and Breakpoints

`SYSTEM` instructions are used to access system functionality that might
require privileged access and are encoded using the I-type instruction
format. These can be divided into two main classes: those that
atomically read-modify-write control and status registers (CSRs), and
all other potentially privileged instructions. CSR instructions are
described in <<csrinsts>>, and the base
unprivileged instructions are described in the following section.

[TIP]
====
The SYSTEM instructions are defined to allow simpler implementations to
always trap to a single software trap handler. More sophisticated
implementations might execute more of each system instruction in
hardware.
====

include::images/wavedrom/env_call-breakpoint.adoc[]

//.Environment call and breakpoint instructions

These two instructions cause a precise requested trap to the supporting
execution environment.

The `ECALL` instruction is used to make a service request to the execution
environment. The `EEI` will define how parameters for the service request
are passed, but usually these will be in defined locations in the
integer register file.

The `EBREAK` instruction is used to return control to a debugging
environment.

[NOTE]
====
ECALL and EBREAK were previously named SCALL and SBREAK. The
instructions have the same functionality and encoding, but were renamed
to reflect that they can be used more generally than to call a
supervisor-level operating system or debugger.
====

[TIP]
====
EBREAK was primarily designed to be used by a debugger to cause
execution to stop and fall back into the debugger. EBREAK is also used
by the standard gcc compiler to mark code paths that should not be
executed.

Another use of EBREAK is to support "semihosting", where the execution
environment includes a debugger that can provide services over an
alternate system call interface built around the EBREAK instruction.
Because the RISC-V base ISAs do not provide more than one EBREAK
instruction, RISC-V semihosting uses a special sequence of instructions
to distinguish a semihosting EBREAK from a debugger inserted EBREAK.

[source,asm]
....
    slli x0, x0, 0x1f   # Entry NOP
    ebreak              # Break to debugger
    srai x0, x0, 7      # NOP encoding the semihosting call number 7
....

Note that these three instructions must be 32-bit-wide instructions,
i.e., they mustn't be among the compressed 16-bit instructions described
in <<compressed>>.

The shift NOP instructions are still considered available for use as
HINTs.

Semihosting is a form of service call and would be more naturally
encoded as an ECALL using an existing ABI, but this would require the
debugger to be able to intercept ECALLs, which is a newer addition to
the debug standard. We intend to move over to using ECALLs with a
standard ABI, in which case, semihosting can share a service ABI with an
existing standard.

We note that ARM processors have also moved to using SVC instead of BKPT
for semihosting calls in newer designs.
====

=== HINT Instructions

//[#rv32i-hints,HINT Instructions]

RV32I reserves a large encoding space for HINT instructions, which are
usually used to communicate performance hints to the microarchitecture.
Like the NOP instruction, HINTs do not change any architecturally
visible state, except for advancing the `pc` and any applicable
performance counters. Implementations are always allowed to ignore the
encoded hints.

Most RV32I HINTs are encoded as integer computational instructions with
_rd_=x0. The other RV32I HINTs are encoded as FENCE instructions with
a null predecessor or successor set and with _fm_=0.

[NOTE]
====
These HINT encodings have been chosen so that simple implementations can
ignore HINTs altogether, and instead execute a HINT as a regular
instruction that happens not to mutate the architectural state. For
example, ADD is a HINT if the destination register is `x0`; the five-bit
_rs1_ and _rs2_ fields encode arguments to the HINT. However, a simple
implementation can simply execute the HINT as an ADD of _rs1_ and _rs2_
that writes `x0`, which has no architecturally visible effect.

As another example, a FENCE instruction with a zero _pred_ field and a
zero _fm_ field is a HINT; the _succ_, _rs1_, and _rd_ fields encode the
arguments to the HINT. A simple implementation can simply execute the
HINT as a FENCE that orders the null set of prior memory accesses before
whichever subsequent memory accesses are encoded in the _succ_ field.
Since the intersection of the predecessor and successor sets is null,
the instruction imposes no memory orderings, and so it has no
architecturally visible effect.
====

<<t-rv32i-hints>> lists all RV32I HINT code points. 91% of the
HINT space is reserved for standard HINTs. The remainder of the HINT
space is designated for custom HINTs: no standard HINTs will ever be
defined in this subspace.

[TIP]
====
We anticipate standard hints to eventually include memory-system spatial
and temporal locality hints, branch prediction hints, thread-scheduling
hints, security tags, and instrumentation flags for simulation/emulation.
====

// this table might still have some problems--some rows might not have landed properly. It needs to be checked cell-by cell.

[[t-rv32i-hints]]
.RV32I HINT instructions.
[float="center", align="center", cols="<,<,^,<", options="header"]
|===
|Instruction
|Constraints
|Code Points
|Purpose

|LUI |_rd_=`x0` |latexmath:[$2^{20}$] .8+<.^m|_Designated for future standard use_

|AUIPC |_rd_=`x0` |latexmath:[$2^{20}$]

|ADDI |_rd_=`x0`, and either _rs1_&#8800;``x0`` or _imm_&#8800;0 |latexmath:[$2^{17}-1$]

|ANDI |_rd_=`x0` |latexmath:[$2^{17}$]

|ORI |_rd_=`x0` |latexmath:[$2^{17}$]

|XORI |_rd_=`x0` |latexmath:[$2^{17}$]

|ADD |_rd_=`x0`, _rs1_&#8800;``x0`` |latexmath:[$2^{10}-32$]

|ADD |_rd_=`x0`, _rs1_=`x0`, _rs2_&#8800;``x2-x5`` |28

|ADD |_rd_=`x0`, _rs1_=`x0`, _rs2_=`x2-x5` |4 |(_rs2_=`x2`) NTL.P1 +
(_rs2_=`x3`) NTL.PALL +
(_rs2_=`x4`) NTL.S1 +
(_rs2_=`x5`) NTL.ALL

|SUB |_rd_=`x0` |latexmath:[$2^{10}$] 11+<.^m|_Designated for future standard use_

|AND |_rd_=`x0` |latexmath:[$2^{10}$]

|OR |_rd_=`x0` |latexmath:[$2^{10}$]

|XOR |_rd_=`x0` |latexmath:[$2^{10}$]

|SLL |_rd_=`x0` |latexmath:[$2^{10}$]

|SRL |_rd_=`x0` |latexmath:[$2^{10}$]

|SRA |_rd_=`x0` |latexmath:[$2^{10}$]

|FENCE |_rd_=`x0`, _rs1_&#8800;``x0``, _fm_=0, and either _pred_=0 or _succ_=0 |latexmath:[$2^{10}-63$]

|FENCE |_rd_&#8800;``x0``, _rs1_=`x0`, _fm_=0, and either _pred_=0 or _succ_=0 |latexmath:[$2^{10}-63$]

|FENCE |_rd_=_rs1_=`x0`, _fm_=0, _pred_=0, _succ_&#8800;0 |15

|FENCE |_rd_=_rs1_=`x0`, _fm_=0, _pred_&#8800;W, _succ_=0 |15

|FENCE |_rd_=_rs1_=`x0`, _fm_=0, _pred_=W, _succ_=0 |1 |PAUSE

4+|

|SLTI |_rd_=`x0` |latexmath:[$2^{17}$] .7+<.^m|_Designated for custom use_

|SLTIU |_rd_=`x0` |latexmath:[$2^{17}$]

|SLLI |_rd_=`x0` |latexmath:[$2^{10}$]

|SRLI |_rd_=`x0` |latexmath:[$2^{10}$]

|SRAI |_rd_=`x0` |latexmath:[$2^{10}$]

|SLT |_rd_=`x0` |latexmath:[$2^{10}$]

|SLTU |_rd_=`x0` |latexmath:[$2^{10}$]
|===