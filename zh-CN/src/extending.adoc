[[extending]]
== 扩展 RISC-V

除了支持标准通用软件开发之外，RISC-V 的另一个目标是为更专业的指令集扩展或更定制的加速器提供基础。 指令编码空间和可选的可变长度指令编码的设计旨在使得在构建更定制的处理器时，更容易利用标准 ISA 工具链的软件开发努力。 例如，意图是继续为仅使用标准 I 基础的实现提供全软件支持，可能与许多非标准指令集扩展一起使用。

本章描述了多种扩展基础 RISC-V ISA 的方式，以及由独立团体开发的管理指令集扩展的方案。 本卷仅涉及非特权 ISA，尽管在第二卷中描述的监督级别扩展中也使用相同的方法和术语。

=== 扩展术语

本节定义了一些描述 RISC-V 扩展的标准术语。

==== 标准与非标准扩展

任何 RISC-V 处理器实现都必须支持一个基本整数 ISA (RV32I, RV32E, RV64I, RV64E, 或 RV128I)。 此外，实现可以支持一个或多个扩展。 我们将扩展分为两个大类：_标准_与_非标准_。

* 标准扩展是指通常有用且设计成不会与任何其他标准扩展冲突的扩展。 目前，"MAFDQLCBTPV"，在本手册的其他章节中描述，要么是完整的，要么是计划中的标准扩展。
* 非标准扩展可能高度专业化，并且可能与其他标准或非标准扩展冲突。 我们预计随着时间的推移，将开发出多种非标准扩展，其中一些最终将被提升为标准扩展。

==== 指令编码空间和前缀

指令编码空间是某个数量的指令位，基础 ISA 或 ISA 扩展在其中被编码。 RISC-V 支持不同的指令长度，但即使在单一指令长度内，也有各种大小的编码空间可用。 例如，基础 ISA 定义在 30 位编码空间内（32 位指令的第 31-2 位），而原子扩展 "A" 适合在 25 位编码空间内（31-7 位）。

我们用术语 _前缀_ 来指代指令编码空间右侧的位（由于 RISC-V 中的指令获取是小端序，右侧的位存储在较早的内存地址，因此在指令获取顺序中形成前缀）。 标准基础 ISA 编码的前缀是位于32位字中第1-0位的两位"11"字段，而标准原子扩展"A"的前缀是位于32位字中代表AMO主操作码的第6-0位的七位"0101111"字段。 编码格式的一个特点是用于编码次操作码的3位funct3字段在32位指令格式中与主操作码位不连续，但被视为22位指令空间前缀的一部分。

尽管指令编码空间可以是任何大小，采用较小的通用大小集合可简化独立开发的扩展打包到单一全球编码中。
<<encodingspaces>> 给出了 RISC-V 建议的大小。

[[encodingspaces]]
.建议的标准 RISC-V 指令编码空间大小。
[%autowidth, float="center", align="center", cols="^,<,>,>,>,>", options="header"]
|===
|大小 |用法 4+^|# 标准指令长度可用

| | |16 位 |32 位 |48 位 |64 位

6+|

|14 位 |压缩 16 位编码象限 |3 | | |

6+|

|22 位 |基础 32 位编码中的次操作码 | |latexmath:[$2^{8}$]
|latexmath:[$2^{20}$] |latexmath:[$2^{35}$]

|25 位 |基础 32 位编码中的主操作码 | |32
|latexmath:[$2^{17}$] |latexmath:[$2^{32}$]

|30 位 |基础 32 位编码象限 | |1 |latexmath:[$2^{12}$]
|latexmath:[$2^{27}$]

6+|

|32 位 |48 位编码中的次操作码 | | |latexmath:[$2^{10}$]
|latexmath:[$2^{25}$]

|37 位 |48 位编码中的主操作码 | | |32 |latexmath:[$2^{20}$]

|40 位 |48 位编码象限 | | |4 |latexmath:[$2^{17}$]

6+|

|45 位 |64 位编码中的次次操作码 | | | |latexmath:[$2^{12}$]

|48 位 |64 位编码中的次操作码 | | | |latexmath:[$2^{9}$]

|52 位 |64 位编码中的主操作码 | | | |32
|===

==== Greenfield 与 Brownfield 扩展

我们用术语 _greenfield extension_ 来描述开始填充新指令编码空间的扩展，因此只能在前缀级别引起编码冲突。 我们用术语 _brownfield extension_ 来描述适合于以前定义的指令空间的现有编码周围的扩展。 一个棕地扩展必然与特定的绿地父编码绑定，并且可能有多个棕地扩展到相同的绿地父编码。 例如，基础 ISA 是 30 位指令空间的 greenfield 编码，而 FDQ 浮点扩展都是 brownfield 扩展，添加到父基础 ISA 30 位编码空间。

请注意，我们认为标准 A 扩展具有 greenfield 编码，因为它在完整 32 位基础指令编码的最左侧位中定义了一个新的先前空的 25 位编码空间，尽管其标准前缀将其定位在其父基础 ISA 的 30 位编码空间内。 仅更改其单一 7 位前缀可以将 A 扩展移动到不同的 30 位编码空间，同时只关注前缀级别的冲突，而不是编码空间内的冲突。

.标准指令集扩展的二维表征。
[cols="^,^,^", options="header"]
[%autowidth, float="center", align="center"]
|===
| |添加状态 |无新状态

|Greenfield |RV32I(30), RV64I(30) |A(25)

|Brownfield |F(I)，D(F)，Q(D) |M(I)
|===

<<exttax>> 显示了在一个简单的二维分类中放置的基础和标准扩展。 一个轴是扩展是 greenfield 还是 brownfield，另一个轴是扩展是否增加了架构状态。 对于 greenfield 扩展，指令编码空间的大小在括号中给出。 对于 brownfield 扩展，扩展（greenfield 或 brownfield）所构建的名称在括号中给出。 额外的用户级架构状态通常意味着对监督级系统或可能对标准调用约定的更改。

请注意，RV64I 不被视为 RV32I 的扩展，而是一个不同的完整基础编码。

==== 标准兼容的全球编码

实际 RISC-V 实现的 ISA 的完整或 _全球_ 编码必须为每个包括的指令编码空间分配一个唯一的不冲突前缀。 基础和每个标准扩展都有各自的标准前缀分配，以确保它们都可以在全球编码中共存。

_标准兼容的_ 全球编码是基础和每个包括的标准扩展都具有其标准前缀的编码。 标准兼容的全球编码可以包含不与包括的标准扩展冲突的非标准扩展。 标准兼容的全球编码还可以使用非标准扩展的标准前缀，如果相关的标准扩展不包含在全球编码中。 换句话说，如果包括在标准兼容的全球编码中，标准扩展必须使用其标准前缀，否则其前缀可以自由重新分配。 这些限制允许通用工具链针对任何 RISC-V 标准兼容的全球编码的标准子集。

==== 保证的非标准编码空间

为了支持专有定制扩展的开发，保证编码空间的部分区域不会被标准扩展使用。

=== RISC-V 扩展设计理念

我们打算通过鼓励扩展开发人员在指令编码空间内操作，并提供工具将这些扩展打包为标准兼容的全球编码，通过分配唯一的前缀，来支持大量独立开发的扩展。 一些扩展更自然地实现为对现有扩展的 brownfield 增强，并将共享分配给其父 greenfield 扩展的任何前缀。 标准扩展前缀避免了核心功能编码中的虚假不兼容，同时允许更多专业扩展的自定义打包。

这种将 RISC-V 扩展重新打包到不同标准兼容的全球编码中的能力可以用多种方式使用。

一种使用场景是开发高度专业的定制加速器，设计来运行重要应用领域的内核。 这些可能想要删除除基础整数 ISA 外的所有内容，只添加执行任务所需的扩展。 基础 ISA 设计的目的是对硬件实现施加最小的要求，并被编码为仅使用 32 位指令编码空间的小部分。

另一种使用场景是为新类型的指令集扩展构建研究原型。 研究人员可能不希望花费精力实现可变长度指令获取单元，因此希望使用简单的 32 位固定宽度指令编码来对其扩展进行原型测试。 然而，这个新扩展可能太大而无法与标准扩展在 32 位空间共存。 如果研究实验不需要所有标准扩展，标准兼容的全球编码可能会删除未使用的标准扩展，并重新使用其前缀将建议的扩展放在非标准位置，以简化研究原型的工程。
标准工具仍然能够定位基础和任何存在的标准扩展，以减少开发时间。 一旦指令集拓展被评估和精炼，可以将其用于更大的可变长度编码空间的打包，以避免与所有标准扩展的冲突。

以下各节描述了用于开发含有新指令集拓展的实现的越来越复杂的策略。
这些策略主要用于高度定制的、教育的或实验性的架构，而不是 RISC-V ISA 开发的主要路线。

[[fix32b]]
=== 固定宽度 32 位指令格式内的扩展

本节讨论将扩展添加到仅支持基础固定宽度 32 位指令格式的实现中。

[NOTE]
====
我们预测最简单的固定宽度 32 位编码将在许多受限加速器和研究原型上普遍使用。
====

==== 可用的 30 位指令编码空间

在标准编码中，可用的30位指令编码空间中的三个（具有2位前缀`00`、`01`和`10`）用于启用可选的压缩指令扩展。 但是，如果不需要压缩指令集扩展，则这三个 30 位编码空间进一步可用。 这使得在 32 位格式中可用的编码空间增加了四倍。

==== 可用的 25 位指令编码空间

25 位指令编码空间对应于基础和标准扩展编码中的主操作码。

有四个专门为定制扩展指定的主操作码 <<opcodemap>>，每个代表一个 25 位编码空间。 其中两个保留用于将来在RV128基础编码中使用（将是OP-IMM-64和OP-64），但可以用于RV32和RV64的非标准扩展。

另外两个保留用于RV64的主操作码（OP-IMM-32和OP-32）也可用于RV32的非标准扩展。

如果实现不需要浮点数，则为标准浮点扩展保留的七个主操作码（LOAD-FP、STORE-FP、MADD、MSUB、NMSUB、NMADD、OP-FP）可以被重新使用用于非标准扩展。 类似地，如果不需要标准原子扩展，则可以重新使用 AMO 主操作码。

如果实现不需要长于 32 位的指令，则还可以使用另外四个主操作码（在 <<opcodemap>> 中用灰色标记）。

基础RV32I编码仅使用了11个主操作码加3个保留操作码，留下多达18个用于扩展。 基础RV64I编码仅使用了13个主操作码加3个保留操作码，留下多达16个用于扩展。

==== 可用的 22 位指令编码空间

22位编码空间对应于基础和标准扩展编码中的funct3次操作码空间。 几个主操作码具有一个funct3字段次操作码，未完全占用，留下几个可用的22位编码空间。

通常情况下，一个主操作码选择用于在指令的其余位中编码操作数的格式，理想情况下，一个扩展应遵循主操作码的操作数格式以简化硬件解码。

==== 其他空间

在某些主操作码下可用较小的空间，并不是所有次操作码都完全填满。

=== 添加对齐的 64 位指令扩展

为那些对基础 32 位固定宽度指令格式来说太大的扩展提供空间的最简单方法是添加自然对齐的 64 位指令。 实现仍然必须支持 32 位基础指令格式，但可以要求 64 位指令在 64 位边界上对齐，以简化指令获取，在必要时使用 32 位 NOP 指令作为对齐填充。

为了简化标准工具的使用，应如 <<instlengthcode, Table 1>> 中描述的那样对 64 位指令进行编码。
然而，实施可能选择 64 位指令的非标准指令长度编码，同时保留 32 位指令的标准编码。 例如，如果不需要压缩指令，则可以使用指令的前两位中的一个或多个零位对 64 位指令进行编码。

[NOTE]
====
我们预计处理器生成器会生成能够自动处理任何支持的变长指令编码组合的指令获取单元。
====

=== 支持 VLIW 编码

尽管 RISC-V 不是为纯粹的 VLIW 机器设计的，但可以使用几种替代方法将 VLIW 编码添加为扩展。 在所有情况下，都必须支持基础 32 位编码以允许使用任何标准软件工具。

==== 固定大小指令组

最简单的方法是在其中编码 VLIW 操作，定义一个大的自然对齐的指令格式（例如，128 位）。 在传统的 VLIW 中，这种方法往往会浪费指令内存以保存 NOP，但 RISC-V 兼容实现还必须支持基础 32 位指令，将 VLIW 代码大小扩展限制在 VLIW 加速的功能中。

==== 编码长度组

另一种方法是使用 <<instlengthcode>> 中的标准长度编码来编码并行指令组，允许 NOP 被压缩出 VLIW 指令。 例如，一个 64 位指令可以容纳两个 28 位操作，而一个 96 位指令可以容纳三个 28 位操作，依此类推。 或者，一个 48 位指令可以容纳一个 42 位操作，而一个 96 位指令可以容纳两个 42 位操作，依此类推。

这种方法的优点是保留了 ISA 编码用于包含单个操作的指令，但具有为 VLIW 指令内的操作引入新的 28 位或 42 位编码以及较大组的未对齐指令获取的缺点。 一种简化是禁止 VLIW 指令跨越某些微架构上重要的边界（例如，缓存行或虚拟内存页）。

==== 固定尺寸指令包

另一种方法，类似于 Itanium，是使用更大的自然对齐的固定指令包大小（例如，128 位），跨其编码并行操作组。 这简化了指令获取，但将复杂性转移到组执行引擎中。 为了保持 RISC-V 兼容，基础 32 位指令仍须支持。

==== 前缀中组结束位

上述方法都没有保留VLIW指令中单个操作的RISC-V编码。 另一种方法是重新利用固定宽度32位编码中的两个前缀位。 若设置其中一位可以用于标识"组结束"，而另一位若未设置则可指示由谓语执行。 标准RISC-V 32位指令由未意识到VLIW扩展的工具生成，会将两个前缀位都设置（11），因此具有正确的语义，每个指令位于组的末尾且未谓语化。

这种方法的主要缺点是基础ISA缺乏通常在种VLIW系统中需要的复杂谓词支持，并且标准30位编码空间难以增加更多谓词寄存器以解决空间不足。