[[counters]]
== “Zicntr”和“Zihpm”计数器扩展，版本2.0

RISC-V ISA 提供了一组最多可达三十二个 64 位性能计数器和定时器，这些计数器和定时器可以通过非特权 XLEN 位只读 CSR 寄存器 `0xC00`–`0xC1F` 访问（当 XLEN=32 时，高 32 位通过 CSR 寄存器 `0xC80`–`0xC9F` 访问）。 这些计数器分为“Zicntr”和“Zihpm”扩展。

=== 用于基本计数器和定时器的“Zicntr”扩展

Zicntr标准扩展包括前三个计数器（CYCLE、TIME和INSTRET），它们具有专用功能（分别为周期计数、实时钟和指令退休）。
Zicntr扩展依赖于Zicsr扩展。

[TIP]
====
我们建议在实现中提供这些基本计数器，因为它们对于基本性能分析、自适应和动态优化以及允许应用程序使用实时数据流是必不可少的。 在单独的Zihpm扩展中，附加的计数器可以帮助诊断性能问题，并且这些计数器应当以低开销从用户级应用程序代码中访问。

某些执行环境可能禁止访问计数器，例如，为了防止时间侧信道攻击。
====

include::images/wavedrom/counters-diag.adoc[]

对于 XLEN&#8805;64 的基本 ISA，CSR 指令可以直接访问完整的 64 位 CSR。 特别是，RDCYCLE、RDTIME和RDINSTRET伪指令读取`cycle`、`time`和`instret`计数器的完整64位。

[TIP]
====
计数器伪指令映射到只读的 `csrrs rd, counter, x0` 规范形式，但其他只读 CSR 指令形式（基于 CSRRC/CSRRSI/CSRRCI）也可以合法读取这些 CSR。
====

对于XLEN=32的基本ISA，Zicntr扩展允许以32位段访问三个64位只读计数器。 RDCYCLE、RDTIME和RDINSTRET伪指令提供低32位，RDCYCLEH、RDTIMEH和RDINSTRETH伪指令提供相应计数器的高32位。

[TIP]
====
我们要求计数器宽度为64位，即使XLEN=32，因为否则软件很难确定值是否溢出。 对于低端实现，每个计数器的高32位可以使用软件计数器实现，通过捕获溢出的下32位来触发陷阱处理程序递增。 下面的示例代码显示了如何使用单个32位宽度的伪指令安全读取完整的64位宽度值。
====

RDCYCLE伪指令读取`cycle` CSR的低XLEN位，该寄存器保存处理器核心从过去任意开始时间执行的时钟周期数。 当 XLEN=32 时，仅存在 RDCYCLEH，读取相同周期计数器的位 63-32。 在实践中，基础的64位计数器不应溢出。 周期计数器增加的速率将取决于实现和操作环境。 执行环境应提供一种方法来确定周期计数器增加的当前速率（周期/秒）。

[TIP]
====
RDCYCLE旨在返回处理器核心而不是硬件线程执行的周期数。 给定某些实现选择（例如，AMD Bulldozer），精确定义“核心”是什么很困难。
给定实现范围（包括软件仿真），精确定义“时钟周期”也很困难，但RDCYCLE的目的是与其他性能计数器一起用于性能监控。 特别是，当存在一个硬件线程/核心时，人们希望周期计数/指令退休用于测量硬件线程的CPI。

核心不必在软件中公开，实施者可能选择假装一个物理核心上的多个硬件线程在单独的核心上运行，每个核心一个硬件线程，并为每个硬件线程提供单独的周期计数器。 这在一个简单的排队处理器（例如，CDC 6600 外围处理器）中可能有意义，在那里硬件线程之间的时间交互不存在或最小。

在存在多个硬件线程/核心和动态多线程的情况下，通常无法分开每个硬件线程的周期（尤其是有SMT时）。 有可能定义一个单独的性能计数器，试图捕获特定硬件线程正在运行的周期数，但这种定义必须足够模糊，以涵盖所有可能的线程实现。 例如，我们是否只应计算此硬件线程发布到执行的指令周期和/或任何指令退休的周期，还是包括此硬件线程占用机器资源但因其他硬件线程进入执行而无法执行的停滞周期？ 为了获得可理解的性能统计数据，可能需要包括“以上所有”。 定义每个硬件线程周期计数器的这种复杂性，以及在调整多线程代码时无论如何需要每个核心的总周期计数，导致只对每个核心的周期计数器进行标准化，这对于常见的单个硬件线程/核心情况也很好。

由于在执行环境中对“休眠”进行标准化是不现实的，但如果整个核心暂停（完全时钟门控或在深度休眠中断电），则它不会执行时钟周期，并且根据规格，周期计数不应增加。 有许多细节，例如是否应计入从电源关闭事件中唤醒后重置处理器所需的时钟周期，这些被认为是执行环境特定的细节。

即使没有适用于所有平台的精确定义，但对于大多数平台来说，这仍然是一个有用的工具，并且在这里一个不精确的、通用的、“通常正确”的标准比没有标准要好。
RDCYCLE的目的是主要用于性能监测/调优，并且规范是以此为目标编写的。
====

RDTIME伪指令读取“time” CSR的低XLEN位，计数从过去任意起始时间经过的墙上时钟的实时。 RDTIMEH 仅在 XLEN=32 时存在，并读取相同实时计数器的位 63-32。 基础的64位计数器随着每个真实时钟滴答而递增，对于实际的真实时钟频率，实践中不应溢出。 执行环境应提供一种方法确定计数器滴答的周期（秒/滴答）。 该周期应在一个小的误差范围内是常数。 环境应提供一种方法确定时钟的准确性（即标称和实际实时时钟周期之间的最大相对误差）。

[TIP]
====
在某些简单的平平台上，周期计数可能表示RDTIME的有效实现，在这种情况下，RDTIME和RDCYCLE可能返回相同的结果。

由于可能的实现平台种类繁多，难以对时钟周期提供严格的要求。 应根据平台的要求设置最大误差界限。
====

所有硬件线程的真实时钟必须在一个真实时钟滴答内同步。

[TIP]
====
与其他架构要求一样，足以表现得“仿佛”硬件线程在真实时钟的一个滴答内同步，即软件无法观察到在两个硬件线程观察到的真实时钟值之间存在更大的差距。
====

RDINSTRET伪指令读取`instret` CSR的低XLEN位，计数从过去某个任意起始点以来此硬件线程退休的指令数。 RDINSTRETH 仅在 XLEN=32 时存在，并读取相同指令计数器的位 63-32。 在实践中，基础的64位计数器不应溢出。

[TIP]
====
导致同步异常的指令，包括ECALL和EBREAK，不被视为退休，因此不增加`instret` CSR。
====

下面的代码序列将读取一个有效的 64 位周期计数器值到 `x3:x2` 中，即使该计数器在读取其上半部分和下半部分之间溢出。

[source,asm.]
.当XLEN=32时，读取64位周期计数器的示例代码。
    again:
        rdcycleh     x3
        rdcycle      x2
        rdcycleh     x4
        bne          x3, x4, again

=== 用于硬件性能计数器的“Zihpm”扩展

Zihpm 扩展包括多达 29 个额外的非特权 64 位硬件性能计数器，`hpmcounter3-hpmcounter31`。 当 XLEN=32 时，这些性能计数器的高 32 位可以通过附加的 CSR `hpmcounter3h-hpmcounter31h` 访问。 Zihpm扩展依赖于Zicsr扩展。

[TIP]
====
在某些应用程序中，能够在同一时间读取多个计数器很重要。 在多任务环境中运行时，用户线程在尝试读取计数器时可能会遇到上下文切换。 一种解决方案是用户线程在读取其他计数器之前和之后读取实时计数器，以确定在序列中间是否发生了上下文切换，在这种情况下，可以重试读取。 我们考虑过增加输出锁存器以允许用户线程原子地快照计数器值，但这会增加用户上下文的大小，特别是对于具有更丰富计数器集的实现。
====

这些附加计数器的实现数量和宽度及其计数的事件集合因平台而异。 访问未实现或配置错误的计数器可能导致非法指令异常，或可能返回一个常数值。

执行环境应提供一种方法来确定已实现的计数器的数量和宽度，以及配置每个计数器计数的事件的接口。

[TIP]
====
对于在RISC-V特权平台上实现的执行环境，特权架构手册描述了控制低特权模式对这些计数器访问的特权CSR以及设置要计数的事件的方法。

替代执行环境（例如，仅用户级软件性能模型）可能提供配置性能计数器计数事件的替代机制。

最终标准化事件设置以计数 ISA 级别指标，例如执行的浮点指令数，并可能包括一些常见的微架构指标，例如“L1 指令缓存未命中”，将是有用的。
====