== 计数器

RISC-V ISA 提供多达 32latexmath:[$\times$]64 位的性能计数器和定时器，通过非特权 XLEN 只读 CSR 寄存器 `0xC00`–`0xC1F` 访问（在 RV32 上，上 32 位通过 CSR 寄存器 `0xC80`–`0xC9F` 访问）。 前面三个（CYCLE、TIME 和 INSTRET）有专用功能（循环计数、实时时钟和指令退休），而其余计数器（如果实现）提供可编程事件计数。

=== 基本计数器和定时器

M@R@F@R@S +
& & & & +
& & & & +
& 5 & 3 & 5 & 7 +
RDCYCLE[H] & 0 & CSRRS & dest & SYSTEM +
RDTIME[H] & 0 & CSRRS & dest & SYSTEM +
RDINSTRET[H] & 0 & CSRRS & dest & SYSTEM +

RV32I 提供了一些 64 位只读用户级计数器，这些计数器映射到 12 位 CSR 地址空间，并使用 CSRRS 指令以 32 位进行访问。 在 RV64I 中，CSR 指令可以操作 64 位 CSR。 尤其是，RDCYCLE、RDTIME 和 RDINSTRET 伪指令读取 `cycle`、`time` 和 `instret` 计数器的完整 64 位。 因此，RDCYCLEH、RDTIMEH 和 RDINSTRETH 指令仅适用于 RV32I。

某些执行环境可能会禁止访问计数器以阻止时间侧信道攻击。

RDCYCLE 伪指令读取 `cycle` CSR 的低 XLEN 位，该 CSR 包含从过去某个任意开始时间运行的处理器内核所执行的时钟周期数。 RDCYCLEH 是一个仅用于 RV32I 的指令，用于读取相同循环计数器的 63–32 位。 基本 64 位计数器在实践中不应溢出。 循环计数器前进的速度将取决于实现和操作环境。 执行环境应提供一种方法来确定循环计数器递增的当前速率（周期/秒）。

RDCYCLE 旨在返回处理器内核执行的周期数，而不是 hart。 由于一些实施选择（例如，AMD Bulldozer），精确定义“内核”是困难的。
由于各种实施（包括软件模拟），精确定义“时钟周期”也很难，但意图是 RDCYCLE 与其他性能计数器一起用于性能监控。 特别是，在有一个hart/core 的情况下，人们会期望cycle-count/instructions-retired衡量hart的CPI。

内核无需完全暴露给软件，实施者可能会选择假装一个物理内核上的多个hart在一个hart/core上运行，并为每个hart提供单独的循环计数器。 这在一个简单的桶形处理器（例如 CDC 6600 外围处理器）中可能有意义，其中 hart 间的时间交互不存在或最小。

在存在多于一个hart/core和动态多线程的情况下，一般来说无法区分每个hart的周期（尤其是SMT）。 可能可以定义一个单独的性能计数器，试图捕捉特定hart正在运行的周期数，但这种定义必须非常模糊，以涵盖所有可能的线程实现。 例如，我们是否应该仅计算对该 hart 发出的任何指令执行的周期，以及/或退休的任何指令的周期，还是包括该 hart 占用但由于停顿而无法执行的周期，同时其他 hart 进入执行？ 可能需要“上述所有”才能获得可理解的性能统计数据。 定义每hart的循环数的复杂性，以及在调整多线程代码时需要每core的总周期数，导致人们仅标准化每core循环计数器，这也正好适用于常见的单hart/core情况。

标准化“休眠”期间发生的事情是不切实际的，因为“休眠”在执行环境中没有标准化，但如果整个内核暂停（完全时钟门控或在深度睡眠中电源关闭），那么它不应执行时钟周期，并且根据规格，循环计数不应增加。 有许多细节，例如，从断电事件中唤醒后重置处理器所需的时钟周期是否应该计入，这些都被认为是执行环境特定的细节。

即使没有适用于所有平台的精确定义，这仍然是大多数平台的一项有用功能，这里的不精确、常见、``通常正确''标准比没有标准要好。
RDCYCLE 的目的是主要针对性能监测/调整，规格是以此目标进行编写的。

RDTIME 伪指令读取 `time` CSR 的低 XLEN 位，该 CSR 从过去的任意开始时间计数经过的墙钟实际时间。 RDTIMEH 是一个仅用于 RV32I 的指令，用于读取相同实时时钟计数器的 63–32 位。 基础64位计数器在实际使用中不应溢出。 执行环境应提供方法来确定实时时钟计数器的周期（秒/滴答）。 周期必须是恒定的。 单个用户应用程序中的所有 hart 的实时时钟应同步到实时时钟的一滴答以内。 环境应提供一种方法来确定时钟的准确性。

在一些简单的平台上，循环计数可能代表 RDTIME 的有效实现，但在这种情况下，平台应实现 RDTIME 指令作为 RDCYCLE 的别名，以使代码更具可移植性，而不是使用 RDCYCLE 来测量墙钟时间。

RDINSTRET 伪指令读取 `instret` CSR 的低 XLEN 位，该 CSR 计数从过去某个任意起点开始该 hart 已退休的指令数。 RDINSTRETH 是一个仅用于 RV32I 的指令，用于读取同一指令计数器的 63–32 位。 基础64位计数器在实践中不应溢出。

以下代码序列将一个有效的 64 位循环计数值读取到 `x3`:`x2`，即使计数器在读取上半部分和下半部分之间溢出。

....
    again:
        rdcycleh     x3
        rdcycle      x2
        rdcycleh     x4
        bne          x3, x4, again
....

我们建议在实现中提供这些基本计数器，因为它们对于基本的性能分析、自适应和动态优化是必不可少的，并允许应用程序处理实时流。 应提供附加计数器以帮助诊断性能问题，而且这些计数器应以低开销的方式从用户级应用程序代码访问。

我们要求计数器具有 64 位宽，即使在 RV32 上，否则软件很难确定值是否溢出。
对于低端实现，每个计数器的上部32位可以使用由陷阱处理程序递增的软件计数器实现，由下部32位溢出触发。 上述示例代码展示了如何使用单个32位指令安全地读取完整的64位宽值。

在某些应用中，同时读取多个计数器的能力很重要。 在多任务环境中运行时，用户线程在尝试读取计数器时可能会遭遇上下文切换。 一种解决方案是让用户线程在读取其他计数器之前和之后读取实时计数器，以确定中间序列中是否发生了上下文切换，在这种情况下，可以重试读取。 我们考虑过添加输出闩锁，使用户线程能够原子地拍摄计数器值的快照，但这会增加用户上下文的大小，特别是对于功能更丰富的计数器实现。

=== 硬件性能计数器

已为 29 个额外的非特权 64 位硬件性能计数器分配了 CSR 空间，`hpmcounter3`–`hpmcounter31`。 对于 RV32，这些性能计数器的上 32 位可通过附加的 CSR `hpmcounter3h`–` hpmcounter31h` 访问。 这些计数器计数平台特定事件，并通过附加的特权寄存器进行配置。 这些附加计数器的数量和宽度以及它们计数的事件组是平台特定的。

特权体系结构手册描述了控制访问这些计数器的特权 CSR 并设置要计数的事件。

最终，标准化事件设置以计数 ISA 级指标将是有用的，例如执行的浮点指令数量，以及可能的一些常见微架构指标，例如“L1 指令缓存未命中”。