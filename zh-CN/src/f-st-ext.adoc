:stem: latexmath

[[single-float]]
== "F" 扩展用于单精度浮点，版本 2.2

本章描述了用于单精度浮点的标准指令集扩展，被命名为"F"，并添加了符合IEEE 754-2008算术标准的单精度浮点计算指令cite:[ieee754-2008]。 F扩展依赖于"Zicsr"扩展用于控制和状态寄存器访问。

=== F寄存器状态

F扩展增加了32个浮点寄存器，`f0-f31`，每个位宽32位，以及浮点控制和状态寄存器`fcsr`，其包含浮点单元的操作模式和异常状态。 此附加状态如 <<fprs>> 所示。 我们使用术语FLEN来描述RISC-V ISA中浮点寄存器的宽度，对于F单精度浮点扩展，FLEN=32。 大多数浮点指令在浮点寄存器文件中的值上操作。
浮点加载和存储指令在寄存器和内存之间传输浮点值。 还提供了在整数寄存器文件之间传输值的指令。

[TIP]
====
我们考虑过一个统一的寄存器文件用于整数和浮点值，因为这简化了软件寄存器分配和调用约定，并减少了总用户状态。 然而，分离的组织增加了在给定指令宽度下可访问的寄存器总数，简化了为广泛超标量发射提供足够的寄存器文件端口，支持解耦浮点单元架构，并简化了内部浮点编码技术的使用。 对于分裂寄存器文件架构，编译器支持和调用约定是公认的，并且使用浮点寄存器文件状态的脏位可以减少上下文切换的开销。
====

[[fprs]]
.RISC-V标准F扩展单精度浮点状态
[cols="<,^,>", options="header", width="50%", align="center", grid="rows"]
|===
|[.small]#FLEN-1#
|
>|[.small]#0#

3+^|[.small]#f0#

3+^|[.small]#f1#

3+^|[.small]#f2#

3+^|[.small]#f3#

3+^|[.small]#f4#

3+^|[.small]#f5#

3+^|[.small]#f6#

3+^|[.small]#f7#

3+^|[.small]#f8#

3+^|[.small]#f9#

3+^|[.small]#f10#

3+^|[.small]#f11#

3+^|[.small]#f12#

3+^|[.small]#f13#

3+^|[.small]#f14#

3+^|[.small]#f15#

3+^|[.small]#f16#

3+^|[.small]#f17#

3+^|[.small]#f18#

3+^|[.small]#f19#

3+^|[.small]#f20#

3+^|[.small]#f21#

3+^|[.small]#f22#

3+^|[.small]#f23#

3+^|[.small]#f24#

3+^|[.small]#f25#

3+^|[.small]#f26#

3+^|[.small]#f27#

3+^|[.small]#f28#

3+^|[.small]#f29#

3+^|[.small]#f30#

3+^|[.small]#f31#

3+^|[.small]#FLEN#

|[.small]#31# | >|[.small]#0#

3+^|[.small]#fcsr#

3+^|[.small]#32#
|===

=== 浮点控制和状态寄存器

浮点控制和状态寄存器`fcsr`是一个RISC-V控制和状态寄存器（CSR）。 它是一个32位读/写寄存器，用于选择浮点算术操作的动态舍入模式，并持有累积的异常标志，如<<fcsr>>所示。

include::images/wavedrom/float-csr.adoc[]

使用FRCSR和FSCSR指令可以读写`fcsr`寄存器，这些是基于底层CSR访问指令的汇编伪指令。 FRCSR通过将`fcsr`复制到整数寄存器_rd_来读取它。 FSCSR通过将原始值复制到整数寄存器_rd_，然后从整数寄存器_rs1_获得新值后写入`fcsr`，这样交换`fcsr`中的值。

可以通过不同的CSR地址单独访问`fcsr`内的字段，并为这些访问定义了独立的汇编伪指令。 FRRM指令读取舍入模式字段`frm`（`fcsr`位7--5）并将其复制到整数寄存器_rd_的最低有效三位，其他位全为零。 FSRM通过将原始值复制到整数寄存器_rd_，然后从整数寄存器_rs1_的最低有效三位获得新值后写入`frm`，这样交换`frm`中的值。 FRFLAGS和FSFLAGS在累积的异常标志字段`fflags`（`fcsr`位4--0）中是按类似方式定义的。

`fcsr`的位31--8保留给其他标准扩展。 如果这些扩展不存在，实现应忽略对这些位的写入，并在读取时提供一个零值。 标准软件应保留这些位的内容。

浮点操作使用指令中编码的静态舍入模式，或者使用`frm`中持有的动态舍入模式。 舍入模式如<<rm>>所示进行编码。 指令的_rm_字段中值为111时，选择`frm`中持有的动态舍入模式。 依赖舍入模式的浮点指令在使用保留舍入模式执行时的行为是_保留_的，包括静态保留的舍入模式（101--110）和动态保留的舍入模式（101--111）。 某些指令，包括扩展转换，具有_rm_字段但数学上不受舍入模式影响；软件应将其_rm_字段设置为RNE（000），但实现必须按常规处理_rm_字段（特别是在解码合法与保留编码时）。

[[rm]]
.舍入模式编码。
[%autowidth, float="center", align="center", cols="^,^,<", options="header"]
|===
|舍入模式 |助记符 |含义

|000 |RNE |就近舍入，偶舍对绑

|001 |RTZ |向零舍入

|010 |RDN |向下舍入（向负无穷）

|011 |RUP |向上舍入（向正无穷）

|100 |RMM |就近舍入，最大值对绑

|101 | |_保留供将来使用._

|110 | |_保留供将来使用._

|111 |DYN |在指令的_rm_字段中，选择动态舍入模式；在舍入模式寄存器中，_保留_。
|===

[NOTE]
====
C99语言标准实际上规定了提供动态舍入模式寄存器。 在典型实现中，对动态舍入模式CSR状态的写入将使流水线顺序化。 静态舍入模式用于实现需要频繁在不同舍入模式之间切换的专用算术操作。

F规范的经批准版本规定，当指令使用保留动态舍入模式执行时，会引发非法指令异常。 这已被削弱为保留，这与静态舍入模式指令的行为相匹配。 在遇到保留编码时，仍然可以通过引发非法指令异常来实现，因此与经批准规范兼容的实现也与削弱的规范兼容。
====

累积异常标志指出自上次通过软件重置字段以来，在任何浮点算术指令上产生的异常条件，如<<bitdef>>所示。 基本的RISC-V ISA不支持在设置浮点异常标志时生成陷阱。
(((浮点,异常标志)))

[[bitdef]]
.累计异常标志编码。
[%autowidth, float="center", align="center", cols="^,<", options="header"]
|===
|标志助记符 |标志含义

|NV |无效操作

|DZ |除以零

|OF |溢出

|UF |下溢

|NX |不准确
|===

[NOTE]
====
根据标准所允许的，我们在F扩展中不支持浮点异常上的陷阱，而是要求在软件中显式检查标志。 我们考虑过添加由浮点累积异常标志内容直接控制的分支，但最终选择省略这些指令以保持ISA简单。
====

=== NaN生成和传播

除非另有说明，否则如果浮点运算的结果是NaN，则为规范NaN。 规范NaN的符号为正，所有有效数字位清除，除了MSB，又称为安静位。 对于单精度浮点，这对应于模式`0x7fc00000`。 对于单精度浮点，这对应于模式`0x7fc00000`。
(((NaN, 生成))) (((NaN, 传播)))

[TIP]
====
此外，由于这一功能在标准中是可选的，因此不能在可移植代码中使用。
实施者可以自由提供一个NaN负载传播方案作为非标准扩展通过非标准操作模式启用。

然而，上述的规范NaN方案必须始终得到支持，并应成为默认模式。 然而，以上描述的标准NaN方案必须始终支持，并且应为默认模式。
====

'''

[NOTE]
====
我们要求实现者在异常条件下返回标准要求的默认值，而无需用户级软件的进一步干预（不像Alpha ISA浮点陷阱屏障）。 实现者可以始终陷入机器模式软件处理程序以提供异常默认值。
实现可以随时陷入机器模式软件处理程序，以提供异常默认值。
====

=== 次正规算术

对次正规数的运算按照IEEE 754-2008标准处理。
(((运算, 次正规)))

在IEEE标准的用词中，四舍五入后检测微小数。
(((微小数, 处理)))

[NOTE]
====
在舍入后检测微小可减少伪下溢信号。
====

=== 单精度加载和存储指令。

浮点加载和存储使用与整数基本ISA相同的基址+偏移寻址模式，基址在寄存器`_rs1_`中，偏移为12位有符号字节偏移。 FLW指令从内存中加载单精度浮点值到浮点寄存器_rd_中。 FSW将单精度值从浮点寄存器_rs2_存储到内存中。

include::images/wavedrom/sp-load-store-2.adoc[]

//.SP load and store

FLW和FSW不修改正在传输的位；特别是，非规范NaN的负载被保留。

FLW和FSW不修改传输的位；特别是，非规范NaN的有效负载会被保留。

如<<ldst>>中所述，执行环境定义未对齐浮点加载和存储是被无形处理还是引发一个受控或致命的陷阱。

[[single-float-compute]]
=== 单精度浮点计算指令。

带有一个或两个源操作数的浮点算术指令使用OP-FP主操作码的R型格式。 FADD.S和FMUL.S分别在_rs1_和_rs2_之间执行单精度浮点加法和乘法。 FSUB.S执行单精度浮点从_rs1_中减去_rs2_的减法。 FDIV.S执行_rs1_被_rs2_除的单精度浮点除法。 在每种情况下，结果写入_rd_。 在每种情况下，结果写入_rd_。

2位浮点格式字段_fmt_如<<fmt>>中编码。 对于F扩展中的所有指令，设置为_S_（00）。

[[fmt]]
._fmt_字段
[%autowidth, float="center", align="center", cols="^,^,<", options="header"]
|===
|助记符 |含义 |格式字段编码。

|S |S |32位单精度

|D |D |64位双精度

|H |16位半精度 |Q

|Q |128位四精度 |所有执行舍入的浮点操作可以使用_rm_字段选择舍入模式，编码如<<rm>>中所示。
|===

浮点最小数和最大数指令FMIN.S和FMAX.S分别将_rs1_和_rs2_中较小或较大的写入_rd_。

仅在这些指令的目的下，数值latexmath:[$-0.0$]被认为小于数值latexmath:[$+0.0$]。 仅为这些指令的目的，值latexmath:[$-0.0$]被视为小于值latexmath:[$+0.0$]。 如果只有一个操作数是NaN，结果是非NaN操作数。 信号NaN输入设置无效操作异常标志，即使结果不是NaN。
信号NaN输入设置无效操作异常标志，即使结果不是NaN。

[NOTE]
====
注意，在版本2.2的F扩展中，FMIN.S和FMAX.S指令已修改为实施提议的IEEE 754-201x最小数和最大数操作，而不是IEEE 754-2008的minNum和maxNum操作。 这些操作在处理信号NaN时有所不同。
====

include::images/wavedrom/spfloat.adoc[]

//.Single-Precision Floating-Point Computational Instructions

(((浮点, 融合乘加)))

浮点融合乘加指令需要新的标准指令格式。 R4型指令指定三个源寄存器 (_rs1_, _rs2_ 和 _rs3_) 以及一个目标寄存器 (_rd_)。 这种格式仅用于浮点融合乘加指令。

FMADD.S对_rs1_和_rs2_的值进行乘法，加上_rs3_中的值，并将最终结果写入_rd_。 FMADD.S计算_(rs1latexmath:[$\times$]rs2)latexmath:[$\+$]rs3_。

FMSUB.S对_rs1_和_rs2_的值进行乘法，减去_rs3_中的值，并将最终结果写入_rd_。 FMSUB.S计算 _(rs1latexmath:[$\times$]rs2)latexmath:[$\-$]rs3_。

FNMSUB.S对_rs1_和_rs2_的值进行乘法，对乘积取负，加上_rs3_中的值，并将最终结果写入_rd_。 FNMSUB.S计算 _-(rs1latexmath:[$\times$]rs2)latexmath:[$\+$]rs3_。

FNMADD.S对_rs1_和_rs2_的值进行乘法，对乘积取负，减去_rs3_中的值，并将最终结果写入_rd_。 FNMADD.S计算 _-(rs1latexmath:[$\times$]rs2)latexmath:[$\-$]rs3_。

[NOTE]
====
两种定义在处理符号零结果时有差异。 MIPS指令的定义是取和的负数，而RISC-V指令对乘积取负，因此当时命名方案更合理。 两个定义在签名零结果方面有所不同。 RISC-V定义匹配x86和ARM融合乘加指令的行为，但不幸的是，RISC-V FNMSUB和FNMADD指令名和x86及ARM之间是对换的。
====

include::images/wavedrom/spfloat2.adoc[]

//.F[N]MADD/F[N]MSUB instructions

[NOTE]
====
融合乘加 (FMA) 指令耗费了32位指令编码空间的一大部分。 一些考虑到的替代方案是限制FMA仅使用动态舍入模式，但静态舍入模式在利用缺乏乘积舍入的代码中很有用。
融合乘加指令必须在乘数为latexmath:[$\infty$]和零时设置无效操作异常标志，即使加数是安静NaN。 目前的设计仍然保持了很大一部分32位编码空间开放，同时避免让FMA变得不正交。
====

IEEE 754-2008标准允许，但不要求，抬高无效异常对于操作latexmath:[$\infty\times 0\ +$]qNaN。

[NOTE]
====
单精度浮点转换和移动指令。
====

=== 浮点到整数和整数到浮点的转换指令编码在OP-FP主操作码空间。

FCVT.W.S或FCVT.L.S将浮点寄存器_rs1_中的浮点数转换为整数寄存器_rd_中有符号的32位或64位整数。 FCVT.S.W或FCVT.S.L将整数寄存器_rs1_中的32位或64位有符号整数转换为浮点寄存器_rd_中的浮点数。 FCVT.WU.S，FCVT.LU.S，FCVT.S.WU和FCVT.S.LU变体转换为或从无符号整数值转换。 对于XLENlatexmath:[$>32$]，FCVT.W[U].S将32位结果符号扩展到目标寄存器宽度。 FCVT.L[U].S和FCVT.S.L[U]为RV64专用指令。 如果四舍五入后的结果在目标格式中不可表示，则将其剪裁到最近的值并设置无效标志。 <<int_conv>>给出FCVT._int_.S的有效输入范围及无效输入的行为。 所有浮点到整数和整数到浮点的转换指令都根据_rm_字段进行舍入。
可以使用FCVT.S.W _rd_, `x0`将浮点寄存器初始化为浮点正零，这永远不会设置异常标志。

浮点到整数转换的范围和无效输入行为。 FCVT.W.S

[[int_conv]]
.FCVT.WU.S
[%autowidth, float="center", align="center", cols="<,>,>,>,>", options="header"]
|===
| |FCVT.L.S |FCVT.LU.S |FCVT.L.S |FCVT.LU.S

|最小有效输入（舍入后） |latexmath:[$-2^{31}$] |0
|latexmath:[$-2^{63}$] |0

|最大有效输入（舍入后） |latexmath:[$2^{31}-1$]
|latexmath:[$2^{32}-1$] |latexmath:[$2^{63}-1$] |latexmath:[$2^{64}-1$]

|超出范围负输入的输出 |latexmath:[$-2^{31}$] |0
|latexmath:[$-2^{63}$] |0

|latexmath:[$-\infty$]的输出 |latexmath:[$-2^{31}$] |0
|latexmath:[$-2^{63}$] |0

|超出范围正输入的输出 |latexmath:[$2^{31}-1$]
|latexmath:[$2^{32}-1$] |latexmath:[$2^{63}-1$] |latexmath:[$2^{64}-1$]

|latexmath:[$+\infty$]或NaN的输出 |latexmath:[$2^{31}-1$]
|latexmath:[$2^{32}-1$] |latexmath:[$2^{63}-1$] |latexmath:[$2^{64}-1$]
|===

如果舍入后的结果与操作数值不同且未设置无效异常标志，则所有浮点转换指令都会设置不精确异常标志。

include::images/wavedrom/spfloat-cn-cmp.adoc[]

//.SP float convert and move

浮点到浮点的符号注入指令FSGNJ.S、FSGNJN.S和FSGNJX.S生成一个结果，取_self_ 除符号位以外的所有位。 对于FSGNJ，结果的符号位是_rs2_的符号位；对于FSGNJN，结果的符号位是_rs2_的符号位的相反；对于FSGNJX，符号位是_rs1_和_rs2_符号位的异或。 符号注入指令不会设置浮点异常标志，也不会规范化NaN。 注意，FSGNJ.S _rx, ry, ry_将_ry_移动到_rx_（汇编伪指令FMV.S _rx, ry_）；FSGNJN.S _rx, ry, ry_将_ry_的否定移到_rx_（汇编伪指令FNEG.S _rx, ry_）；FSGNJX.S _rx, ry, ry_将_ry_的绝对值移到_rx_（汇编伪指令FABS.S _rx,
ry_）。

include::images/wavedrom/spfloat-sign-inj.adoc[]

[[inj]]
[NOTE]
====
符号注入指令提供浮点MV、ABS和NEG，还支持其他一些操作，包括IEEE的copySign操作和超越数学函数库中的符号操作。 虽然MV、ABS和NEG只需要单个寄存器操作数，而FSGNJ指令需要两个，但大多数微架构不太可能通过减少寄存器读取的数量来优化这些相对罕见的指令。 即使在这种情况下，微架构也可以简单地检测FSGNJ指令的两个源寄存器是否相同，只需读取一个副本。
====

提供指令在浮点和整数寄存器之间移动位模式。 FMV.X.W将IEEE 754-2008编码表示的单精度值从浮点寄存器_rs1_移动到整数寄存器_rd_的低32位。 在传输中位不会被修改，特别是非规范NaN的有效负载被保留。 对于RV64，目标寄存器的高32位填充为浮点数的符号位的副本。

FMV.W.X将IEEE 754-2008标准编码的单精度值从整数寄存器_rs1_的低32位移动到浮点寄存器_rd_。 在传输中位不会被修改，特别是非规范NaN的有效负载被保留。

[NOTE]
====
FMV.W.X和FMV.X.W指令之前被称为FMV.S.X和FMV.X.S。 使用W更符合它们的语义，作为不解释32位的移动指令。 在定义NaN封装后这一点变得更明确。 为了不影响现有代码，工具将支持W和S版本。
====

include::images/wavedrom/spfloat-mv.adoc[]

//.SP floating point move

[TIP]
====
基本浮点ISA被定义为允许实现采用浮点格式在寄存器中的内部重编码，以简化非正规值的处理并可能减少功能单元的延迟。 为此，F扩展通过定义读写整数寄存器文件的转换和比较操作避免在浮点寄存器中表示整数值。 这也消除了许多显式在整数和浮点寄存器之间移动的常见情况，减少了常见混合格式代码序列的指令数量和关键路径。
====

=== 单精度浮点比较指令

浮点比较指令（FEQ.S、FLT.S、FLE.S）执行指定的浮点寄存器之间的比较（latexmath:[$\mbox{\em rs1} = \mbox{\em rs2}$], latexmath:[$\mbox{\em rs1} < \mbox{\em rs2}$], latexmath:[$\mbox{\em rs1} \leq \mbox{\em rs2}$]），如果条件成立，则向整数寄存器_rd_写入1，否则写入0。

FLT.S和FLE.S执行IEEE 754-2008标准所称的“信号”比较：即，如果任一输入是NaN，则设置无效操作异常标志。 FEQ.S执行一个“静默”比较：如果任一输入是信号NaN，则仅设置无效操作异常标志。 对于这三个指令，如果任一操作数是NaN，结果为0。

include::images/wavedrom/spfloat-comp.adoc[]

//.SP floating point compare

[NOTE]
====
F扩展提供latexmath:[$\leq$]比较，而基本ISA提供latexmath:[$\geq$]分支比较。 因为latexmath:[$\leq$]可以从latexmath:[$\geq$]合成，反之亦然，所以这种不一致没有性能影响，但它仍然是ISA中的一个不幸的不一致。
====

=== 单精度浮点分类指令

FCLASS.S指令检查浮点寄存器_rs1_中的值，并向整数寄存器_rd_写入一个10位掩码，表示浮点数的类别。 掩码的格式在<<fclass>>中描述。 如果属性为真，_rd_中的相应位将被设置，否则清除。 _rd_中的所有其他位都被清除。 请注意，_rd_中只会设置一位。
FCLASS.S不设置浮点异常标志。
(((floating-point, classification)))

include::images/wavedrom/spfloat-classify.adoc[]

//.SP floating point classify

[[fclass]]
.FCLASS指令结果的格式。
[%autowidth, float="center", align="center", cols="^,<", options="header"]
|===
|_rd_位 |含义

|0 |_rs1_是latexmath:[$-\infty$]。

|1 |_rs1_是负的正常数。

|2 |_rs1_是负的次正常数。

|3 |_rs1_是latexmath:[$-0$]。

|4 |_rs1_是latexmath:[$+0$]。

|5 |_rs1_是正的次正常数。

|6 |_rs1_是正的正常数。

|7 |_rs1_是latexmath:[$+\infty$]。

|8 |_rs1_是信号NaN。

|9 |_rs1_是安静的NaN。
|===