[[rv32]]
== RV32I 基础整数指令集，版本 2.1

本章介绍 RV32I 基础整数指令集。

[提示]
====
RV32I 的设计目标是足以构建编译器目标，
并支持现代操作系统环境。 ISA 的设计还旨在
减少最小实现中所需的硬件。 RV32I
包含 40 条独特指令，尽管简单实现可能
用单个 SYSTEM 硬件覆盖 ECALL/EBREAK 指令
指令总是陷阱并可能将 FENCE 指令实现为 NOP，
从而将基础指令数总共减少到 38 条。 RV32I
可以模拟几乎任何其他 ISA 扩展（除了 A 扩展，
该扩展需要额外硬件支持用于自动化）。

在实践中，一个包含机器模式的硬件实现
的特权架构也将需要 6 个 CSR 指令。

基础整数 ISA 的子集可能对教学有用，
但基础已被定义，以至于现实硬件实现中的
子集化除了省略
对未对齐内存访问的支持和将所有 SYSTEM
指令视为单一陷阱之外不太有动机。
====

[注意]
====
标准 RISC-V 汇编语言语法记录在
汇编程序员手册 cite:[riscv-asm-manual]。
====

[注意]
====
大部分关于 RV32I 的评论也适用于 RV64I 基础。
====

=== 基础整数 ISA 的程序员模型

<<gprs>> 显示了基础整数 ISA 的
非特权状态。 对于 RV32I，32 个 `x` 寄存器每个都是 32 位宽，
即 `XLEN=32`。 寄存器 `x0` 的所有位硬连接为 0。
通用寄存器 `x1-x31` 保存的值被各种
指令解释为一组布尔值，或作为二进制补码有符号
整数或无符号二进制整数。

还有一个附加的非特权寄存器：程序计数器 `pc`
保存当前指令的地址。

[[gprs]]
.RISC-V 基础非特权整数寄存器状态。
[cols="<,^,>",options="header",width="50%",align="center",grid="rows"]
|===
<| [.small]#XLEN-1#| >| [.small]#0#
3+^| [.small]#x0/zero#
3+^| [.small]#x1#
3+^| [.small]#x2#
3+^| [.small]#x3#
3+^| [.small]#x4#
3+^| [.small]#x5#
3+^| [.small]#x6#
3+^| [.small]#x7#
3+^| [.small]#x8#
3+^| [.small]#x9#
3+^| [.small]#x10#
3+^| [.small]#x11#
3+^| [.small]#x12#
3+^| [.small]#x13#
3+^| [.small]#x14#
3+^| [.small]#x15#
3+^| [.small]#x16#
3+^| [.small]#x17#
3+^| [.small]#x18#
3+^| [.small]#x19#
3+^| [.small]#x20#
3+^| [.small]#x21#
3+^| [.small]#x22#
3+^| [.small]#x23#
3+^| [.small]#x24#
3+^| [.small]#x25#
3+^| [.small]#x26#
3+^| [.small]#x27#
3+^| [.small]#x28#
3+^| [.small]#x29#
3+^| [.small]#x30#
3+^| [.small]#x31#
3+^| [.small]#XLEN#
| [.small]#XLEN-1#| >| [.small]#0#
3+^|  [.small]#pc#
3+^| [.small]#XLEN#
|===
[注意]
====
基础整数 ISA 没有专用的堆栈指针或子程序返回地址链接
寄存器；指令编码允许使用任何
`x` 寄存器用于这些目的。 然而，标准
软件调用约定使用寄存器 `x1` 保存返回
对于调用的地址，寄存器 `x5` 可用作替代链接
寄存器。 标准调用约定使用寄存器 `x2` 作为
堆栈指针。

硬件可以选择加速使用的函数调用和返回
`x1` 或 `x5`。 请参阅 JAL 和 JALR 指令的说明。

可选的压缩 16 位指令格式的设计基于
假设 `x1` 是返回地址寄存器而 `x2` 是
堆栈指针。 使用其他约定的软件将正常运行
但代码尺寸可能更大。

可用的架构寄存器数量对代码尺寸、性能和
能耗有很大影响。 尽管 16 个寄存器
文学说足以支持运行编译代码的整数 ISA，
但在 16 位指令中用 16 个寄存器编码完整 ISA 是不可能的，
使用 3 地址格式的指令。 尽管 2 地址格式会
是可能的，但会增加指令数量并降低效率。
我们希望避免中间指令大小（如 Xtensa 的
24 位指令）以简化基础硬件实现，一旦
采用 32 位指令大小后，支持
32 个整数寄存器是很直接的。 更多数量的整数寄存器也有助于
高性能代码中的性能，在此可以广泛使用
循环展开、软件流水线和缓存拼接。

出于这些原因，我们选择了 32 个整数寄存器的常规大小
用于 RV32I。 动态寄存器使用往往被少数几个
频繁访问的寄存器所主导，寄存器文件实现可以被
优化以减少频繁访问的
寄存器的访问能源 cite:[jtseng:sbbci]。 可选的压缩 16 位指令格式主要
只访问 8 个寄存器，因此可以提供密集指令
编码，而附加的指令集扩展可以支持
更大的寄存器空间（可选择扁平或分层）如果需要。

对于资源有限的嵌入式应用，我们定义了
RV32E 子集，只有 16 个寄存器
(<<rv32e>>) 。
====
=== 基本指令格式
在基础 RV32I ISA 中，有四个核心指令格式
（R/I/S/U），如 <<base_instr>> 所示。 所有都是固定的 32 位
长度。 基本 ISA 拥有 `IALIGN=32`，表示指令必须在内存中对齐在四字节边界上。 一条
指令地址未对齐异常会在一个被取的分支中产生，
或无条件跳转，如果目标地址不是 `IALIGN` 位对齐。
这个异常在分支或跳转指令中报告，而不是在
目标指令。 对于未满足的条件分支不会产生
指令地址未对齐异常。

[注意]
====
基础 ISA 指令的对齐限制被放宽到
两字节边界，当指令扩展长度为 16 位或
其他奇数倍 16 位长度被添加时（即 IALIGN=16）。

指令地址未对齐异常在分支或
跳转中报告，以帮助调试，
并简化 IALIGN=32 系统的硬件设计，
这些是唯一可能发生未对齐的地方。
====

对保留指令进行解码时的行为为未指定。

[注意]
====
某些平台可能要求为标准使用保留的操作码引发
非法指令异常。 其他平台可能允许保留
操作码空间用于不符合标准的扩展。
====

RISC-V ISA 将源寄存器 (_rs1_ 和 _rs2_) 和目标寄存器 (_rd_)
在所有格式中放在相同位置以简化解码。
除了 CSR 指令中使用的 5 位立即数，
(<<csrinsts>>)，立即数总是
符号扩展，并且通常向最左可用
指令中的位聚集，以减少硬件
复杂性。 特别地，所有立即数的符号位总是在
指令的第 31 位，以加速符号扩展电路。

include::images/wavedrom/instruction_formats.adoc[]
[[base_instr, 基本指令格式]]
RISC-V 基本指令格式。 每个立即数子字段都标有在生成的立即值中的位位置 (imm[x])，而不是通常在指令的立即字段内的位位置。

[注意]
====
解码寄存器指定通常是在
实现中的关键路径，因此指令格式选择为保持所有
寄存器指定在所有格式中的相同位置，不惜代价
需要在格式之间移动立即数位（与 RISC-IV 又名 SPUR 共享的属性）。
指南 [spur-jsscc1989]) SPUR 引用：[spur-jsscc1989]）。

在实践中，大多数立即数要么很小，要么需要整个 XLEN 位。
我们选择了不对称的立即数拆分（常规指令中为 12 位，
再加上具有 20 位的特殊加载高级立即数指令），以
增加常规指令可用的操作码空间。

立即数是符号扩展的，因为我们没有观察到使用零扩展
用于某些立即数（类似于 MIPS ISA）有什么好处，并且希望
使 ISA 尽可能简单。
====

=== 立即数编码变体

基于立即数处理，还有两种指令格式变体 (B/J)，
如 <<baseinstformatsimm>> 所示。

include::images/wavedrom/immediate_variants.adoc[]
[[baseinstformatsimm, 基本指令格式立即数变体。]]
//.RISC-V 基本指令格式显示立即数变体。


S格式与B格式的唯一区别在于12位
立即数字段用于以2的倍数编码分支偏移量
在B格式中。 代替在硬件中传统的左移指令编码的所有位
，中间位（imm[10:1]）和符号位保持在固定位置
，而S格式中的最低位（inst[7]）在B格式中编码为高位。
。

同样，U格式和J格式的唯一区别在于
20位立即数左移12位形成U立即数，并左移1位形成J立即数。
。 U格式和J格式立即数的指令位位置旨在最大化与其他格式及彼此之间的重叠。
。
。

<<immtypes>>展示了由
每种基本指令格式产生的立即数，并标记出哪一位指令位（inst[_y_]）产生每一位
即时数值。
[[immtypes, 立即数类型]]
RISC-V指令产生的立即数类型。 
include::images/wavedrom/immediate.adoc[]

这些字段用指令位标记以构建其值。  符号扩展始终使用inst[31]。

[注意]
====
符号扩展是立即数上最关键的操作之一
（尤其是在XLEN>32的情况下），并且在RISC-V中
所有立即数的符号位始终保存在指令的第31位，以便于符号扩展
与指令解码并行进行。

虽然更复杂的实现可能有单独的加法器用于
分支和跳转计算，因此不需要通过保持
立即数位位置一致来获得好处，
我们希望降低最简单实现的硬件成本。 通过
在B和J立即数的指令编码中旋转位，
而不是使用动态硬件多路复用器将立即数乘以2，我们
减少指令信号扇出和立即数多路复用器成本约一
倍。 被打乱的立即数编码将对静态或提前编译的时间影响甚微。
。 对于动态生成的指令，
会有一些小的额外开销，但最常见的短前向分支有直接的立即数编码。
。
====

=== 整数计算指令 ===

大多数整数计算指令在`XLEN`位的值上操作
保存在整数寄存器文件中。 整数计算指令
要么使用I型格式编码为寄存器-立即数操作，要么使用R型格式编为寄存器-寄存器操作。
。 目标是两个寄存器-立即数和寄存器-寄存器指令的_rd_寄存器。
。
。 无整数计算指令引起算术异常。
。

[提示]
====
我们没有在基本指令集中包含用于溢出检查的特殊指令集支持，因为许多溢出检查可以使用RISC-V分支便宜地实现。
。
溢出检查可便宜地实现。
无符号加法的溢出检查在加法后只需一个附加分支指令：
。
`add t0, t1, t2; bltu t0, t1, 溢出`。

对于有符号加法，如果知道一个操作数的符号，溢出检查在加法后只需一个分支指令：
。
`addi t0, t1, +imm; blt t0, t1, 溢出`。 这涵盖了与立即数操作数的加法的常见情况。
。

对于一般的有符号加法，
需要在加法后再加三条指令，
观察到，如果只有另一个操作数为负，和应小于其中一个操作数。
。

[来源，文本]
....
         add t0, t1, t2
         slti t3, t2, 0
         slt t4, t0, t1
         bne t3, t4, overflow
....

在RV64I中，32位有符号加法的检查可以通过比较操作数上的ADD和ADDW结果进一步优化。
。
====

==== 整数寄存器-立即数指令 ====

include::images/wavedrom/integer_computational.adoc[]
//.整数计算指令

ADDI把符号扩展的12位立即数加到寄存器_rs1_。
算术溢出被忽略，结果仅为结果的低XLEN位。
。 ADDI _rd, rs1, 0_用于实现MV _rd,
rs1_汇编伪指令。

SLTI（立即数下置）如果寄存器_rs1_的值小于符号扩展的立即数，并且两者都按签名数处理，则将值1放置在寄存器_rd_中，否则0将被写入到_rd_。
。
。 SLTIU类似，但把值比较为无符号数（ 即，立即数首先符号扩展到XLEN位然后视为无符号数） 。
。
。
注意，SLTIU _rd, rs1, 1_ 将_rd_ if _rs1_ 等于0，否则
将_rd_设置为0（assembler伪指令SEQZ _rd, rs_）。

ANDI, ORI, XORI是逻辑操作，将按位计算寄存器_rs1_和符号扩展的12位立即数，并将结果放置在_rd_。
。
。 注意，XORI _rd, rs1, -1_对寄存器_rs1_进行按位逻辑
反转（assembler伪指令NOT _rd, rs_）。

include::images/wavedrom/int-comp-slli-srli-srai.adoc[]
[[int-comp-slli-srli-srai]]
//.整数寄存器-立即数，SLLI，SRLI，SRAI

用常数位移被编码成I型格式的一种特化。
格式。 要移位的操作数在_rs1_中，移位量编码在I-立即数域的低5位。
。 右移类型编码在位30。
。 SLLI是逻辑左移（零被移入低位）；SRLI是逻辑右移（零被移入高位）；SRAI是算术右移（原符号位被复制到腾空的高位） 。
。
。
。

include::images/wavedrom/int-comp-lui-aiupc.adoc[]
[[int-comp-lui-aiupc]]
//.整数寄存器-立即数，U-立即数

LUI（装入上部立即数）用于构建32位常量，并使用U型格式。
。 LUI将32位U立即数值置于目标寄存器_rd_中，并在最低12位填上零。
。

AUIPC（将上部立即数加到“pc”）用于构建“pc”相对
地址，并使用U型格式。 AUIPC形成一个32位偏移量从
U立即数，上面12位填上零，将此偏移加到AUIPC指令的地址上，然后将结果置于寄存器_rd_中。
。
。

[注意]
====
`lui`和`auipc`的汇编语法不表示U立即数的下12位，它们总是零。
。

AUIPC指令支持两个指令序列来访问
从PC的任意偏移，既可以用于控制流转移，也可以用于数据
访问。 AUIPC与JALR中的12位立即数的组合可将控制转移至任何32位PC相对地址，
。
而AUIPC加上常规加载或存储指令中的12位立即数偏移
可以访问任何32位PC相对数据地址。

当前PC可以通过将U立即数设为0来获得。 虽然
一个JAL +4指令也可以用来获得本地PC（在JAL后的指令）
，但这可能会导致在简单微架构中的管道中断或在更复杂微架构中污染BTB结构。
。
。
====

==== 整数寄存器-寄存器操作 ====

RV32I定义了一些算术R型操作。 所有操作读取
_rs1_和_rs2_寄存器作为源操作数，并将结果写入
寄存器_rd_中。 _funct7_和_funct3_字段选择运算类型。
。

include::images/wavedrom/int_reg-reg.adoc[]
[[int-reg-reg]]
//.整数寄存器-寄存器

ADD执行_rs1_和_rs2_的加法。 SUB执行
_rs2_从_rs1_的减法。 溢出被忽略，结果的低XLEN
位写入到目标_rd_。 SLT和SLTU分别执行有符号和无符号比较，写入1到_rd_如果
。
_rs1_< _rs2_，0 否则。 注意，SLTU _rd_, _x0_, _rs2_设置_rd_到1如果
_rs2_不等于零，否则设置_rd_到零（assembler
伪指令SNEZ _rd, rs_）。 AND, OR, 和XOR执行按位逻辑操作。
。

SLL, SRL, 和SRA执行逻辑左移，逻辑右移和算术
右移，_rs1_中的值按_rs2_注册的低5位保留的移位量。
。

==== NOP 指令 ====

include::images/wavedrom/nop.adoc[]
[[nop]]
//.NOP指令

NOP指令不会改变任何架构上可见的状态，
除了前进“pc”和增加任何适用的性能计数器。
。 NOP被编码为ADDI _x0, x0, 0_。

[注意]
====
NOPs可用于将代码段对齐到微架构上
显著的地址边界，或为内联代码修改留出空间。
。 虽然有很多可能的方法来编码NOP，我们
定义一个标准的NOP编码以允许微架构
优化以及更具可读性的反汇编输出。 其他
NOP编码可用于<<rv32i-hints>>。

ADDI被选择用于NOP编码因为这最有可能在系统上占用最少的资源（如果没有在解码中优化）。
。
。 特别是，该指令仅读取一个寄存器。
此外，ADDI功能单元在超标量设计中更可能可用，因为加法是最常见的操作。
。 特别是，
地址生成功能单元可以使用生成基+偏移量计算所需的相同硬件执行ADDI，而寄存器-寄存器加法或逻辑/移位操作则需要额外的硬件。
。
。
。
====

=== 控制传输指令 ===
RV32I提供两种类型的控制传输指令：无条件
跳转和条件分支。 RV32I中的控制传输指令
_没有_架构上可见的延迟槽。

如果一个指令访问故障或指令页故障异常
在跳转或取得分支的目标上发生，则异常
在目标指令上报告，而不是在跳转或分支指令上报告。
。

无条件跳转
跳转和链接（JAL）指令采用J型格式，其中J立即数编码为2字节的签名偏移。
J-立即数以2字节的倍数编码为有符号偏移。 偏移量
被符号扩展并加到跳转指令地址上以形成跳转目标地址。
。 因此，跳转可以目标到一个
±1 MiB范围。 JAL将跳转后指令的地址（'pc'+4）
跳转后 ('pc'+4) 保存到寄存器_rd_中。 标准软件调用约定使用'x1'作为返回地址寄存器，'x5'作为
。
替代链接寄存器。

[注意]
====
替代链接寄存器支持调用millicode例程（例如
，用于在压缩代码中保存和恢复寄存器）同时保留常规返回地址寄存器。
。 寄存器'x5'被选为
替代链接寄存器，因为它映射到标准调用约定中的临时，编码仅有一个比特与常规链接寄存器不同。
。
。
====

简单的无条件跳转（汇编伪指令J）被编码为
带有_rd_=`x0`的JAL。

include::images/wavedrom/ct-unconditional.adoc[]
[[ct-unconditional]]
//.无条件跳转指令，JAL

间接跳转指令JALR（跳转并链接寄存器）使用
I型编码。 目标地址是通过将符号扩展的12位I立即数加到寄存器_rs1_来获得，然后设置
。
结果的最低有效位为零。 跳转后的指令地址（`pc`+4）
被写入寄存器_rd_。
如果结果不需要，寄存器`x0`可以用作目标。
。

include::images/wavedrom/ct-unconditional-2.adoc[]
[[ct-unconditional-2]]
//.间接无条件跳转指令，JALR

[注意]
====
无条件跳转指令全部使用PC相对寻址来
支持位置无关代码。 JALR指令被定义
以允许使用两指令序列跳到32位绝对地址范围内的任意位置。
。 一个LUI指令可先将_rs1_装入目标地址的高20位，然后JALR可加上低位。
。
同样，AUIPC然后JALR可以跳到32位'pc'相对地址范围内的任意位置。
。

注意，JALR指令不将12位立即数视为2个字节的倍数，而条件分支指令会。
。 这样
避免在硬件中使用更多的立即格式。 在实践中，大多数使用
JALR的立即数要么为零，要么与LUI或AUIPC配对，
因此，范围略有减少并不重要。

在计算JALR目标地址时清零最低有效位
同时简化了硬件，并允许函数指针的低位用于存储辅助信息。
。 虽然
在这种情况下可能稍微减少错误检查，
在实践中跳到错误的指令地址通常会迅速引发异常。
。

当与基址_rs1_=`x0`一起使用时，JALR可以被用来
实现单指令子程序调用从空间中的任何地方转移到最低或最高地址区域
，可以用来实现快速调用一个小型运行时库。
。 或者，一个ABI可以指定一个通用寄存器以指向地址空间中的另一个库。
。
。
====

JAL和JALR指令将在不能四字节对齐时生成一个指令地址未对齐异常。
。
。

[注意]
====
在支持16位对齐指令的机器上，不可能出现指令地址未对齐异常，如压缩指令集扩展（C）。
。
。
====

返回地址预测堆栈是
高性能指令获取单元的常见特性，但需要准确检测
用于过程调用和返回的指令以有效。
对于RISC-V，指令使用的提示是隐式编码于寄存器号中。
。 一个JAL指令应仅在_rd_为'x1'或'x5'时将返回地址推到返回地址堆栈（RAS）。
。
`x5`。 JALR指令应按<<rashints>>中显示的方式推/弹返回地址堆栈。

[[rashints]]
JALR指令寄存器操作数中编码的返回地址堆栈预测提示。
[%autowidth,float="center",align="center",cols="^,^,^,<",options="header"]
|===
|_rd_ is _x1/x5_ |_rs1_ is _x1/x5_ |_rd_=_rs1_ |返回地址堆栈（RAS）操作

|否 |否 |-- |不操作

|否 |是 |-- |弹出

|是 |否 |-- |推入

|是 |是 |否 |弹出，然后推动

|是 |是 |是 |推入
|===


[注意]
====
一些其他的指令集架构在其间接跳转指令中增加了显式提示位。
来引导返回地址栈操作。 我们使用
与寄存器号和调用约定绑定的隐式提示，
以减少这些提示的编码空间。

当两个不同的链接寄存器（`x1`和`x5`）被赋予_rs1_和
_rd_，则返回地址栈（RAS）同时弹出和推入来支持协程。 如果
_rs1_和_rd_是相同的链接寄存器（`x1`或`x5`），则返回地址栈（RAS）仅推入以启用宏操作融合以下序列：
。
`lui ra, imm20; jalr ra, imm12(ra)_ 和 _auipc ra, imm20; jalr ra, imm12(ra)`
====

==== 条件分支 ====

所有分支指令都使用B型指令格式。 12位B-立即数以字节为单位编码签名偏移。
。 偏移量
被符号扩展并加到分支指令地址以提供目标地址。
。 条件分支范围为
±4 KiB。

include::images/wavedrom/ct-conditional.adoc[]
[[ct-conditional]]
//.条件分支

分支指令比较两个寄存器。 BEQ和BNE比较_rs1_和_rs2_是否相等来分支。
。 BLT和
BLTU采取分支如果_rs1_小于_rs2_，分别使用签名和
无符号比较。 BGE和BGEU如果_rs1_
是大于或等于_rs2_，分别使用签署和无符号比较
。 注意，BGT, BGTU, BLE, 和BLEU可以通过颠倒BLT, BLTU, BGE, 和BGEU的操作数来合成。
。

[注意]
====
有符号的数组界限可以用一个BLTU指令检查，因为
任何负索引将比较大于任何非负界限。
====

软件应优化，使顺序代码路径是最常路径，并将较不频繁的代码路径放到界外。
。
。 软件也应假设向后的分支将被预测为取得并且向前的分支将被预测为不取得，首次被遇到时如此，
预测为已执行和向前的分支未执行，至少第一个
。 动态预测者应迅速学习任何可预测的分支行为。
。

与其他一些架构不同，RISC-V跳转（JAL和_rd_= x0_）
指令应始终用于无条件分支，而不是用条件分支指令与总是成立的条件。
。 RISC-V
跳跃也是相对PC的，比分支支持更宽的偏移量范围，
并且不会污染条件分支预测表。

[技巧]
====
条件分支被设计为包括两个寄存器之间算法比较运算（如在PA-RISC、Xtensa、MIPS R6中），而不是使用条件码(x86, ARM, SPARC, PowerPC)，或仅比较一个寄存器与零(Alpha, MIPS)，或两个寄存器仅对于相等性(MIPS)。
。
。
。
。 这种设计的动机源于观察到，结合比较与分支指令正好适应常规流水线，避免了附加的条件码状态或临时寄存器使用，减少了静态代码大小和动态指令获取流量。
。
。
。
。 另一个观点认为，与零比较需要显著的电路延迟（特别是在转至静态逻辑后的高级过程中），因此与算术大小比较几乎一样昂贵。
。
。
。 集合比较与分支指令的另一个优势是分支在前端指令流中更早观察到，因此更早预测。
。
。 也许有某种优势在于设计有条件码，
如果是基于相同条件码的多个分支可以被采取，
但是我们认为
这种情况相对罕见。

我们曾考虑但未在指令编码中包括静态分支提示。
。 这些可以减少动态预测者的压力，但
需要更多的指令编码空间和软件剖析以达到最佳效果，如果生产跑步不匹配剖析跑步时可能造成性能差。
。
。

我们曾考虑但未包括条件移动或谓词
指令，
。 它们可以有效地替代不可预测的短前向分支。条件移动是两种中更简单的，但很难与可能引发异常的条件代码一起使用（内存访问和浮点操作）。
。
。 谓词增加了
系统中额外的标记状态，用于设置和清除标志的额外指令，以及每个指令的额外编码开支。
。 同时，
条件移动和谓词指令追加了对乱序微架构的复杂性，因需要复制
隐含的第三个源操作数至重命名的目标物理寄存器
中的目标架构寄存器原值，如果谓词为假。
。
。 此外，静态编译时使用谓词而不是分支的决定
可能导致更低的性能
。
不可预测的分支是罕见的，随着分支预测技术的改进变得更加罕见。
。

我们注意到存在各种微架构技术可以动态地将不可预测的较短程前向分支转换为内部谓词代码
。
以避免分支错误预测cite:[heil-tr1996], cite:[Klauser-1998], cite:[Kim-micro2005]时刷新流水线的成本，并已在商用处理器中实现cite:[ibmpower7]。
。 最简单的技术只是通过仅在分支影子中刷指令来减少从错误预测的短程前向分支恢复的惩罚，而不是整个抓取流水线，或通过使用宽指令抓取或空闲指令抓取槽，双侧抓取指令。
。
。
。
。 更复杂的技术对于乱序核心
在分支影子中的指令上添加内部谓词，由分支指令写的内部谓词值，允许分支和随后的指令以推测的和乱序的方式执行相对于其他代码
。
。
。
。
====

条件分支指令将在目标地址未对齐至4字节边界且分支条件为真时, 生成指令地址未对齐异常。
。
。
。 如果分支条件评估为假，则不会引发指令地址不当对齐异常。
。

[注意]
====
在支持16位对齐指令扩展的机器上，不可能出现指令地址未对齐异常，例如压缩指令集扩展（C）。
。
。
====

[[ldst]]
=== 加载和存储指令 ===
RV32I是加载-存储架构，其中只有加载和存储指令访问内存，而运算指令只操作在CPU寄存器上。
。
。 RV32I提供一个字节寻址的32位地址空间。
字节寻址。 EEI将定义地址空间的哪些部分可以用哪些指令访问（例如，某些地址可能是只读的，或者只支持字访问）。
。
。 即使目标为`x0`的加载也必须引发任何异常并导致任何其他副作用，
。
即使加载值被丢弃。

EEI将定义内存系统是小端序还是大端序。
。 在RISC-V中, 端序是字节地址不变的。

[技巧]
====
在端序是字节地址不变的系统中，如果某个地址用某种端序存取一个字节，通过任何端序从该地址访问字节也返回存取的值。
。
。
。

在小端序配置中，多字节存储从最低字节地址开始写入最低有效寄存器字节，按其意义升序写入其他寄存器字节。
。
。
。 加载同样地将较小的内存字节地址的内容传到寄存器的较低字节。
。

在大端序配置中，多字节存储从最低内存字节地址上写入最高有效寄存器字节，按意义下降顺序写入其他寄存器字节。
。
。
。 加载同样地将寄存器字节的内容转移到更高的内存字节地址。
内存字节地址至低位寄存器字节。
====

include::images/wavedrom/load_store.adoc[]
[[load-store,载入与存储]]
//.加载与存储指令

加载和存储指令在寄存器和内存之间转移值。
。 加载以I型格式编码，存储以S型格式编码。
有效地址由寄存器_rs1_和符号扩展的12位偏移量相加得到。
。 加载从内存复制值到寄存器。
_rd_。 存储将寄存器_rs2_中的值复制到内存。

LW指令从内存中加载32位值到_rd_。 LH加载一个16位值，从内存中
，然后符号扩展到32位后存储
在_rd_中。 LHU从内存加载一个16位值，但后续阶段为零扩展到32位，然后存储在 _rd_中。
。 LB和LBU则为
8位值。 SW，SH 和 SB指令分别将32位、16位和8位值从寄存器低位存入内存。
。

不管EEI是什么，
自然对齐的加载和存储不会引发地址未对齐的异常。 加载
和存储其有效地址未与数据类型自然对齐（即有效地址不是字节大小的可整除的整除数）
。
取决于 EEI的行为。

一个 EEI可以保证未对齐的加载和存储完全
支持，因此在执行环境中运行的软件
将不会经历包含或致命的地址未对齐陷阱。 在此情况下，未对齐的加载和存储可以在硬件中处理，或通过一个不可见的陷阱进入执行环境实现，或在硬件和不可见的陷阱两者都根据地址结合处理。
。
。
。
地址。

EEI 可能无法保证处理未对齐的加载和存储
不可见地。 在这种情况下，非自然对齐的加载和存储
可以成功完成执行或引发异常。 该
引发的异常可以是地址未对齐异常或
访问错误异常。 对于可能完成的内存访问，除非
由于未对齐，可以引发访问错误异常
如果非对齐访问不应被模拟，可以引发访问错误异常而不是地址未对齐异常。
例如，如果内存区域的访问具有副作用，不应模拟非对齐访问。
具有副作用。 当EEI不能保证非对齐的加载和
存储被隐式处理时，EEI必须定义由于
地址未对齐引起的异常导致的限制捕获（允许软件
在执行环境中运行的软件处理捕获）或致命
捕获（终止执行）。

[提示]
====
移植遗留代码时偶尔需要非对齐访问，
在任何形式的打包SIMD扩展或处理外部打包的数据结构时，有助于应用程序性能。
处理外部打包的数据结构。 我们的理由
允许EEI选择通过常规加载和存储指令支持非对齐访问，
是为了简化
未对齐硬件支持的添加。 一种选择是禁止
在基础ISA中实施未对齐访问，然后提供一些ISA
支持未对齐访问，包括特别指令帮助软件处理未对齐访问或者新的硬件寻址模式
处理未对齐访问。
处理未对齐访问。 特殊指令难以使用，
复杂的ISA，经常添加新的处理器状态（如SPARC VIS对齐地址偏移寄存器）
或使现有
处理器状态的访问复杂化（如MIPS LWL\/LWR部分寄存器写入）。 在
此外，对于循环导向的打包SIMD代码，操作数未对齐时的额外开销激励软件提供多种形式的
循环根据操作数对齐来进行。
这复杂了代码生成和增加了循环启动开销。
并增加了循环启动开销。 新的未对齐硬件寻址
模式在指令编码中占用大量空间或需要
非常简化的寻址模式（例如，仅寄存器间接）。
====

即使未对齐加载和存储成功完成，
这些访问可能极其缓慢，具体取决于实现
（例如，通过不可见陷阱实现时）。 此外，当
自然对齐的加载和存储保证原子执行时，未对齐的加载和存储可能不是
原子执行，因此需要额外的
同步来确保原子性。

[注意]
====
我们不要求未对齐访问的原子性，因此执行环境的实现可以使用看不见的机器陷阱和
软件处理器来处理部分或全部未对齐存取。
软件处理器来处理部分或全部未对齐访问。 如果使用硬件
支持未对齐，则软件可以通过简单地使用常规加载和存储指令来利用这一点。
使用常规加载和存储指令。 然后，硬件可以自动优化
访问自动优化的访问取决于运行时地址是否
对齐。
====

[[屏障]]
=== 内存排序指令

include::images\/wavedrom\/mem_order.adoc[]
[[内存顺序]]
\\/\/内存排序指令

FENCE 指令用于对设备I\/O和内存访问进行排序，并
按其他RISC-V核和外部设备或协处理器的观察进行排序。 任何
设备输入（I）、设备输出（O）、内存读（R）和内存写（W）的组合
可以相对于这些命令的任何组合进行排序。
。 非正式地说，其他RISC-V处理器或外部设备不能
观察到在FENCE之前在_后继者_集合中的任何操作前发生的情况
在FENCE之前在_前继者_集合中的任何操作前发生的情况。
<<memorymodel>>提供了一个精确的描述
RISC-V内存一致性模型。

FENCE指令还会对由处理器执行的内存读和写操作进行排序，
如由外部设备执行的内存读取和写入观察到的。
然而，FENCE不会对外部设备通过任何其他信号机制观察到的事件进行排序。
设备通过任何其他信号机制进行的观察。

[注意]
====
设备可能通过一些外部通信机制观察对内存某位置的访问，
例如，一个内存映射的控制寄存器，该寄存器驱动中断信号到中断控制器。
驱动中断信号的中断控制器。 这种
通讯不在FENCE排序机制的范围内，因此
FENCE指令不能保证中断信号的变化何时连接到中断控制器。
中断信号对于中断控制器何时可见。 特定
设备可能提供额外的顺序保证，以减少软件
开销，但这些不在RISC-V内存模型的范围内。
====

EEI将定义哪些I\/O操作是可能的，特别是，
当通过加载和存储指令访问特定的内存地址时，该内存地址将被处理和排序为设备输入和设备
输出操作，
而不是内存读和写。 例如，
内存映射I\/O设备一般将使用未缓存的加载和存储，
使用I和O位进行排序而不是R和W位。
位。 指令集扩展可能还会描述新I\/O指令指令亦可能描述新I\/ O
指令同样会使用 FENCE 中的 I 和 O 位进行排序。
 FENCE。

[[fm]]
[float="center",align="center",cols="^1,^1,<3",options="header"]
.Fence 模式编码
|===
|_fm_字段 |助记符 |含义
|0000 |_none_ |正常 Fence
|1000 |TSO |使用`FENCE RW,RW`: 排除写-读排序; 否则为: _保留供未来使用._
|_other_ |_保留供未来使用._
|===

Fence 模式字段_fm_定义了`FENCE`的语义。 一个`FENCE`
使用 _fm_=`0000` 指令顺序排列其前置集合中的所有内存操作
在其前继指令集里的所有内存操作之前。

`FENCE.TSO` 指令被编码为一条 `FENCE` 指令
设置_fm_=`1000`，_predecessor_=`RW`，以及 successor`=`RW`。 `FENCE.TSO`对
该预先集中的所有装入操作在其后续集中的所有内存操作之前发出。
笔以其后续设定的所有存储操作，和其前继集中的所有存储操作
在其后续集的所有存储操作之前 。 这将`非AMO`
FENCE.TSO前接指令集中没有顺序的存储操作
FENCE.TSO后继集中的非AMO负载。

[注意]
====
因为FENCE RW,RW 强加了FENCE.TSO命令中的超集合，所以忽略_fm_字段更正是正确的，并将FENCE.TSO执行为FENCE RW，RW。EEP.这个组合可以用其他手段来实现。
可以忽略_fm_字段来实现FENCE.TSO作为FENCE RW，RW。
====

`FENCE`指令中未使用的字段-- _rs1_和 _rd_--被保留
以便在未来扩展中实现更细粒度的防护。 为向前兼容，
基本的实现应忽略这些字段，标准软件
应将这些字段置零。 同样，许多 _fm_ 和 predecessor\/successor
在<< fm >>中的设置也被保留以供将来使用。
基本实现应将所有此类保留配置视为
普通 _fm_=0000 的 fence，标准软件应仅使用
未保留的配置。

[提示]
====
我们选择了一个宽松的内存模型，以便简单的
机器实现以及未来可能的协处理器或
加速器扩展获得高性能。 我们将 I\/O 顺序与内存读/写
顺序分离，以避免设备驱动器核心内的不必要的串行化
并支持另一种非内存路径来控制添加的
协处理器或 I\/O 设备。 简单的实现可能还
会忽略 _predecessor_ 和 _successor_ 字段，并始终执行一个
保守的 fence 在所有操作上。
====

=== 环境调用和断点
`SYSTEM` 指令用于访问可能需要的系统功能
需要特权访问，并使用 I 类型指令编码
格式。 这些可以分为两大类：那些
原子地读-修改-写控制和状态寄存器 (CSR)，以及
所有其他可能的特权指令。 CSR 指令是
在 \u003c\u003ccsrinsts\u003e\u003e 中描述的，其基地
非特权指令在下节中描述。


[提示]
====
系统指令被定义以便于更简单的实现可以
始终陷入一个单一的软件陷阱处理程序。 更复杂的
实现可能在
硬件中执行更多的系统指令。
====

include::images\/wavedrom\/env_call-breakpoint.adoc[]
[[env-call]]
\/\/.环境调用和断点指令

这两个指令导致对支持的
执行环境的精确请求中断。

`ECALL` 指令用于向执行
环境发出服务请求。 `EEI` 将定义服务请求的参数传递方式
，但通常这些会位于
整数寄存器文件中的定义位置。

`EBREAK` 指令用于将控制返回给调试
环境。

[注意]
====
ECALL 和 EBREAK 之前分别命名为 SCALL 和 SBREAK。 这些
指令具有相同的功能和编码，但被重命名为
以反映它们可以更广泛地用于调用
超级管理员级操作系统或调试器。
====

[提示]
====
EBREAK 主要设计用于调试器使其
执行停止并返回到调试器。 EBREAK 还用于
标准 gcc 编译器标记不应
执行的代码路径。

EBREAK 的另一用途是支持“半主机”，其中执行
环境包括一个调试器，能够通过另一个
围绕 EBREAK 指令建立的备用系统调用接口提供服务。
由于 RISC-V 基本 ISA 不提供超过一个 EBREAK
指令，RISC-V 半主机使用一系列特殊指令
来区分一个半主机 EBREAK 和一个调试器插入的 EBREAK。

[source,asm]
....
    slli x0, x0, 0x1f   \# 输入 NOP
    ebreak              \# 中断到调试器
    srai x0, x0, 7      \# NOP 编码的半主机调用编号 7
....

请注意，这三个指令必须是 32 位宽的指令，
即，它们不能是描述的压缩 16 位指令之一
在 \u003c\u003ccompressed\u003e\u003e 中。

移位 NOP 指令仍被视为可用作
提示。

半主机是一种服务调用形式，更自然地
使用现有的 ABI 编码为 ECALL，但这将需要
调试器能够截取 ECALL，这是一项较新的扩展
调试标准。 我们打算转移到使用 ECALL 和一个
标准 ABI，在这种情况下，半主机可以与其他共用一个服务 ABI
现有标准。

我们注意到 ARM 处理器也已改用 SVC 代替 BKPT
在较新的设计中进行半主机调用。
====

=== HINT 指令
\/\/\#\[rv32i-hints,HINT 指令\]

[[rv32i-hints,HINT 指令]]

RV32I 为 HINT 指令保留了大量的编码空间，这些指令用来
通常用于向微架构传达性能提示。
与 NOP 指令类似，HINT 不改变任何结构上
可见的状态，除了推进 `pc` 和任何适用的
性能计数器。 实现始终可以忽略
已编码的提示。

大多数 RV32I HINT 编码为整数计算指令，附带
_rd_=x0。 其他 RV32I HINT 编码为带有
前驱或后继集为空，且_fm_=0。

[注意]
====
这些HINT编码的选择是为了使简单的实现能够
完全忽略HINT，而是将HINT作为常规的指令执行
因不改变体系结构状态而进行的指令。 例如，
如果目标寄存器是`x0`，ADD就是一个HINT；五位的
_rs1_和_rs2_字段编码为HINT的参数。 然而，简单的
实现只需将HINT简单地执行为_rs1_和_rs2_的ADD
并写入`x0`，这没有体系结构上可见的效果。

另一个例子是，如果_pred_字段和
_fm_字段全为零的FENCE指令就是一个HINT；_succ_、_rs1_和_rd_字段编码为
HINT的参数。 简单的实现可以
简单地将HINT执行为FENCE，从而使空的内存访问集在
_succ_字段编码的内存访问之前。
由于前驱集和后继集的交集为空，
该指令不引入任何内存序，因此
不会在体系结构上产生可见的效果。
====

<<t-rv32i-hints>> 列出所有RV32I HINT码点。 HINT空间的91%被保留用于标准Hint。
HINT空间的91%被保留用于标准Hint。 剩余的HINT
空间被指定为自定义HINT：这个子空间中将永远没有标准HINT。
这个子空间中将永远没有标准HINT。

[提示]
====
我们预计标准HINT最终会包括内存系统空间和时间性提示、
分支预测提示、线程调度
提示、安全标签，以及用于仿真/模拟的标记。
====

// 这个表格可能仍然存在一些问题 —— 某些行可能没有正确排列。 需要一个个单元格地检查。

[[t-rv32i-hints]]
.RV32I HINT指令。
[float="center",align="center",cols="<,<,^,<",options="header"]
|===
|指令 |约束 |码点 |用途

|LUI |_rd_=`x0` |latexmath:[$2^{20}$] .8+<.^m|_指定用于将来的标准用途_

|AUIPC |_rd_=`x0` |latexmath:[$2^{20}$]

|ADDI |_rd_=`x0`，并且_rs1_≠``x0``或_imm_≠0 |latexmath:[$2^{17}-1$]

|ANDI |_rd_=`x0` |latexmath:[$2^{17}$]

|ORI |_rd_=`x0` |latexmath:[$2^{17}$]

|XORI |_rd_=`x0` |latexmath:[$2^{17}$]

|ADD |_rd_=`x0`，_rs1_≠``x0`` |latexmath:[$2^{10}-32$]

|ADD |_rd_=`x0`，_rs1_=`x0`，_rs2_≠``x2-x5`` | 28

|ADD |_rd_=`x0`，_rs1_=`x0`，_rs2_=`x2-x5` |4|(_rs2_=`x2`) NTL.P1 + 
(_rs2_=`x3`) NTL.PALL +
(_rs2_=`x4`) NTL.S1 +
(_rs2_=`x5`) NTL.ALL

|SUB |_rd_=`x0` |latexmath:[$2^{10}$] .11+<.^m|_指定用于将来的标准用途_

|AND |_rd_=`x0` |latexmath:[$2^{10}$]

|OR |_rd_=`x0` |latexmath:[$2^{10}$]

|XOR |_rd_=`x0` |latexmath:[$2^{10}$]

|SLL |_rd_=`x0` |latexmath:[$2^{10}$]

|SRL |_rd_=`x0` |latexmath:[$2^{10}$]

|SRA |_rd_=`x0` |latexmath:[$2^{10}$]

|FENCE|_rd_=`x0`，_rs1_≠``x0``，_fm_=0，并且_pred_=0或_succ_=0| latexmath:[$2^{10}-63$]

|FENCE|_rd_≠``x0``，_rs1_=`x0`，_fm_=0，并且_pred_=0或_succ_=0| latexmath:[$2^{10}-63$]

|FENCE |_rd_=_rs1_=`x0`，_fm_=0, _pred_=0, _succ_≠0 |15

|FENCE |_rd_=_rs1_=`x0`，_fm_=0, _pred_≠W, _succ_=0 |15

|FENCE |_rd_=_rs1_=`x0`, _fm_=0, _pred_=W, _succ_=0 |1 |PAUSE

4+| 

|SLTI |_rd_=`x0` |latexmath:[$2^{17}$] .7+<.^m|_指定用于自定义用途_

|SLTIU|_rd_=`x0` |latexmath:[$2^{17}$]

|SLLI |_rd_=`x0` |latexmath:[$2^{10}$]

|SRLI |_rd_=`x0` |latexmath:[$2^{10}$]

|SRAI |_rd_=`x0` |latexmath:[$2^{10}$]

|SLT |_rd_=`x0` |latexmath:[$2^{10}$]

|SLTU |_rd_=`x0` |latexmath:[$2^{10}$]
|===

