[[rv32]]
== RV32I基础整数指令集，版本2.1

本章介绍RV32I基础整数指令集。

[提示]
====
RV32I的设计旨在足以作为编译器目标并支持现代操作系统环境。 该ISA还旨在减少最小实现中所需的硬件。 RV32I包含40条独特指令，尽管简单的实现可能通过一个始终捕获的SYSTEM硬件指令涵盖ECALL/EBREAK指令，并可能能够将FENCE指令实现为NOP，从而将基本指令数减少到总共38条。 RV32I几乎可以模拟任何其他ISA扩展（除了A扩展，A扩展需要额外的硬件支持以实现原子性）。

在实践中，包括机器模式特权架构的硬件实现还需要6条CSR指令。

基础整数ISA的子集可能对于教学目的有用，但该基础已经定义好，以至于除了省略对未对齐内存访问的支持并将所有SYSTEM指令视为单个捕获之外，几乎没有动机对真实的硬件实现进行子集化。
====

[注意]
====
标准的RISC-V汇编语言语法记载于《汇编程序员手册》中 (cite:[riscv-asm-manual])。
====

[注意]
====
大多数关于RV32I的评论也适用于RV64I基础。
====

=== 基础整数ISA的程序员模型

<<gprs>>显示了基础整数ISA的无特权状态。 对于RV32I，32个`x`寄存器每个都是32位宽，即`XLEN=32`。 寄存器`x0`是硬线连接的，所有位均为0。
通用寄存器`x1-x31`保存各种指令解释为布尔值集合、或二进制二补码有符号整数或无符号二进制整数的值。

还有一个额外的无特权寄存器：程序计数器`pc`，它保存当前指令的地址。

[[gprs]]
.RISC-V基础无特权整数寄存器状态。
[cols="<,^,>",options="header",width="50%",align="center",grid="rows"]
|===
<| [.small]#XLEN-1#| >| [.small]#0#
3+^| [.small]#x0/zero#
3+^| [.small]#x1#
3+^| [.small]#x2#
3+^| [.small]#x3#
3+^| [.small]#x4#
3+^| [.small]#x5#
3+^| [.small]#x6#
3+^| [.small]#x7#
3+^| [.small]#x8#
3+^| [.small]#x9#
3+^| [.small]#x10#
3+^| [.small]#x11#
3+^| [.small]#x12#
3+^| [.small]#x13#
3+^| [.small]#x14#
3+^| [.small]#x15#
3+^| [.small]#x16#
3+^| [.small]#x17#
3+^| [.small]#x18#
3+^| [.small]#x19#
3+^| [.small]#x20#
3+^| [.small]#x21#
3+^| [.small]#x22#
3+^| [.small]#x23#
3+^| [.small]#x24#
3+^| [.small]#x25#
3+^| [.small]#x26#
3+^| [.small
3+^|  [.small]#pc#
3+^| [.small]#XLEN#
|===
[注释]
====
在基本整数ISA中没有专用的堆栈指针或子程序返回地址链接寄存器；指令编码允许任何`x`寄存器用于这些目的。 然而，标准软件调用约定使用寄存器`x1`来保存调用的返回地址，寄存器`x5`可作为备用链接寄存器。 标准调用约定使用寄存器`x2`作为堆栈指针。

硬件可能会选择加速使用`x1`或`x5`的函数调用和返回。 参见JAL和JALR指令的描述。

可选的压缩16位指令格式是基于`x1`是返回地址寄存器和`x2`是堆栈指针的假设设计的。 使用其他约定的软件将正常运行，但可能会有更大的代码尺寸。

可用的架构寄存器数量可以对代码尺寸、性能和能量消耗产生巨大影响。 虽然16个寄存器可以说足够运行编译代码的整数ISA，但不可能使用3地址格式在16位指令中用16个寄存器编码完整的ISA。 虽然可能使用2地址格式，但这会增加指令数量并降低效率。
我们希望避免中间指令大小（如Xtensa的24位指令）以简化基本硬件实现，一旦采用32位指令大小，就可以直接支持32个整数寄存器。 更多的整数寄存器也能提高高性能代码的性能，在这里可以广泛使用循环展开、软件流水线和缓存平铺。

出于这些原因，我们为RV32I选择了常规的32个整数寄存器大小。 动态寄存器使用往往由几个经常访问的寄存器主导，可以优化寄存器文件实现以减少频繁访问寄存器的访问能量。cite:[jtseng:sbbci]。 可选的压缩16位指令格式主要只访问8个寄存器，因此可以提供密集的指令编码，而补充指令集扩展可以支持更大的寄存器空间（无论是平滑的还是分层的），如果需要。

对于资源受限的嵌入式应用，我们定义了RV32E子集，其仅有16个寄存器
(<<rv32e>>)。
====
=== 基本指令格式
在基本RV32I ISA中，有四种核心指令格式
(R/I/S/U) ，如<<base_instr>>中所示。 所有长度为固定32位。 基本ISA具有`IALIGN=32`，这意味着指令必须在内存中在四字节边界上对齐。 如果目标地址未`IALIGN-bit`对齐，则在采用的分支或无条件跳转上生成指令地址未对齐异常。
此异常在分支或跳转指令报告，而不是在目标指令上。 对于未采用的条件分支，不会生成指令地址未对齐异常。

[注释]
====
当指令扩展具有16位长度或其他16位长度的奇数倍值（即，IALIGN=16）时，基本ISA指令的对齐约束放宽到两字节边界。

指令地址未对齐异常在会导致指令未对齐的分支或跳转上报告，以帮助调试，并简化具有IALIGN=32的系统的硬件设计，这是发生未对齐的唯一地方。
====

解码保留指令时的行为未指定。

[注释]
====
某些平台可能要求为标准使用保留的操作码引发非法指令异常。 其他平台可能允许将保留的操作码空间用于不符合规范的扩展。
====

RISC-V ISA在所有格式中保持源（_rs1_和_rs2_）和目标（_rd_）寄存器在相同位置以简化解码。
除用于CSR指令（<<csrinsts>>）的5位立即数外，立即数始终符号扩展，并通常打包到指令中极左可用位，并已分配以减少硬件复杂性。 特别是，所有立即数的符号位始终在指令的第31位，以加快符号扩展电路。

include::images/wavedrom/instruction_formats.adoc[]
[[base_instr,基本指令格式]]
RISC-V基本指令格式。 每个立即子字段用所生成立即数的位位置（imm[x]）标记，而不是通常情况下指令的立即字段内的位位置。

[注释]
====
解码寄存器说明符通常位于实现的关键路径上，因此选择指令格式以在所有格式中保持所有寄存器说明符在相同位置，代价是必须在格式间移动立即位（该特性与RISC-IV aka共享）。 SPUR cite:[spur-jsscc1989] 。

实际上，大多数立即数要么很小，要么需要所有XLEN位。
我们选择了不对称的立即划分（常规指令中的12位再加上具有20位的特殊加载上立即指令）来增加常规指令的可用操作码空间。

立即数是符号扩展的，因为我们没有观察到为某些立即数使用零扩展的好处，如MIPS ISA中那样，并希望保持ISA尽可能简单。
====

=== 立即数编码变体

根据对立即数的处理，还有两种指令格式变体（B/J），如<<baseinstformatsimm>>中所示。

include::images/wavedrom/immediate_variants.adoc[]
[[baseinstformatsimm, 基本指令格式立即数变体。]]
///.RISC-V基本指令格式，显示立即数变体。


S和B格式之间的唯一区别是B格式中使用12位立即字段以2的倍数编码分支偏移量。 不是像通常情况下的那样在硬件中将指令编码的立即数的所有位左移一位，而是使中间位（imm[10:1]）和符号位保持在固定位置，而S格式中的最低位（inst[7]）在B格式中编码高阶位。

同样，U和J格式之间的唯一区别是20位立即数左移12位以形成U立即数，并左移1位以形成J立即数。 U和J格式立即数的指令位位置选择为最大化与其他格式及其自身之间的重叠。

<<immtypes>>显示了每种基本指令格式产生的立即数，并标记了哪个指令位（inst[_y_]）产生立即数的每个位。
[[immtypes, 立即数类型]]
.RISC-V指令产生的立即数类型。 
include::images/wavedrom/immediate.adoc[]

字段用指令位标记，用于构建它们的值。  符号扩展始终使用inst[31] 。

[注释]
====
符号扩展是对立即数的最关键操作之一（特别是对于XLEN>32），在RISC-V中，所有立即数的符号位始终保存在指令的第31位中，以允许符号扩展与指令解码并行进行。

尽管更复杂的实现可能具有用于分支和跳转计算的单独加法器，因此不受益于保持立即数位在指令类型间的恒定位置，但我们希望减少最简单实现的硬件成本。 通过旋转B和J立即数的指令编码中的位，而不是使用动态硬件多路复用器将立即数乘以2，我们将指令信号风扇出和立即多路复用器成本降低约2倍。 扰乱的立即数编码将在静态或提前编译上增加的时间量可以忽略不计。 对于指令的动态生成，有一些小的额外开销，但大多数常见的短前向分支都有直接的立即数编码。
====

=== 整数计算指令

大多数整数计算指令在整数寄存器文件中保存的`XLEN`位的值上操作。 整数计算指令要么以I类型格式编码为寄存器立即操作，要么以R类型格式编码为寄存器寄存器操作。 目的地是寄存器立即指令和寄存器寄存器指令的寄存器_rd_。 没有整数计算指令引起算术异常。

[提示]
====
我们没有在基础指令集中包含对整数算术操作进行溢出检查的特殊指令集支持，因为许多溢出检查可以通过RISC-V分支实现，成本很低。
无符号加法的溢出检查只需要在加法之后增加一条分支指令：
`add t0, t1, t2; bltu t0, t1, overflow`。

对于有符号的加法，如果知道一个操作数的符号，溢出检查只在加法之后需要一个分支：
`addi t0, t1, +imm; blt t0, t1, overflow`。 这涵盖了具有立即操作数的加法的常见情况。

对于一般有符号加法，加法后需要三条额外指令，利用的观察是，只有在另一个操作数为负时，和才小于其中一个操作数。

[源,文本]
....
         add t0, t1, t2
         slti t3, t2, 0
         slt t4, t0, t1
         bne t3, t4, overflow
....

在RV64I中，可以通过比较ADD和ADDW在操作数上的结果来进一步优化32位有符号加法的检查。
====

==== 整数寄存器立即指令

include::images/wavedrom/integer_computational.adoc[]
///.整数计算指令

ADDI将符号扩展的12位立即数加到寄存器_rs1_ 中。
忽略算术溢出，结果仅是结果的低XLEN位。 ADDI _rd, rs1, 0_ 用于实现MV _rd,
rs1_ 汇编伪指令。

如果将寄存器_rs1_和符号扩展的立即数都视为有符号数，并且寄存器_rs1_小于该立即数，SLTI（设置小于立即数）将值1放入寄存器_rd_中，否则将0写入_rd_。 SLTIU类似，但将值作为无符号数进行比较（即，立即数先符号扩展为XLEN位，然后视为无符号数）。
请注意，如果_rs1_等于零，SLTIU _rd, rs1, 1_ 将_rd_设置为1，否则将_rd_设置为0（汇编伪指令SEQZ _rd, rs_）。

ANDI、ORI、XORI是逻辑操作，它们对寄存器_rs1_和符号扩展12位立即数进行按位与、或和异或操作，并将结果放入_rd_中。 请注意，XORI _rd, rs1, -1_ 执行寄存器_rs1_的按位逻辑反转（汇编伪指令NOT _rd, rs_）。

include::images/wavedrom/int-comp-slli-srli-srai.adoc[]
[[int-comp-slli-srli-srai]]
//.整数寄存器立即，SLLI，SRLI，SRAI

常数字移位被编码为I类型格式的特化。 要移位的操作数在_rs1_中，移位量在I型立即字段的低5位中编码。 右移类型编码在第30位。 SLLI是逻辑左移（零被移到低位）；SRLI是逻辑右移（零被移到高位）；而SRAI是算术右移（原始符号位被复制到空出的高位）。

include::images/wavedrom/int-comp-lui-aiupc.adoc[]
[[int-comp-lui-aiupc]]
//.整数寄存器立即，U型立即

LUI（加载上立即值）用于构建32位常量，使用U型格式。 LUI将32位U型立即值放入目标寄存器_rd_中，并用零填充最低的12位。

AUIPC（将上立即数加到`pc`）用于构建与`pc`相关的地址，并使用U型格式。 AUIPC从U型立即数形成32位偏移量，填充最低的12位为零，将此偏移量加到AUIPC指令的地址，然后将结果放入寄存器_rd_中。

[注释]
====
`lui`和`auipc`的汇编语法不表示U型立即数的低12位，这些位总是为零。

AUIPC指令支持两条指令序列，用于在控制流传输和数据访问中从PC访问任意偏移量。 AUIPC和JALR中的12位立即数组合可以将控制转移到任何32位与PC相关的地址，而AUIPC加上常规加载或存储指令中的12位立即数偏移可以访问任何32位的PC相关数据地址。

通过将U型立即数设置为0，可以获得当前PC。 尽管JAL +4指令也可以用于获取本地PC（JAL之后的指令），但在更简单的微架构中可能会导致管道中断，或在更复杂的微架构中污染BTB结构。
====

==== 整数寄存器寄存器操作

RV32I定义了几种算术R类型操作。 所有操作都读取_rs1_和_rs2_寄存器作为源操作数，并将结果写入寄存器_rd_中。 _funct7_ 和_funct3_ 字段选择操作类型。

include::images/wavedrom/int_reg-reg.adoc[]
[[int-reg-reg]]
//.整数寄存器寄存器

ADD执行_rs1_和_rs2_的加法。 SUB执行_rs1_减去_rs2_的减法。 溢出被忽略，并且结果的低 XLEN 位被写入目标 _rd_。 SLT和SLTU分别进行有符号和无符号比较，如果_rs1_ < _rs2_，写入1到_rd_，否则为0。 请注意，如果_rs2_不等于零，SLTU _rd_, _x0_, _rs2_将_rd_设置为1，否则设置_rd_为零（汇编伪指令SNEZ _rd, rs_）。 AND、OR和XOR执行按位逻辑操作。

SLL、SRL和SRA通过寄存器_rs2_的低5位中保存的移位量，对寄存器_rs1_中的值执行逻辑左移、逻辑右移和算术右移。

==== NOP指令

include::images/wavedrom/nop.adoc[]
[[nop]]
//.NOP指令

NOP指令不会更改任何架构可见状态，除了推进`pc`和增计任何适用的性能计数器。 NOP 被编码为 ADDI _x0, x0, 0_。

[注释]
====
NOP可以用来将代码段对齐到微架构显著的地址边界，或为内联代码修改留出空间。 尽管可以通过多种方法编码NOP，我们定义了一种标准的NOP编码以允许微架构优化和更具可读性的反汇编输出。 其他NOP编码可用于<<rv32i-hints>> 。

选择 ADDI 作为 NOP 编码是因为它最有可能在多个系统中执行时占用最少的资源（如果在解码时未优化）。 特别是，该指令只读取一个寄存器。
此外，在超级标量设计中，ADDI 功能单元也更可能可用，因为加法是最常见的操作。 特别是，地址生成函数单元可以使用基准+偏移地址计算所需的相同硬件执行ADDI，而寄存器-寄存器ADD或逻辑/移位操作需要额外的硬件。
====

=== 控制转移指令
RV32I提供两种类型的控制转移指令：无条件跳转和条件分支。 RV32I中的控制转移指令没有架构上可见的延迟槽。

如果在跳转或采用分支的目标上发生指令访问错误或指令页错误异常，该异常将在目标指令上报告，而不是在跳转或分支指令上。

==== 无条件跳转
跳转和链接（JAL）指令使用J型格式，J型立即数编码2字节倍数的带符号偏移量。 偏移量进行符号扩展并加到跳转指令的地址上，形成跳转目标地址。 因此，跳转可以定位到±1 MiB范围。 JAL将跳转后指令的地址（'pc'+4）存储到寄存器_rd_中。 标准软件调用约定使用'x1'作为返回地址寄存器，'x5'作为备用链接寄存器。

[注释]
====
备用链接寄存器支持调用millicode例程（如，在压缩代码中保存和恢复寄存器的那些例程），同时保留常规返回地址寄存器。 选择寄存器`x5`作为备用链接寄存器，因为它在标准调用约定中映射到一个临时寄存器，并且其编码与常规链接寄存器仅有一位之差。
====

普通无条件跳转（汇编伪指令J）被编码为JAL与_rd_=`x0`。

include::images/wavedrom/ct-unconditional.adoc[]
[[ct-unconditional]]
//.无条件跳转指令，JAL

间接跳转指令JALR（跳转并链接寄存器）使用I类型编码。 目标地址是通过将符号扩展的12位I型立即数加到寄存器_rs1_获得的，然后将结果的最低位设置为零。 跳转后的指令地址（`pc`+4）被写入寄存器 _rd_。
如果不需要该结果，寄存器`x0`可以用作目标。

include::images/wavedrom/ct-unconditional-2.adoc[]
[[ct-unconditional-2]]
//.间接无条件跳转指令，JALR

[注意]
====
无条件跳转指令都使用PC相对寻址以帮助支持位置无关代码。 定义JALR指令是为了实现两条指令序列可以在32位绝对地址范围中跳转到任何位置。 LUI指令可以首先用目标地址的高20位加载_rs1_，然后JALR可以加入低位。
类似地，AUIPC然后JALR可以在32位`pc`相对地址范围内的任何位置跳转。

请注意，JALR指令不像条件分支指令那样，将12位立即数视为2字节的倍数。 这避免了硬件中的另一种立即数格式。 实际上，大多数使用JALR的场合要么有零立即数，要么与LUI或AUIPC配对，因此范围减小稍微不显著。

在计算JALR目标地址时清除最低位既轻微简化了硬件，又允许将函数指针的低位用来存储辅助信息。 虽然在这种情况下可能会有轻微的错误检查损失，但实际上跳转到不正确的指令地址通常会迅速引发异常。

当与基底_rs1_=`x0`一起使用时，JALR可用于从地址空间中的任何位置实现单指令子程序调用到最低或最高地址区域，这可以用于实现快速调用小型运行时库。 或者，ABI可以专用一个通用寄存器指向地址空间其他地方的库。
====

如果目标地址没有对齐到四字节边界，JAL和JALR指令将生成指令地址未对齐异常。

[注释]
====
在支持16位对齐指令扩展的机器上，例如压缩指令集扩展C，不可能出现指令地址未对齐异常。
====

返回地址预测栈是高性能指令获取单元的常见功能，但需要准确检测用于过程调用和返回的指令才能有效。
对于RISC-V，且关于指令使用的提示通过使用的寄存器编号隐式编码。 只有当_rd_是'x1'或`x5`时，JAL指令才应该将返回地址推送到返回地址栈（RAS）上。 JALR指令应如<<rashints>>中所示地推/弹出一个RAS。

[[rashints]]
.在JALR指令的寄存器操作数中编码的返回地址栈预测提示。
[%autowidth,float="center",align="center",cols="^,^,^,<",options="header"]
|===
|_rd_是_x1/x5_ |_rs1_是_x1/x5_ |_rd_=_rs1_|RAS 动作

|否 |否 |-- |无

|否 |是 |-- |弹出

|是 |否 |-- |推入

|是 |是 |否 |弹出，然后推入

|是 |是 |是 |推入
|===


[注释]
====
一些其他ISA向其间接跳转指令中添加了显式提示位以指导返回地址栈操作。 我们使用与寄存器编号和调用约定相关的隐式提示以减少用于这些提示的编码空间。

当两个不同的链接寄存器（`x1`和`x5`）作为_rs1_和_rd_给出时，RAS既会被弹出又会推入以支持协程。 如果
_rs1_ 和 _rd_ 是相同的链接寄存器（即 `x1` 或 `x5`），则仅推入 RAS 以启用序列的宏操作融合：
`lui ra, imm20; jalr ra, imm12(ra)_ 和 _auipc ra, imm20; jalr ra, imm12(ra)`
====

==== 条件分支

所有分支指令均使用B型指令格式。 12位B型立即数编码以2字节的倍数表示的有符号偏移。 偏移量进行符号扩展并加到分支指令的地址上产生目标地址。 条件分支范围是±4 KiB。

include::images/wavedrom/ct-conditional.adoc[]
[[ct-conditional]]
//.条件分支

分支指令比较两个寄存器。 如果寄存器_rs1_和_rs2_分别相等或不相等，BEQ和BNE进行分支。 如果_rs1_小于_rs2_，BLT和BLTU分别通过有符号和无符号比较进行分支。 如果_rs1_大于或等于_rs2_，BGE和BGEU分别通过有符号和无符号比较进行分支。 请注意，可以通过反转BLT、BLTU、BGE和BGEU的操作数来合成BGT、BGTU、BLE和BLEU。

[注释]
====
可以通过单个BLTU指令检查有符号数组边界，因为任何负索引都会大于任何非负边界。
====

软件应优化，使顺序代码路径是最常见的路径，放置在外的代码路径是很少采用的。 软件还应假定向后分支将预测为已采用，而向前分支将预测为未采用，至少在首次遇到时如此。 动态预测器应该快速学习任何可预测的分支行为。

与某些其他架构不同，RISC-V跳转（JAL与_rd_=`x0`）\指令应始终用于无条件分支，而不是条件始终为真的条件分支指令。 RISC-V\跳转也是PC相对的，并且支持比分支更宽的偏移范围，并且不会污染条件分支预测表。

[提示]
====
条件分支被设计为包括两个寄存器之间的算术比较\操作（也在PA-RISC、Xtensa和\nMIPS R6中完成），而不是使用条件代码（x86、ARM、SPARC、PowerPC），或\n只将一个寄存器与零进行比较（Alpha、MIPS），或者\n仅比较两个寄存器的相等性（MIPS）。 此设计的动机是观察到比较和分支组合的指令适合常规管道，避免了额外的条件代码状态或使用临时寄存器，并减少了静态代码大小和动态指令\提取流量。 另一点是，与零的比较需要非平凡的电路延迟（尤其是在先进工艺中转向静态逻辑之后），因此几乎与算术\比较一样昂贵。 比较与分支融合指令的另一个优势是，分支在前端\指令流中观察得更早，因此可以更早被预测。 在根据相同条件代码可以采用多个\n分支的情况下，使用条件代码的设计可能会有一定优势，但我们认为\这种情况相对罕见。

我们考虑了，但没有在指令\n编码中包含静态分支提示。 这些可以减少动态预测器的压力，但\需要更多的指令编码空间和软件性能分析以获得最佳\结果，并且如果生产运行不匹配性能分析运行，可能导致性能不佳。

我们考虑了，但没有包含条件移动或已预言\指令，这可以有效地替代难以预测的短前向\n分支。 在两个中，条件移动是较简单的一种，但难以用于可能导致异常的条件代码（内存访问和浮点操作）。 预言在系统中增加额外的标志状态，额外的指令来设置和\清除标志，并为每条指令增加额外的编码开销。 无论是\n条件移动还是预言指令，都增加了乱序微架构的复杂性，增加了一个隐式的第三源操作数，因为如果预言为假，则需要将目标架构寄存器的原始值复制到重命名的目标物理寄存器中。 此外，使用\预言而不是分支的静态编译时决策可能会导致未包含在编译器训练集合中的输入上性能较低，尤其是考虑到\不可预测的分支很少，且随着分支预测\技术的进步变得更少。

我们注意到，存在多种微架构技术，可以动态\将不可预测的短前向分支转换为内部预言\代码，以避免在分支错误预测引起的管道刷新成本cite:[heil-tr1996], cite:[Klauser-1998], cite:[Kim-micro2005]，并\被实现于商业处理器中 cite:[ibmpower7] 。 最简单的方法\只是通过仅刷新分支影中的指令而不是整个提取管道，或者通过使用宽指令提取或闲指令提取槽从两侧提取指令来降低从错误预测的短前向分支恢复的惩罚。 对于乱序核心的更复杂\方法是在分支影中的指令上添加内部预言，并由分支指令编写内部预言值，允许分支及其后的指令对其他代码进行推测执行和乱序执行。
====

如果目标地址未对齐到四字节边界且分支条件评估为真，条件分支指令将生成指令地址未对齐异常。 如果分支条件评估为假，则不会引发指令地址未对齐异常。

[注释]
====
在支持具有16位对齐指令扩展的机器上，如压缩指令集扩展C，指令地址未对齐异常不可能出现。
====

[[ldst]]
=== 加载和存储指令
RV32I 是一种存储架构，其中只有加载和存储指令访问内存，而算术指令仅在 CPU 寄存器上运行。 RV32I提供一个32位地址空间，\n按字节寻址。 EEI将定义\n哪些指令可以合法访问地址空间的哪些部分（例如，某些地址可能\n仅供读取，或仅支持字访问）。 尽管加载值被丢弃，但目标为\n`x0`的加载仍必须引发任何异常并导致任何其他副作用。

EEI将定义内存系统是小端模式还是大端模式。 在RISC-V中，字节序是字节地址不变的。

[提示]
====
在一个字节地址不变的系统中，遵循以下性质：如果一个字节存储到某个地址，以某种字节序存储，那么从该地址以任何字节序进行的字节大小加载将返回存储的值。

在小端配置中，多字节存储将\n最低有效寄存器字节写入最低内存字节地址，\n接下来是其他寄存器字节，按其重要性的升序排列。 加载同样地将较小内存\n字节地址的内容传输到较低重要性的

在大端配置中，多字节存储将最高有效寄存器字节写入最低的内存字节地址，接着按其重要性降序写入其他寄存器字节。 加载类似地将较大内存字节地址的内容传输到较低有效的寄存器字节。
====

include::images/wavedrom/load_store.adoc[]
[[load-store,加载和存储]]
//.加载和存储指令

加载和存储指令在寄存器和内存之间传输值。 加载指令以 I 型格式编码，存储指令为 S 型。
有效地址通过将寄存器 _rs1_ 加到符号扩展的 12 位偏移量来获得。 加载从内存复制一个值到寄存器
_rd_。 存储将寄存器 _rs2_ 中的值复制到内存。

LW 指令从内存加载一个 32 位值到 _rd_。 LH 指令从内存加载一个 16 位值，然后符号扩展到 32 位再存储到 _rd_。 LHU 指令从内存加载一个 16 位值，然后零扩展到 32 位再存储到 _rd_。 LB 和 LBU 是针对 8 位值类似定义的。 SW、SH 和 SB 指令将寄存器 _rs2_ 的低位的 32 位、16 位和 8 位值存储到内存。

无论 EEI，具有自然对齐有效地址的加载和存储都不会引发地址未对齐异常。 加载和存储有效地址如果不是自然对齐到引用的数据类型（即，有效地址不能整除访问的字节大小）则其行为依赖于 EEI。

EEI 可能保证完全支持未对齐的加载和存储，因此在执行环境中运行的软件不会遇到局部或致命的地址对齐陷阱。 在此情况下，未对齐的加载和存储可以通过硬件处理，或通过进入执行环境实现的不显性陷阱处理，或可能是根据地址的硬件和不显性陷阱相结合处理。

EEI 可能不保证未对齐的加载和存储能被不显性处理。 在这种情况下，未自然对齐的加载和存储可能成功完成执行或引发异常。 引发的异常可能是地址未对齐异常或访问错误异常。 对于本可以完成但因未对齐而不能完成的内存访问，如果未对齐的访问不应仿真（例如，如果访问内存区域有副作用），则可以引发访问错误异常而不是地址未对齐异常。 当 EEI 不保证未对齐的加载和存储被不显性处理时，EEI 必须定义地址未对齐引发的异常是导致局域陷阱（允许在执行环境中运行的软件处理该陷阱）还是致命的陷阱（终止执行）。

[提示]
====
在移植遗留代码时偶尔需要未对齐访问，并在使用任何形式的打包 SIMD 扩展或处理外部打包数据结构时有助于提升应用程序性能。 我们允许 EEIs 选择通过常规加载和存储指令来支持未对齐访问的理由是简化未对齐硬件支持的增加。 一个方案是禁止在基本 ISA 中未对齐访问，然后提供一些独立的 ISA 支持，或者是用于软件处理未对齐访问的特殊指令，或者是用于未对齐访问的新硬件地址模式。 特殊指令难以使用，复杂化 ISA，并常常增加新处理器状态（如 SPARC VIS 对齐地址偏移寄存器）或复杂化对现有处理器状态的访问（如 MIPS LWL/LWR 部分寄存器写入）。 此外，对于循环导向的打包 SIMD 代码，操作数未对齐时的额外开销会激励软件根据操作数对齐情况提供多种循环形式，这复杂化了代码生成并增加了循环启动开销。 新的未对齐硬件地址模式在指令编码中占用大量空间或需要极简化的地址模式（例如，仅寄存器间接）。
====

即使未对齐的加载和存储成功完成，这些访问可能会根据实现情况（例如，通过不显性陷阱实现）运行得极慢。 此外，虽然自然对齐的加载和存储可保证原子执行，未对齐的加载和存储可能无法做到，因此需要额外的同步以确保原子性。

[注意]
====
我们不强制要求未对齐访问的原子性，因此执行环境实现可以使用不显性机器陷阱和软件处理器来处理部分或全部未对齐访问。 如果提供硬件未对齐支持，软件可以简单地使用常规加载和存储指令加以利用。 硬件可以视运行时地址是否对齐自动优化访问。
====

[[fence]]
=== 内存排序指令

include::images/wavedrom/mem_order.adoc[]
[[mem-order]]
//.内存排序指令

FENCE 指令用于按其他 RISC-V hart 和外部设备或协处理器查看来排序设备 I/O 和内存访问。 可以按照同样的任意组合顺序排序设备输入（I）、设备输出（O）、内存读取（R）和内存写入（W）的任意组合。 非正式地，其他 RISC-V hart 或外部设备在 FENCE 之前无法观察到 FENCE 之后任何 _successor_ 集操作。
<<memorymodel>> 提供了 RISC-V 内存一致性模型的精确描述。

FENCE 指令还会按外部设备执行的内存读写进行排序内存读写。
但是，FENCE 不会对外部设备使用任何其他信令机制进行的事件观察排序。

[注意]
====
某个设备可能通过某种外部通信机制观察到对内存位置的访问，例如，驱动中断信号到中断控制器的内存映射控制寄存器。 该通信不在 FENCE 排序机制的范围内，因此 FENCE 指令无法保证中断信号的变化何时对于中断控制器可见。 具体设备可能提供额外的排序保证以减少软件开销，但这超出了 RISC-V 内存模型的范围。
====

EEI 将定义可能的 I/O 操作，特别是，当加载和存储指令访问的哪个内存地址将分别被视为并排序为设备输入和设备输出操作而不是内存读写。 例如，内存映射 I/O 设备通常使用未缓存的加载和存储进行访问，这些加载和存储使用 I 和 O 位而非 R 和 W 位进行排序。 指令集扩展可能还描述了一些新 I/O 指令，也会在 FENCE 中使用 I 和 O 位排序。

[[fm]]
[float="center",align="center",cols="^1,^1,<3",options="header"]
.FENCE 模式编码
|===
|_fm_ 字段 |助记符 |含义
|0000 |_none_ |普通 FENCE
|1000 |TSO |使用 `FENCE RW,RW` 时：排除写到读排序；否则：_保留供将来使用。_
2+|_other_ |_保留供将来使用。_
|===

FENCE 模式字段 _fm_ 定义了 `FENCE` 的语义。 带有 _fm_=`0000` 的 `FENCE`
将其前置集中的所有内存操作排序在其后继集中的所有内存操作之前。

`FENCE.TSO` 指令被编码为 `FENCE` 指令，
带有 _fm_=`1000`、_predecessor_=`RW` 和 _successor_=`RW`。 `FENCE.TSO` 将其前置集中的所有加载操作排序在其后继集中的所有内存操作之前，并将前置集中的所有存储操作排序在后继集中的所有存储操作之前。 这使得 `FENCE.TSO` 的前置集中 `non-AMO` 存储操作与后继集中 `non-AMO` 加载操作未排序。

[注意]
====
因为 FENCE RW,RW 强加了 FENCE.TSO 强加的排序超集，可以忽略 _fm_ 字段并将 FENCE.TSO 实现为 FENCE RW,RW。
====

`FENCE` 指令中未使用的字段——_rs1_ 和 _rd_——保留用于将来扩展中的更细粒度的 FENCE。 为向前兼容，
基础实现应忽略这些字段，而标准软件应将这些字段置为零。 同样，许多在 <<fm>> 中的 _fm_ 和前置/后继集设置也保留供将来使用。
基础实现应将所有这些保留的配置视为常规 FENCE，_fm_ 字段为 0000，标准软件应仅使用非保留的配置。

[提示]
====
我们选择了一种宽松的内存模型，以便简单的机器实现和未来可能的协处理器或加速器扩展实现高性能。 我们将 I/O 排序与内存 R/W
排序分离，以避免设备驱动 hart 内不必要的序列化，并支持非内存路径来控制新增的协处理器或 I/O 设备。 简单实现还可以忽略 _predecessor_ 和 _successor_ 字段，对所有操作执行保守的 FENCE。
====

=== 环境调用和断点
`SYSTEM` 指令用于访问可能需要特权访问的系统功能，并使用 I 型指令格式进行编码。 这些可以分为两大类：那些以原子方式读-改-写控制和状态寄存器（CSRs）的，和所有其他潜在特权指令。 CSR 指令在 <<csrinsts>> 中描述，基础非特权的指令在下一节中描述。


[提示]
====
SYSTEM 指令定义为允许更简单的实现始终陷入到单一软件陷阱处理器。 更复杂的实现可能会在硬件中执行更多的每条系统指令。
====

include::images/wavedrom/env_call-breakpoint.adoc[]
[[env-call]]
//.环境调用和断点指令

这两个指令引发对支持执行环境的精确请求陷阱。

`ECALL` 指令用于向执行环境提出服务请求。 `EEI` 将定义服务请求的参数如何传递，但通常这些将在整数寄存器文件的定义位置中。

`EBREAK` 指令用于返回控制权到调试环境。

[注意]
====
ECALL 和 EBREAK 之前分别称为 SCALL 和 SBREAK。 这些指令具有相同的功能和编码，但是被重命名为反映它们可以比调用监督级操作系统或调试器更普遍使用。
====

[提示]
====
EBREAK 主要设计为由调试器使用以导致执行停止并返回调试器。 标准 gcc 编译器也使用 EBREAK 来标记不应执行的代码路径。

EBREAK 的另一用途是支持“半主机”，执行环境包括一个调试器，该调试器可以通过围绕 EBREAK 指令构建的替代系统调用接口提供服务。
由于 RISC-V 基本 ISA 不提供多于一个的 EBREAK 指令，RISC-V 半主机使用一系列特殊指令来区分半主机 EBREAK 和调试器插入的 EBREAK。

[source,asm]
....
    slli x0, x0, 0x1f   # 入口 NOP
    ebreak              # 中断到调试器
    srai x0, x0, 7      # 编码半主机调用号 7 的 NOP
....

注意，这三个指令必须是 32 位宽的指令，
即，不得为在 <<compressed>> 中描述的压缩 16 位指令。

移位 NOP 指令仍被视为可用作 HINTs。

半主机是一种服务调用形式，更自然地编码为使用现有 ABI 的 ECALL，但这需要调试器能够拦截 ECALL，这是调试标准中的新增加功能。 我们打算转而使用带有标准 ABI 的 ECALL，这样，半主机可以与现有标准共享服务 ABI。

我们注意到 ARM 处理器也已转而在新设计中使用 SVC 而不是 BKPT 进行半主机调用。
====

=== HINT 指令
//[#rv32i-hints,HINT 指令]

[[rv32i-hints,HINT 指令]]

RV32I 为 HINT 指令保留了大量编码空间，通常用于向微架构传达性能提示。
与 NOP 指令一样，HINTs 不会更改任何架构可见状态，除了推进 `pc` 和任何适用的性能计数器。 始终允许实现忽略编码提示。

大多数 RV32I HINTs 被编码为整数计算指令，_rd_=x0。 其他 RV32I HINTs 被编码为 FENCE 指令，
带有空前置或后继集和 _fm_=0。

[注意]
====
选择这些 HINT 编码是为了简单实现可以完全忽略 HINTs，
相反地，将 HINTs 作为常规指令执行，
只是不改变架构状态。 例如，如果目标寄存器是 `x0`，
则 ADD 是一个 HINT；五位 _rs1_ 和 _rs2_ 字段为 HINT 编码参数。 然而，简单实现可以仅执行该 HINT，
作为 _rs1_ 和 _rs2_
的 ADD 写入 `x0`，没有架构可见效果。

再例如，一个 
带有零 _pred_ 字段和零 _fm_ 字段的 FENCE 指令是一个 HINT；
_succ_, _rs1_ 和 _rd_ 字段为 HINT 编码参数。 A simple implementation can simply execute the
HINT as a FENCE that orders the null set of prior memory accesses before
whichever subsequent memory accesses are encoded in the _succ_ field.
由于前置集和后继集的交集为空，
该指令不强加内存排序，
因此没有架构可见效果。
====

<<t-rv32i-hints>> 列出了所有 RV32I HINT 代码点。 91% 的 HINT 空间保留供标准 HINTs 使用。 其余 HINT 空间指定用于自定义 HINTs：此子空间中不会定义标准 HINTs。

[提示]
====
我们预期标准提示将最终包括内存系统的空间和时间局部性提示、分支预测提示、线程调度提示、安全标签和用于仿真/模拟的工具标志。
====

// 此表格可能仍有一些问题——某些行可能没有正确放置。 需要逐个单元格地检查。

[[t-rv32i-hints]]
.RV32I HINT 指令。
[float="center",align="center",cols="<,<,^,<",options="header"]
|===
|指令 |限制 |代码点 |目的

|LUI |_rd_=`x0` |latexmath:[$2^{20}$] .8+<.^m|_指定用于未来标准使用。_

|AUIPC |_rd_=`x0` |latexmath:[$2^{20}$]

|ADDI |_rd_=`x0`，且 _rs1_≠``x0`` 或 _imm_≠0 |latexmath:[$2^{17}-1$]

|ANDI |_rd_=`x0` |latexmath:[$2^{17}$]

|ORI |_rd_=`x0` |latexmath:[$2^{17}$]

|XORI |_rd_=`x0` |latexmath:[$2^{17}$]

|ADD |_rd_=`x0`, _rs1_≠``x0`` |latexmath:[$2^{10}-32$]

|ADD |_rd_=`x0`, _rs1_=`x0`, _rs2_≠``x2-x5`` | 28

|ADD |_rd_=`x0`, _rs1_=`x0`, _rs2_=`x2-x5` |4|(_rs2_=`x2`) NTL.P1 + 
(_rs2_=`x3`) NTL.PALL +
(_rs2_=`x4`) NTL.S1 +
(_rs2_=`x5`) NTL.ALL

|SUB |_rd_=`x0` |latexmath:[$2^{10}$] .11+<.^m|_指定用于未来标准使用。_

|AND |_rd_=`x0` |latexmath:[$2^{10}$]

|OR |_rd_=`x0` |latexmath:[$2^{10}$]

|XOR |_rd_=`x0` |latexmath:[$2^{10}$]

|SLL |_rd_=`x0` |latexmath:[$2^{10}$]

|SRL |_rd_=`x0` |latexmath:[$2^{10}$]

|SRA |_rd_=`x0` |latexmath:[$2^{10}$]

|FENCE|_rd_=`x0`, _rs1_≠``x0``, _fm_=0, 且 _pred_=0 或 _succ_=0| latexmath:[$2^{10}-63$]

|FENCE|_rd_≠``x0``, _rs1_=`x0`, _fm_=0, 且 _pred_=0 或 _succ_=0| latexmath:[$2^{10}-63$]

|FENCE |_rd_=_rs1_=`x0`, _fm_=0, _pred_=0, _succ_≠0 |15

|FENCE |_rd_=_rs1_=`x0`, _fm_=0, _pred_≠W, _succ_=0 |15

|FENCE |_rd_=_rs1_=`x0`, _fm_=0, _pred_=W, _succ_=0 |1 |PAUSE

4+| 

|SLTI |_rd_=`x0` |latexmath:[$2^{17}$] .7+<.^m|_指定用于自定义使用。_

|SLTIU|_rd_=`x0` |latexmath:[$2^{17}$]

|SLLI |_rd_=`x0` |latexmath:[$2^{10}$]

|SRLI |_rd_=`x0` |latexmath:[$2^{10}$]

|SRAI |_rd_=`x0` |latexmath:[$2^{10}$]

|SLT |_rd_=`x0` |latexmath:[$2^{10}$]

|SLTU |_rd_=`x0` |latexmath:[$2^{10}$]
|===

