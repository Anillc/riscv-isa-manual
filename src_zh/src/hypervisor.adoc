[[hypervisor]]
== "H" 扩展用于虚拟机支持，版本 1.0

本章描述了 RISC-V 的虚拟机扩展，虚拟化了监督级架构以支持高效托管来宾操作系统在类型-1 或类型-2 虚拟机之上。
虚拟机扩展将监督模式更改为 _虚拟机扩展监督模式_（HS 模式，简称_虚拟机模式_），在这种模式下运行虚拟机或托管功能的操作系统。
虚拟机扩展还添加了另一个地址翻译阶段，从_来宾物理地址_到领导者物理地址，为来宾操作系统虚拟化内存和内存映射的I/O子系统。 HS 模式与 S 模式作用相同，但具有用于控制新地址翻译阶段并支持在虚拟 S 模式（VS 模式）中托管来宾操作系统的附加指令和 CSR。 常规 S 模式的操作系统可以在不修改的情况下在 HS 模式下执行或作为 VS 模式的来宾执行。

在 HS 模式下，操作系统或虚拟机通过与操作系统在 S 模式下相同的 SBI 与机器交互。 在 HS 模式下，预期虚拟机会为其 VS 模式的来宾实现 SBI。

虚拟机扩展依赖于具有 32 个 `x` 寄存器的 "I" 基整数 ISA（RV32I 或 RV64I），而不是只有 16 个 `x` 寄存器的 RV32E 或 RV64E。 CSR `mtval` 不应为只读零，并且必须支持标准的基于页面的地址转换，对于 RV32 是 Sv32，对于 RV64 至少是 Sv39。

通过在 `misa` CSR 中设置位 7 来启用虚拟机扩展，该位对应于字母 H。实施虚拟机扩展的 RISC-V hart 鼓励不要将 `misa`[7] 固接，这样可以禁用扩展。

[NOTE]
====
基础特权架构设计旨在简化经典虚拟化技术的使用，其中来宾操作系统在用户级别运行，因少数特权指令可以很容易地被检测并捕获。 虚拟机扩展通过减少这些捕获的频率来提高虚拟化性能。

虚拟机扩展被设计为能够在未实现该扩展的平台上高效地仿真，通过在 S 模式下运行虚拟机并捕获到 M 模式进行虚拟机 CSR 访问和维护影子页表。 对于类型-2 虚拟机的大部分 CSR 访问是有效的 S 模式访问，因此无需被捕获。
虚拟机可以类似地支持嵌套虚拟化。
====

=== 特权模式

当前_虚拟化模式_，用 V 表示，表示hart 当前是否在来宾中执行。 当 V=1 时，hart 要么在虚拟 S 模式（VS 模式），要么在来宾操作系统顶层运行的 VS 模式中的虚拟 U 模式（VU 模式）。 当 V=0 时，hart 要么处于 M 模式，要么处于 HS 模式，要么在 HS 模式中运行的操作系统顶层的 U 模式。 虚拟化模式还表明双重地址转换是启用（V=1）还是停用（V=0）。 <<HPrivModes>>列出了带虚拟机扩展的 RISC-V hart 的可能特权模式。

<<<

[[HPrivModes]]
.带虚拟机扩展的特权模式。
[float="center", align="center", cols="~,~,~,~,~"]
|===
^|虚拟化 + 模式 (V)
|名义特权 |缩写 |名称 |双重翻译

^|0 + 0 + 0
|U + S + M
|U 模式 + HS 模式 + M 模式
|用户模式 + 虚拟机扩展监督模式 + 机器模式
|关闭 + 关闭 + 关闭

^|1 + 1
|U + S
|VU 模式 + VS 模式
|虚拟用户模式 + 虚拟监督模式
|开启 + 开启
|===

对于特权模式 U 和 VU，_名义特权模式_ 是 U，而对于特权模式 HS 和 VS，名义特权模式是 S。

HS 模式比 VS 模式更高级，而 VS 模式比 VU 模式更高级。 VS 模式中断在 U 模式执行时会全局禁用。

[NOTE]
====
该描述未考虑 U 模式或 VU 模式中断的可能性，如果采用用户级别中断的扩展，将进行修订。
====

=== 虚拟机和虚拟监督 CSR

在 HS 模式下运行的操作系统或虚拟机使用监督 CSR 与异常、中断和地址翻译子系统交互。 HS 模式提供了额外的 CSR，但不提供给 VS 模式，以管理两级地址翻译并控制 VS 模式来宾的行为：`hstatus`、`hedeleg`、`hideleg`、`hvip`、`hip`、`hie`、`hgeip`、`hgeie`、`henvcfg`、`henvcfgh`、`hcounteren`、`htimedelta`、`htimedeltah`、`htval`、`htinst` 和 `hgatp`。

此外，多个_虚拟监督_ CSR（VS CSR）是普通监督 CSR 的复制品。 例如，`vsstatus` 是 VS CSR，用于复制常规的 `sstatus` CSR。

当 V=1 时，VS CSR 代替对应的监督 CSR，除了特别规定外，承担所有的正常监督 CSR 功能。 通常读取或修改监督 CSR 的指令应改为访问对应的 VS CSR。 当 V=1 时，尝试通过其独立的 CSR 地址直接读取或写入 VS CSR 会导致虚拟指令异常。 （从 U 模式的尝试同样会导致非法指令异常。） VS CSR 只能作为自身从 M 模式或 HS 模式访问。

当 V=1 时，被 VS CSR 替换的正常 HS 级监督 CSR 保留其值，但不影响机器的行为，除非另有具体文件说明。 反之，当 V=0 时，VS CSR 通常不影响机器的行为，除了可以通过 CSR 指令读取和写入。

一些标准监督 CSR（`senvcfg`、`scounteren` 和 `scontext`，可能还有其他）没有与之匹配的 VS CSR。 这些监督 CSR 在 V=1 时继续具有其通常的功能和可访问性，但在 VS 模式和 VU 模式下替代 HS 模式和 U 模式。 预期虚拟机软件会根据需要手动交换这些寄存器的内容。

[NOTE]
====
匹配的 VS CSR 仅存在于必须复制的监督 CSR 中，主要是那些在陷入或 SRET 之前立即自动写入的 CSR，在软件无法准确时刻交换 CSR时。 目前，大多数监督 CSR 属于此类别，但未来的可能不是。
====

在本章中，我们使用术语 _HSXLEN_ 来指代在 HS 模式下执行时的有效 XLEN，使用 _VSXLEN_ 来指代在 VS 模式下执行时的有效 XLEN。

==== 虚拟机状态寄存器 (`hstatus`)

`hstatus` 寄存器是一个 HSXLEN-位读/写寄存器，当 HSXLEN=32 时，它的格式如 <<hstatusreg-rv32>> 所示，当 HSXLEN=64 时，如 <<hstatusreg>> 所示。 `hstatus` 寄存器提供了与 `mstatus` 寄存器类似的功能，用于跟踪和控制 VS 模式客人异常行为。

include::images/bytefield/hstatusreg-rv32.edn[]

include::images/bytefield/hstatusreg.edn[]

VSXL 字段控制 VS 模式（称为 VSXLEN）的有效 XLEN，可能与 HS 模式（HSXLEN）的 XLEN 不同。 当 HSXLEN=32 时，VSXL 字段不存在，并且 VSXLEN=32。 当 HSXLEN=64 时，VSXL 是 *WARL* 字段，编码与 `misa` 的 MXL 字段相同，如<<misabase>> 中第<<misabase, 19>>页所示。 特别是，实现可能使 VSXL 成为只读字段，其值始终确保 VSXLEN=HSXLEN。

如果 HSXLEN 从 32 改为更宽，且 VSXL 字段不限制为单一值，则它将获得不超过新 HSXLEN 的最宽支持宽度。

`hstatus` 字段 VTSR、VTW 和 VTVM 的定义类比于 `mstatus` 字段 TSR、TW 和 TVM，但仅影响 VS 模式执行，并导致虚拟指令异常而不是非法指令异常。 当 VTSR=1 时，在 VS 模式下尝试执行 SRET 将引发虚拟指令异常。 当 VTW=1 时（并假设 `mstatus`.TW=0），在 VS 模式下执行 WFI 的尝试会引发虚拟指令异常，如果 WFI 未在实现特定的、有界时间限制内完成。 实现中可能设置 VTW=1 时（且 `mstatus`.TW=0），在 VS 模式下执行 WFI 时，即使在执行指令时存在全局禁用的挂起中断，也会始终引发虚拟指令异常。 当 VTVM=1 时，尝试在 VS 模式下执行 SFENCE.VMA 或 SINVAL.VMA 或访问 CSR `satp` 将引发虚拟指令异常。

VGEIN（虚拟来宾外部中断号）字段选择 VS 级外部中断的来宾外部中断源。 VGEIN 是一个 *WLRL* 字段，必须能够持有值在零和最大来宾外部中断号（称为 GEILEN）之间，含最大值。
当 VGEIN=0 时，未为 VS 级外部中断选择来宾外部中断源。 GEILEN 可能为零，此时 VGEIN 可能是只读零。 来宾外部中断在 <<hgeinterruptregs>> 中进行了解释，VGEIN 的使用在 <<hinterruptregs>> 进一步介绍。

字段 HU（U 模式下的虚拟机）控制虚拟机负载/存储指令 HLV、HLVX 和 HSV 是否也可以在 U 模式中使用。
当 HU=1 时，这些指令可以在 U 模式中像 HS 模式一样执行。 当 HU=0 时，所有虚拟机指令在 U 模式中引发非法指令异常。

[NOTE]
====
HU 位允许在 U 模式下运行部分虚拟机以增强对软件错误的保护，同时仍然保留对虚拟机内存的访问。
====

SPV 位（监督员先前虚拟化模式）由实现写入，当陷入 HS 模式时。 正如 `sstatus` 中的 SPP 位设置为陷入时的（名义）特权模式一样，`hstatus` 中的 SPV 位设置为陷入时的虚拟化模式 V 的值。 当在 V=0 的情况下执行 SRET 指令时，V 设置为 SPV。

当 V=1 并陷入 HS 模式时，SPVP 位（监督员先前虚拟特权）设置为陷入时的名义特权模式，与 `sstatus`.SPP 相同。 但如果陷入前 V=0，SPVP 位在陷入时保持不变。 SPVP 控制虚拟机负载/存储指令 HLV、HLVX 和 HSV 的显式内存访问的有效特权。

[NOTE]
====
如果没有 SPVP，如果指令 HLV、HLVX 和 HSV 改为查看`sstatus`.SPP 来确定其内存访问的有效特权，即使 HU=1，U 模式也无法在 VS 级访问虚拟机内存，因为使用 SRET 进入 U 模式总是使 SPP=0。 与 SPP 不同，SPVP 字段不会因在 HS 模式和 U 模式之间来回切换而改变。
====

GVA（来宾虚拟地址）字段由实现写入，当陷入 HS 模式时。 对于任意陷阱（如断点、地址未对齐、访问故障、页故障或来宾页故障）写入来宾虚拟地址到 `stval`，GVA 被设置为 1。 对于其他陷阱进入 HS 模式，GVA 被设置为 0。

[NOTE]
====
对于将非零值写入 `stval` 的断点和内存访问陷阱，GVA 与 SPV 字段冗余（两位设置相同），除非 HLV、HLVX 或 HSV 指令的显式内存访问引发故障。 在这种情况下，SPV=0 但 GVA=1。
====

VSBE 位是一个 *WARL* 字段，控制从 VS 模式进行的显式内存访问的字节序。 如果 VSBE=0，从 VS 模式进行的显式加载和存储内存访问是小端序，如果 VSBE=1，则是大端序。 VSBE 还控制对 VS 级内存管理数据结构（如页表）的所有隐式访问的字节序。 实现可能将 VSBE 设置为只读字段，总是指定与 HS 模式相同的字节序。

==== 虚拟机陷阱委派寄存器（`hedeleg` 和 `hideleg`）

寄存器 `hedeleg` 是一个 64 位的读/写寄存器，如 <<hedelegreg>> 所示。
寄存器 `hideleg` 是一个 HSXLEN 比特的读/写寄存器，如 <<hidelegreg>> 所示。
默认情况下，任何特权级别的所有陷阱都在 M 模式下处理，尽管 M 模式通常使用 `medeleg` 和 `mideleg` CSR 将一些陷阱委托给 HS 模式。 `hedeleg` 和 `hideleg` CSR 允许这些陷阱进一步委托给 VS 模式来宾；它们的布局与 `medeleg` 和 `mideleg` 相同。

include::images/bytefield/hedelegreg.edn[]

include::images/bytefield/hidelegreg.edn[]

同步陷阱已被委托至 HS 模式（使用 `medeleg`），若在陷阱前置 V=1 并设置对应的 `hedeleg` 位，则进一步委托至 VS 模式。 `hedeleg` 的每个位应当是可写的或只读为零。 许多`hedeleg` 的位特别要求是可写的或零，如 <<hedeleg-bits>> 中所列举。 位 0 对应于指令地址未对齐异常，若 IALIGN=32，则必须可写。

[NOTE]
====
要求 `hedeleg` 的某些位必须是可写的，以减少虚拟机处理实现变体的负担。
====

当 XLEN=32 时，`hedelegh` 是一个 32 位的读/写寄存器，别名为 `hedeleg` 的 63:32 位。
XLEN=64 时不存在寄存器 `hedelegh`。

委托至 HS 模式（使用 `mideleg`）的中断，如果设置了对应的 `hideleg` 位，则进一步委托至 VS 模式。
`hideleg` 的位 15:0 中，第 10、6、2 位（对应标准 VS 级中断）是可写的，第 12、9、5、1 位（对应标准 S 级中断）是只读为零。

当虚拟监督外部中断（代码 10）被委派至 VS 模式时，机器会自动将其转换为 VS 模式的监督外部中断（代码 9），包括在中断陷阱中写入 `vscause` 的值。 同样，虚拟监督计时器中断（6）被转换为 VS 模式的监督计时器中断（5），虚拟监督软件中断（2）被转换为 VS 模式的监督软件中断（1）。 对于平台中断原因（代码 16 及以上），相似的转换可能会或可能不会完成。

[[hedeleg-bits]]
.`hedeleg` 的必须是可写的或必须是只读为零的位。
[%autowidth, float="center", align="center", cols=">,<,<", options="header"]
|===
|位 |属性 |对应异常

|0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 15 + 18 + 19 + 20 + 21 + 22 + 23
|（见文本） + 可写 + 可写 + 可写 + 可写 + 可写 + 可写 + 可写 + 可写 + 只读为 0 + 只读为 0 + 只读为 0 + 可写 + 可写 + 可写 + 可写 + 可写 + 只读为 0 + 只读为 0 + 只读为 0 + 只读为 0
|指令地址未对齐 + 指令访问故障 + 非法指令 + 断点 + 负载地址未对齐 + 负载访问故障 + 存储/AMO 地址未对齐 + 存储/AMO 访问故障 + 来自 U 模式或 VU 模式的环境调用 + 来自 HS 模式的环境调用 + 来自 VS 模式的环境调用 + 来自 M 模式的环境调用 + 指令页故障 + 加载页故障 + 存储/AMO 页故障 + 软件检查 + 硬件错误 + 指令来宾页故障 + 负载来宾页故障 + 虚拟指令 + 存储/AMO 来宾页故障
|===

[[hinterruptregs]]
==== 虚拟机中断寄存器（`hvip`、`hip` 和 `hie`）

寄存器 `hvip` 是一个 HSXLEN 比特的读/写寄存器，虚拟机可写入以指示用于 VS 模式的虚拟中断。 `hvip` 中不可写的位为只读零。

include::images/bytefield/hvipreg.edn[]

`hvip` 的标准部分（位 15:0）格式如 <<hvipreg-standard>> 所示。 `hvip` 的 VSEIP、VSTIP 和 VSSIP 位是可写的。 在 `hvip` 中设置 VSEIP=1 激活 VS 级外部中断；设置 VSTIP 激活 VS 级计时器中断；设置 VSSIP 激活 VS 级软件中断。

include::images/bytefield/hvipreg-standard.edn[]

寄存器 `hip` 和 `hie` 是 HSXLEN 比特的读/写寄存器，分别补充 HS 级别的 `sip` 和 `sie`。 `hip` 寄存器指示挂起的 VS 级和虚拟机特定中断，而 `hie` 包含相同中断的使能位。

include::images/bytefield/hipreg.edn[]

include::images/bytefield/hiereg.edn[]

对于 `sie` 中的每个位，对应位在 `hip` 和 `hie` 中应为只读零。 因此，`sie` 和 `hie` 中的非零位始终互斥，`sip` 和 `hip` 亦然。

[NOTE]
====
`hip` 和 `hie` 的活动位不能放至 HS 级的 `sip` 和 `sie`，否则将使得软件在未在硬件上实现该扩展的平台无法仿真虚拟机扩展。
====

中断 i 将陷入 HS 模式，当满足以下所有条件时：（a）当前操作模式为 HS 模式且 `sstatus` 寄存器中的 SIE 位被设置，或当前操作模式的特权低于 HS 模式；（b）位 i 在 `sip` 和 `sie` 或 `hip` 和 `hie` 中均被设置；（c）位 i 未在 `hideleg` 中被设置。

如果 `sie` 中的位 i 是只读零，则寄存器 `hip` 中的相同位可能是可写的，也可能是只读的。 当 `hip` 中的位 i 是可写的时，可以通过将该位写 0 来清除挂起的中断 i。 如果中断 i 可以在 `hip` 中变为挂起状态但 `hip` 中的位 i 是只读的，则可以通过清除 `hvip` 中的位 i 来清除中断，或实现必须提供其他机制来清除挂起的中断（可能涉及环境执行的调用）。

若相应中断可以在 `hip` 中变为挂起状态，则 `hie` 中的位应为可写的。 `hie` 中不可写的位应为只读零。

寄存器 `hip` 和 `hie` 的标准部分（位 15:0）格式如 <<hipreg-standard>> 和 <<hiereg-standard>> 所示。

include::images/bytefield/hipreg-standard.edn[]

include::images/bytefield/hiereg-standard.edn[]

`hip`.SGEIP 和 `hie`.SGEIE 位是用于监督级（HS 级）来宾外部中断的中断挂起和使能位。 SGEIP 在 `hip` 中是只读的，仅当 CSR `hgeip` 和 `hgeie` 的按位与操作有任何位非零时才为 1。
（见 <<hgeinterruptregs>>。）

`hip`.VSEIP 和 `hie`.VSEIE 位是用于 VS 级外部中断的中断挂起和使能位。 VSEIP 在 `hip` 中是只读的，是以下中断源的逻辑或：

* `hvip` 中的 VSEIP 位；
* 由 `hstatus`.VGEIN 选择的 `hgeip` 位；以及
* 任何其他平台特定的对 VS 级的外部中断信号。

`hip`.VSTIP 和 `hie`.VSTIE 位是用于 VS 级计时器中断的中断挂起和使能位。 VSTIP 在 `hip` 中是只读的，是 `hvip`.VSTIP 和任何其他平台特定的对 VS 级计时器中断信号的逻辑或。

`hip`.VSSIP 和 `hie`.VSSIE 位是用于 VS 级软件中断的中断挂起和使能位。 `hip` 中的 VSSIP 是 `hvip` 中相同位的别名（可写）。

多个同时面向 HS 模式的中断按照以下优先级顺序降序处理：SEI、SSI、STI、SGEI、VSEI、VSSI、VSTI。

[[hgeinterruptregs]]
==== 虚拟机来宾外部中断寄存器（`hgeip` 和 `hgeie`）

`hgeip` 寄存器是一个 HSXLEN 比特的只读寄存器，如 <<hgeipreg>> 所示，指示此 hart 的来宾外部中断挂起情况。 `hgeie`寄存器是一个HSXLEN位的读/写寄存器，如<<hgeiereg>>所示格式，包含了该hart的客体外部中断的使能位。 客体外部中断编号
_i_ 与 `hgeip` 和 `hgeie` 中的第 _i_ 位相对应。

include::images/bytefield/hgeipreg.edn[]

include::images/bytefield/hgeiereg.edn[]

客体外部中断表示指向单个虚拟机在VS级别的中断。 如果一个 RISC-V 平台支持将物理设备置于访客操作系统的直接控制下，极少有超级管理程序的干预（称为虚拟机与物理设备之间的 _直通_ 或 _直接分配_），那么，在这种情况下，设备的中断专用于特定虚拟机。 `hgeip`的每个位汇总了所有指向某个虚拟hart的挂起中断，这些中断由中断控制器收集并报告。 为了区分来自多个设备的特定挂起中断，软件必须查询中断控制器。

[NOTE]
====
支持客体外部中断需要一个能够将虚拟机导向的中断与其他中断分开收集的中断控制器。
====

`hgeip`和`hgeie`中为客体外部中断实现的位数未指定且可能为零。 该数值称为_GEILEN_。 此外，最低有效位首先实现，除了第0位。 因此，如果GEILEN不为零，那么GEILEN:1位在`hgeie`中应可写，`hgeip`和`hgeie`中的所有其他位位置应为只读零。

[NOTE]
====
在一个物理hart上接收和处理的一组客体外部中断可能与其他hart所接收的有所不同。 一个物理hart上的客体外部中断编号_i_通常预计与其他hart上的客体外部中断_i_不相同。
对于任何一个物理hart，直接接收客体外部中断的最大虚拟hart数由GEILEN限制。 对于任何实现，这个最大数值是 RV32 为 31，RV64 为 63，每个物理 hart。

超级管理程序总是可以自由模拟任何数量的虚拟hart的设备，而不受GEILEN的限制。 只有中断的直接传递（直接分配）受到GEILEN限制的影响，该限制针对于接收此类中断的虚拟hart数量，而不是接收到的独特中断数量。 单个虚拟hart可以接收的不同中断数量由中断控制器确定。
====

`hgeie`寄存器选择引发主管级（HS级）客体外部中断的客体外部中断子集。 `hgeie`中的使能位不影响由`hstatus`.VGEIN从`hgeip`选择的VS级别外部中断信号。

[[sec:henvcfg]]
==== 超级管理程序环境配置寄存器（`henvcfg`）

`henvcfg` CSR是一个64位读/写寄存器，如<<henvcfg>>中所示格式，在虚拟化模式V=1时控制执行环境的某些特性。

include::images/bytefield/henvcfg.edn[]

如果 `henvcfg` 中的 FIOM 位（I/O 的 Fence 暗示内存）被置为 1，当 V=1 时执行的 FENCE 指令会被修改，以便顺序访问设备 I/O 的要求也暗示顺序访问主内存的要求。 <<henvcfg-FIOM>>详细说明了在FIOM=1且V=1时修改后的FENCE指令位PI、PO、SI和SO的解释。

同样，当FIOM=1且V=1时，如果访问设备I/O有序区域的原子指令的_aq_和/或_rl_位被置位，那么该指令会被排序为访问设备I/O和内存。

[[henvcfg-FIOM]]
.在FIOM=1且虚拟化模式V=1下，修改后的FENCE前驱和后继集的解释。
[%autowidth, float="center", align="center", cols="^,<", options="header"]
|===
|指令位 |设置时的意思

|PI +
PO
|前驱设备输入和内存读取（PR暗示）+
前驱设备输出和内存写入（PW暗示）

|SI +
SO
|后继设备输入和内存读取（SR暗示）+
后继设备输出和内存写入（SW暗示）
|===

PBMTE位控制Svpbmt扩展是否可以用于VS阶段的地址翻译。 当PBMTE=1时，Svpbmt可用于VS阶段地址翻译。 当PBMTE=0时，实现行为如同Svpbmt未为VS阶段地址翻译实现。
如果Svpbmt未实现，则PBMTE为只读零。

如果Svadu扩展被实现，ADUE位控制VS阶段地址翻译中PTE A/D位的硬件更新是否启用。
当ADUE=1时，VS阶段地址翻译期间PTE A/D位的硬件更新被启用，且实现行为如同Svade扩展未为VS模式地址翻译实现。
当ADUE=0时，实现行为如同Svade为VS阶段地址翻译实现。
如果Svadu未实现，则ADUE为只读零。

STCE字段的定义将由即将到来的Sstc扩展提供。 它在`henvcfg`中的分配可能会在

CBZE字段的定义将由即将到来的Zicboz扩展提供。 在该扩展批准之前，它在`henvcfg`中的分配可能会更改。

CBCFE和CBIE字段的定义将由即将到来的Zicbom扩展提供。 在该扩展批准之前，它们在`henvcfg`中的分配可能会更改。

PMM字段的定义将由即将到来的Ssnpm扩展提供。 在该扩展批准之前，它在`henvcfg`中的分配可能会改变。

当XLEN=32时，`henvcfgh`是一个32位的读/写寄存器，别名为`henvcfg`的位63:32。 当XLEN=64时，寄存器`henvcfgh`不存在。

==== 超级管理程序计数器使能寄存器（`hcounteren`）

计数器使能寄存器`hcounteren`是一个32位寄存器，控制访客虚拟机对硬件性能监控计数器的可用性。

include::images/bytefield/hcounterenreg.edn[]

当`hcounteren`寄存器中的CY、TM、IR或HPM_n_位被清除时，尝试在V=1条件下读取`cycle`、`time`、`instret`或`hpmcounter` _n_ 寄存器将导致虚拟指令异常，如果`mcounteren`中的同一位为1。 当这些位之一被设置时，除非因其他原因被阻止，否则在V=1时允许访问相应的寄存器。 在VU模式下，除非在`hcounteren`和`scounteren`中设置了适用位，否则计数器不可读。

`hcounteren`必须被实现。 然而，任何位可以是只读零，表明V=1时对相应计数器的读取将导致异常。 因此，它们实际上是*WARL*字段。

==== 超级管理程序时间差寄存器（`htimedelta`）

`htimedelta` CSR是一个64位读/写寄存器，包含`time` CSR的值与VS模式或VU模式返回的值之间的差值。 也就是说，在VS或VU模式下读取`time` CSR返回`htimedelta`内容与`time`实际值之和。

[NOTE]
====
因为在对`htimedelta`和`time`求和时忽略了溢出，可以使用大值的`htimedelta`来表示负时间偏移。
====

include::images/bytefield/htimedelta.edn[]

当XLEN=32时，`htimedeltah`是一个32位读/写寄存器，别名为`htimedelta`的位63:32。
当XLEN=64时，寄存器`htimedeltah`不存在。

==== 超级管理程序陷阱值寄存器（`htval`）

`htval`寄存器是一个HSXLEN位读/写寄存器，格式如<<htvalreg>>中所示。 当陷阱进入HS模式时，`htval`被写入带有附加的异常特定信息，与`stval`一起，以协助软件处理陷阱。

include::images/bytefield/htvalreg.edn[]

当访客页面故障陷阱进入 HS 模式时，`htval` 被写入为零或导致故障的访客物理地址右移 2 位。 对于其他陷阱，`htval`被设置为零，但未来的标准或扩展可能会重新定义`htval`在其他陷阱中的设置。

由于在第一阶段（VS阶段）地址翻译期间隐含的内存访问可能导致客体页面故障，在这种情况下写入`htval`的访客物理地址是隐含内存访问导致故障的地址，例如无法读取的VS级页面表项的地址。 （当VS阶段翻译未能完成时，原始虚拟地址对应的访客物理地址未知。） 附加信息在CSR `htinst`中提供，用于区分此类情况。

否则，对于因不对齐的加载和存储而导致的客体页面故障，`htval`中的非零客体物理地址对应于由`stval`中的虚拟地址指示的访问出错部分。
对于具有可变长度指令的系统上的指令客体页面故障，`htval`中的非零值对应于由`stval`中的虚拟地址指示的指令错误部分。

[NOTE]
====
写入到 `htval` 的客体物理地址右移 2 位，以适应比当前 XLEN 更宽的地址。 对于 RV32，超级管理扩展允许客体物理地址宽至 34 位，而 `htval` 报告地址的位 33:2。 这种右移 2 位的顾客物理地址编码与 PMP 地址寄存器（<<pmp>>）和页表条目中的物理地址编码相匹配（<<sv32>>, <<sv39>>, <<sv48>> 和 <<sv57>>）。

如果需要故障客体物理地址的最低两位，这些位通常与`stval`中的故障虚拟地址的最低两位相同。 对于因为VS阶段地址翻译的隐含内存访问而导致的故障，最低两位则是零。 这些情况可以通过寄存器`htinst`中提供的值来区分。
====

`htval`是一个*WARL*寄存器，必须能够容纳零，并可能只能容纳其他2位移位的客体物理地址的任意子集，如果有的话。

[NOTE]
====
除非有理由认为是这样（例如平台标准），否则写入到`htval`的软件应当从`htval`中读取以确认储存的值。
====

==== 超级管理程序陷阱指令寄存器（`htinst`）

`htinst`寄存器是一个HSXLEN位的读/写寄存器，格式如<<htinstreg>>中所示。 当陷阱进入HS模式时，`htinst`被写入一个值，如果非零，它提供了有关导致陷阱的指令的信息，以协助软件处理陷阱。 可能在陷阱中写入`htinst`的值记录在<<tinst-vals>>中。

include::images/bytefield/htinstreg.edn[]

`htinst`是一个*WARL*寄存器，只需能够容纳在陷阱时实现可能自动写入它的值。

[[hgatp]]
==== 超级管理程序访客地址转换和保护寄存器（`hgatp`）

`hgatp` 寄存器是一个 HSXLEN 位的读/写寄存器，格式如 HSXLEN=32 的 <<rv32hgatp>> 和 HSXLEN=64 的 <<rv64hgatp>> 中所示，用于控制 G 阶段地址翻译和保护，这是客体虚拟地址的两阶段翻译的第二阶段（见 <<two-stage-translation>>）。 类似于CSR `satp`，该寄存器保存访客物理根页表的物理页号（PPN）；一个虚拟机标识符（VMID），方便按虚拟机进行地址转换隔离；以及MODE字段，选择访客物理地址的地址转换方案。 当`mstatus`.TVM=1时，在HS模式下执行时试图读取或写入`hgatp`将引发非法指令异常。

include::images/bytefield/rv32hgatp.edn[]

include::images/bytefield/rv64hgatp.edn[]

<<hgatp-mode>>显示了当HSXLEN=32和HSXLEN=64时MODE字段的编码。 当MODE=Bare时，访客物理地址等于主管物理地址，客体虚拟机没有进一步的内存保护，超出<<pmp>>中描述的物理内存保护方案。 在这种情况下，`hgatp`中的剩余字段必须设置为零。

当 HSXLEN=32 时，MODE 的唯一其他有效设置是 Sv32x4，这是一种修改过的标准 Sv32 分页虚拟内存方案，扩展为支持 34 位的访客物理地址。 当 HSXLEN=64 时，模式 Sv39x4、Sv48x4 和 Sv57x4 被定义为 Sv39、Sv48 和 Sv57 分页虚拟内存方案的修改模式。 所有这些分页虚拟内存方案在<<guest-addr-translation>>中进行描述。

HSXLEN=64时的剩余MODE设置保留用于将来使用，并可能定义`hgatp`中其他字段的不同解释。

[[hgatp-mode]]
.`hgatp` MODE字段的编码。
[%autowidth, float="center", align="center", cols="^,^,<", options="header"]
|===
3+|HSXLEN=32

|值 |名称 |描述

|0 +
1
|裸露 +
Sv32x4
|无翻译或保护。 +
基于页面的 34 位虚拟寻址（Sv32 的 2 位扩展）。

3+s|HSXLEN=64

|值 |名称 |描述

|0 +
1-7 +
8 +
9 +
10 +
11-15
|裸露 +
— +
Sv39x4 +
Sv48x4 +
Sv57x4 +
—
|无翻译或保护。 +
保留 +
基于页面的 41 位虚拟寻址（Sv39 的 2 位扩展）。 +
基于页面的 50 位虚拟寻址（Sv48 的 2 位扩展）。 +
基于页面的 59 位虚拟寻址（Sv57 的 2 位扩展）。 +
保留
|===

实施并不要求支持所有已定义的MODE设置当HSXLEN=64。

对使用不支持的MODE值的`hgatp`写入不会像`satp`那样被忽略。 相反，当指示时`hgatp`的字段以常规方式成为*WARL*。

如 <<guest-addr-translation>> 中解释的，对于分页虚拟内存方案（Sv32x4、Sv39x4、Sv48x4 和 Sv57x4），根目录页面表为 16 KiB，必须对齐到 16-KiB 边界。 在这些模式中，`hgatp`中的物理页号（PPN）的最低两位总是读取为零。 支持只有定义的分页虚拟内存方案和/或裸露的实现可以使PPN[1:0]为只读零。

VMID位数未指定且可能为零。 实现的 VMID 位数，称为 _VMIDLEN_，可以通过在 VMID 字段中的每个位位置上写入 1，然后读取 `hgatp` 中的值来确定，看看 VMID 字段中的哪些位位置保存为 1。 VMID的最低有效位先实现：即如果VMIDLEN>0，VMID[VMIDLEN-1:0]是可写的。 VMIDLEN 的最大值，称为 VMIDMAX，对于 Sv32x4 为 7，对于 Sv39x4、Sv48x4 和 Sv57x4 为 14。

对于地址翻译算法的目的，除非有效特权模式是U且`hstatus`.HU=0，否则`hgatp`寄存器被视为_活动_。

[NOTE]
====
这个定义简化了对HLV、HLVX和HSV指令的推测执行的实现。
====

注意写入`hgatp`并不意味着页面表更新与随后的G阶段地址翻译之间存在任何排序约束。
如果新的虚拟机的访客物理页表已被修改，或如果VMID被重用，可能需要在写入`hgatp`之前或之后执行HFENCE.GVMA指令（见<<hfence.vma>>）。

==== 虚拟主管状态寄存器（`vsstatus`）

`vsstatus` 寄存器是一个 VSXLEN 位的读/写寄存器，是 VS 模式下主管寄存器 `sstatus` 的版本，当 VSXLEN=32 时格式如 <<vsstatusreg-rv32>> 中所示，当 VSXLEN=64 时如 <<vsstatusreg>> 中所示。 当V=1时，`vsstatus`取代标准的`sstatus`，因此正常读取或修饰`sstatus`的指令实际上访问的是`vsstatus`。

include::images/bytefield/vsstatusreg-rv32.edn[]

include::images/bytefield/vsstatusreg.edn[]

UXL字段控制VU模式的有效XLEN，这可能与VS模式（VSXLEN）的XLEN不同。 当VSXLEN=32时，UXL字段不存在，VU模式XLEN=32。 当 VSXLEN=64 时，UXL 是一个 *WARL* 字段，编码与 `misa` 的 MXL 字段相同，显示在 <<misabase>> 中。 特别地，实现可以使UXL成为`hstatus`中VSXL字段的只读副本，强制VU模式XLEN=VSXLEN。

如果VSXLEN从32更改为更宽的宽度，并且如果UXL字段未限于单值，则它获得不超过新的VSXLEN的支持最宽宽度对应的值。

当V=1时，`vsstatus`.FS和HS级别的`sstatus`.FS均在生效。 尝试执行浮点指令当任一个字段为0（关）时，引发非法指令异常。 当V=1时修改浮点状态会导致两个字段都被设为3（脏）。

[NOTE]
====
为了使超级管理程序从扩展上下文状态中受益，它必须在HS级别的`sstatus`中拥有自己的副本，独立于在VS模式下运行访客操作系统。 虽然VS模式显然必须在`vsstatus`中存在扩展上下文的版本，但由于VS级软件可以随意更改`vsstatus`.FS，因此超级管理程序不能依靠此版本正确维护。 如果HS级别的`sstatus`.FS在V=1时不得不是独立活跃和由硬件维护与`vsstatus`.FS并行进行，则在虚拟机间进行上下文切换时，超级管理程序将被迫谨慎地交换所有浮点状态。
====

同样，当V=1时，`vsstatus`.VS和HS级别的`sstatus`.VS也生效。 当任一字段为0（关）时，尝试执行向量指令引发非法指令异常。 当V=1时修改向量状态会导致两个字段设为3（脏）。

只读字段SD和XS总结了扩展上下文状态，因为它只对VS模式可见。 例如，HS级别的`sstatus`.FS的值不影响`vsstatus`.SD。

实现可以使UBE字段成为`hstatus`.VSBE的只读副本。

当V=0时，除非使用虚拟机加载/存储（HLV、HLVX或HSV）或`mstatus`寄存器中的MPRV特性作为虽然V=1来执行加载或存储，否则`vsstatus`不会直接影响机器行为。

==== 虚拟主管中断寄存器（`vsip`和`vsie`）

`vsip`和`vsie`寄存器是VSXLEN位的读/写寄存器，是VS模式下主管CSR`sip`和`sie`的版本，格式如<<vsipreg>>和<<vsiereg>>中所示。 当V=1时，`vsip`和`vsie`取代正常的`sip`和`sie`，因此正常读取或修饰`sip`/`sie`的指令实际上访问的是`vsip`/`vsie`。 然而，定向到HS级的中断仍会在HS级的`sip`寄存器中指示，而不是在`vsip`中，当V=1。

include::images/bytefield/vsipreg.edn[]

include::images/bytefield/vsiereg.edn[]

寄存器`vsip`和`vsie`的标准部分（位15:0）格式如<<vsipreg-standard>>和<<vsiereg-standard>>所示。

include::images/bytefield/vsipreg-standard.edn[]

include::images/bytefield/vsiereg-standard.edn[]

当`hideleg`的第13位为零时，`vsip`.LCOFIP和`vsie`.LCOFIE为只读零。
否则，`vsip`.LCOFIP和`vsie`.LCOFIE是`sip`.LCOFIP和`sie`.LCOFIE的别名。

NOTE: The `vsip`.LCOFIP and `vsie`.LCOFIE bits were added in Version 1.13 of
the Privileged Architecture.

When bit 10 of `hideleg` is zero, `vsip`.SEIP and `vsie`.SEIE are
read-only zeros. Else, `vsip`.SEIP and `vsie`.SEIE are aliases of
`hip`.VSEIP and `hie`.VSEIE.

When bit 6 of `hideleg` is zero, `vsip`.STIP and `vsie`.STIE are
read-only zeros. Else, `vsip`.STIP and `vsie`.STIE are aliases of
`hip`.VSTIP and `hie`.VSTIE.

When bit 2 of `hideleg` is zero, `vsip`.SSIP and `vsie`.SSIE are
read-only zeros. Else, `vsip`.SSIP and `vsie`.SSIE are aliases of
`hip`.VSSIP and `hie`.VSSIE.

==== Virtual Supervisor Trap Vector Base Address Register (`vstvec`)

The `vstvec` register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register `stvec`, formatted as shown in
<<vstvecreg>>. When V=1, `vstvec` substitutes for
the usual `stvec`, so instructions that normally read or modify `stvec`
actually access `vstvec` instead. When V=0, `vstvec` does not directly
affect the behavior of the machine.

include::images/bytefield/vstvecreg.edn[]

==== Virtual Supervisor Scratch Register (`vsscratch`)

The `vsscratch` register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register `sscratch`, formatted as shown
in <<vsscratchreg>>. When V=1, `vsscratch`
substitutes for the usual `sscratch`, so instructions that normally read
or modify `sscratch` actually access `vsscratch` instead. The contents
of `vsscratch` never directly affect the behavior of the machine.

include::images/bytefield/vsscratchreg.edn[]

==== Virtual Supervisor Exception Program Counter (`vsepc`)

The `vsepc` register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register `sepc`, formatted as shown in
<<vsepcreg>>. When V=1, `vsepc` substitutes for the
usual `sepc`, so instructions that normally read or modify `sepc`
actually access `vsepc` instead. When V=0, `vsepc` does not directly
affect the behavior of the machine.

`vsepc` is a *WARL* register that must be able to hold the same set of values
that `sepc` can hold.

include::images/bytefield/vsepcreg.edn[]

==== Virtual Supervisor Cause Register (`vscause`)

The `vscause` register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register `scause`, formatted as shown in
<<vscausereg>>. When V=1, `vscause` substitutes
for the usual `scause`, so instructions that normally read or modify
`scause` actually access `vscause` instead. When V=0, `vscause` does not
directly affect the behavior of the machine.

`vscause` is a *WLRL* register that must be able to hold the same set of
values that `scause` can hold.

include::images/bytefield/vscausereg.edn[]

==== Virtual Supervisor Trap Value Register (`vstval`)

The `vstval` register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register `stval`, formatted as shown in
<<vstvalreg>>. When V=1, `vstval` substitutes for
the usual `stval`, so instructions that normally read or modify `stval`
actually access `vstval` instead. When V=0, `vstval` does not directly
affect the behavior of the machine.

`vstval` is a *WARL* register that must be able to hold the same set of values
that `stval` can hold.

include::images/bytefield/vstvalreg.edn[]

==== Virtual Supervisor Address Translation and Protection Register (`vsatp`)

The `vsatp` register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register `satp`, formatted as shown in
<<rv32vsatpreg>> for VSXLEN=32 and <<rv64vsatpreg>> for VSXLEN=64. When V=1,
`vsatp` substitutes for the usual `satp`, so instructions that normally
read or modify `satp` actually access `vsatp` instead. `vsatp` controls
VS-stage address translation, the first stage of two-stage translation
for guest virtual addresses (see
<<two-stage-translation>>).

include::images/bytefield/rv32vsatpreg.edn[]

include::images/bytefield/rv64vsatpreg.edn[]

The `vsatp` register is considered _active_ for the purposes of the
address-translation algorithm _unless_ the effective privilege mode is U
and `hstatus`.HU=0. However, even when `vsatp` is active, VS-stage
page-table entries’ A bits must not be set as a result of speculative
execution, unless the effective privilege mode is VS or VU.

[NOTE]
====
In particular, virtual-machine load/store (HLV, HLVX, or HSV)
instructions that are misspeculatively executed must not cause VS-stage
A bits to be set.
====

When V=0, a write to `vsatp` with an unsupported MODE value is either
ignored as it is for `satp`, or the fields of `vsatp` are treated as *WARL* in
the normal way. However, when V=1, a write to `satp` with an unsupported
MODE value _is_ ignored and no write to `vsatp` is effected.

When V=0, `vsatp` does not directly affect the behavior of the machine,
unless a virtual-machine load/store (HLV, HLVX, or HSV) or the MPRV
feature in the `mstatus` register is used to execute a load or store _as
though_ V=1.

=== Hypervisor Instructions

The hypervisor extension adds virtual-machine load and store
instructions and two privileged fence instructions.

==== Hypervisor Virtual-Machine Load and Store Instructions

include::images/wavedrom/hypv-virt-load-and-store.edn[]

The hypervisor virtual-machine load and store instructions are valid
only in M-mode or HS-mode, or in U-mode when `hstatus`.HU=1. Each
instruction performs an explicit memory access as though V=1; i.e., with
the address translation and protection, and the endianness, that apply
to memory accesses in either VS-mode or VU-mode. Field SPVP of `hstatus`
controls the privilege level of the access. The explicit memory access
is done as though in VU-mode when SPVP=0, and as though in VS-mode when
SPVP=1. As usual when V=1, two-stage address translation is applied, and
the HS-level `sstatus`.SUM is ignored. HS-level `sstatus`.MXR makes
execute-only pages readable for both stages of address translation
(VS-stage and G-stage), whereas `vsstatus`.MXR affects only the first
translation stage (VS-stage).

For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
and LD, there is a corresponding virtual-machine load instruction:
HLV.B, HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I
or RV64I store instruction, SB, SH, SW, and SD, there is a corresponding
virtual-machine store instruction: HSV.B, HSV.H, HSV.W, and HSV.D.
Instructions HLV.WU, HLV.D, and HSV.D are not valid for RV32, of course.

Instructions HLVX.HU and HLVX.WU are the same as HLV.HU and HLV.WU,
except that _execute_ permission takes the place of _read_ permission
during address translation. That is, the memory being read must be
executable in both stages of address translation, but read permission is
not required. For the supervisor physical address that results from
address translation, the supervisor physical memory attributes must
grant both _execute_ and _read_ permissions. (The _supervisor physical
memory attributes_ are the machine’s physical memory attributes as
modified by physical memory protection, <<pmp>>, for
supervisor level.)

[NOTE]
====
HLVX cannot override machine-level physical memory protection (PMP), so
attempting to read memory that PMP designates as execute-only still
results in an access-fault exception.

Although HLVX instructions’ explicit memory accesses require execute
permissions, they still raise the same exceptions as other load
instructions, rather than raising fetch exceptions instead.
====

HLVX.WU is valid for RV32, even though LWU and HLV.WU are not. (For
RV32, HLVX.WU can be considered a variant of HLV.W, as sign extension is
irrelevant for 32-bit values.)

Attempts to execute a virtual-machine load/store instruction (HLV, HLVX,
or HSV) when V=1 cause a virtual-instruction exception. Attempts to execute
one of these same instructions from U-mode when `hstatus`.HU=0 cause an
illegal-instruction exception.

[[hfence.vma]]
==== Hypervisor Memory-Management Fence Instructions

include::images/wavedrom/hypv-mm-fence.edn[]

The hypervisor memory-management fence instructions, HFENCE.VVMA and
HFENCE.GVMA, perform a function similar to SFENCE.VMA
(<<sfence.vma>>), except applying to the
VS-level memory-management data structures controlled by CSR `vsatp`
(HFENCE.VVMA) or the guest-physical memory-management data structures
controlled by CSR `hgatp` (HFENCE.GVMA). Instruction SFENCE.VMA applies
only to the memory-management data structures controlled by the current
`satp` (either the HS-level `satp` when V=0 or `vsatp` when V=1).

HFENCE.VVMA is valid only in M-mode or HS-mode. Its effect is much the
same as temporarily entering VS-mode and executing SFENCE.VMA. Executing
an HFENCE.VVMA guarantees that any previous stores already visible to
the current hart are ordered before all implicit reads by that hart done
for VS-stage address translation for instructions that

* are subsequent to the HFENCE.VVMA, and
* execute when `hgatp`.VMID has the same setting as it did when
HFENCE.VVMA executed.

Implicit reads need not be ordered when `hgatp`.VMID is different than
at the time HFENCE.VVMA executed. If operand __rs1__≠`x0`, it specifies a single guest virtual address, and if operand __rs2__≠`x0`, it specifies a single guest address-space identifier (ASID).

[NOTE]
====
An HFENCE.VVMA instruction applies only to a single virtual machine,
identified by the setting of `hgatp`.VMID when HFENCE.VVMA executes.
====

When __rs2__≠`x0`, bits XLEN-1:ASIDMAX of the value held
in _rs2_ are reserved for future standard use. Until their use is
defined by a standard extension, they should be zeroed by software and
ignored by current implementations. Furthermore, if
ASIDLEN < ASIDMAX, the implementation shall ignore bits
ASIDMAX-1:ASIDLEN of the value held in _rs2_.

[NOTE]
====
Simpler implementations of HFENCE.VVMA can ignore the guest virtual
address in _rs1_ and the guest ASID value in _rs2_, as well as
`hgatp`.VMID, and always perform a global fence for the VS-level memory
management of all virtual machines, or even a global fence for all
memory-management data structures.
====

Neither `mstatus`.TVM nor `hstatus`.VTVM causes HFENCE.VVMA to trap.

HFENCE.GVMA is valid only in HS-mode when `mstatus`.TVM=0, or in M-mode
(irrespective of `mstatus`.TVM). Executing an HFENCE.GVMA instruction
guarantees that any previous stores already visible to the current hart
are ordered before all implicit reads by that hart done for G-stage
address translation for instructions that follow the HFENCE.GVMA. If
operand __rs1__≠`x0`, it specifies a single guest
physical address, shifted right by 2 bits, and if operand
__rs2__≠`x0`, it specifies a single virtual machine
identifier (VMID).

[NOTE]
====
Conceptually, an implementation might contain two address-translation
caches: one that maps guest virtual addresses to guest physical
addresses, and another that maps guest physical addresses to supervisor
physical addresses. HFENCE.GVMA need not flush the former cache, but it
must flush entries from the latter cache that match the HFENCE.GVMA’s
address and VMID arguments.

More commonly, implementations contain address-translation caches that
map guest virtual addresses directly to supervisor physical addresses,
removing a level of indirection. For such implementations, any entry
whose guest virtual address maps to a guest physical address that
matches the HFENCE.GVMA’s address and VMID arguments must be flushed.
Selectively flushing entries in this fashion requires tagging them with
the guest physical address, which is costly, and so a common technique
is to flush all entries that match the HFENCE.GVMA’s VMID argument,
regardless of the address argument.

***

Like for a guest physical address written to `htval` on a trap, a guest
physical address specified in _rs1_ is shifted right by 2 bits to
accommodate addresses wider than the current XLEN.
====

When __rs2__≠`x0`, bits XLEN-1:VMIDMAX of the value held
in _rs2_ are reserved for future standard use. Until their use is
defined by a standard extension, they should be zeroed by software and
ignored by current implementations. Furthermore, if
VMIDLEN < VMIDMAX, the implementation shall ignore bits
VMIDMAX-1:VMIDLEN of the value held in _rs2_.

[NOTE]
====
Simpler implementations of HFENCE.GVMA can ignore the guest physical
address in _rs1_ and the VMID value in _rs2_ and always perform a global
fence for the guest-physical memory management of all virtual machines,
or even a global fence for all memory-management data structures.
====

If `hgatp`.MODE is changed for a given VMID, an HFENCE.GVMA with
_rs1_=`x0` (and _rs2_ set to either `x0` or the VMID) must be executed
to order subsequent guest translations with the MODE change—even if the
old MODE or new MODE is Bare.

Attempts to execute HFENCE.VVMA or HFENCE.GVMA when V=1 cause a
virtual-instruction exception, while attempts to do the same in U-mode cause an
illegal-instruction exception. Attempting to execute HFENCE.GVMA in HS-mode
when `mstatus`.TVM=1 also causes an illegal-instruction exception.

=== Machine-Level CSRs

The hypervisor extension augments or modifies machine CSRs `mstatus`,
`mstatush`, `mideleg`, `mip`, and `mie`, and adds CSRs `mtval2` and
`mtinst`.

==== Machine Status Registers (`mstatus` and `mstatush`)

The hypervisor extension adds two fields, MPV and GVA, to the
machine-level `mstatus` or `mstatush` CSR, and modifies the behavior of
several existing `mstatus` fields.
<<hypervisor-mstatus>> shows the modified
`mstatus` register when the hypervisor extension is implemented and
MXLEN=64. When MXLEN=32, the hypervisor extension adds MPV and GVA not
to `mstatus` but to `mstatush`.
<<hypervisor-mstatush>> shows the
`mstatush` register when the hypervisor extension is implemented and
MXLEN=32.

include::images/bytefield/hypv-mstatus.edn[]

include::images/bytefield/hypv-mstatush.edn[]

The MPV bit (Machine Previous Virtualization Mode) is written by the
implementation whenever a trap is taken into M-mode. Just as the MPP
field is set to the (nominal) privilege mode at the time of the trap,
the MPV bit is set to the value of the virtualization mode V at the time
of the trap. When an MRET instruction is executed, the virtualization
mode V is set to MPV, unless MPP=3, in which case V remains 0.

Field GVA (Guest Virtual Address) is written by the implementation
whenever a trap is taken into M-mode. For any trap (breakpoint, address
misaligned, access fault, page fault, or guest-page fault) that writes a
guest virtual address to `mtval`, GVA is set to 1. For any other trap
into M-mode, GVA is set to 0.

The TSR and TVM fields of `mstatus` affect execution only in HS-mode,
not in VS-mode. The TW field affects execution in all modes except
M-mode.

Setting TVM=1 prevents HS-mode from accessing `hgatp` or executing
HFENCE.GVMA or HINVAL.GVMA, but has no effect on accesses to `vsatp` or
instructions HFENCE.VVMA or HINVAL.VVMA.

[NOTE]
====
TVM exists in `mstatus` to allow machine-level software to modify the
address translations managed by a supervisor-level OS, usually for the
purpose of inserting another stage of address translation below that
controlled by the OS. The instruction traps enabled by TVM=1 permit
machine level to co-opt both `satp` and `hgatp` and substitute _shadow
page tables_ that merge the OS’s chosen page translations with M-level’s
lower-stage translations, all without the OS being aware. M-level
software needs this ability not only to emulate the hypervisor extension
if not already supported, but also to emulate any future RISC-V
extensions that may modify or add address translation stages, perhaps,
for example, to improve support for nested hypervisors, i.e., running
hypervisors atop other hypervisors.

However, setting TVM=1 does not cause traps for accesses to `vsatp` or
instructions HFENCE.VVMA or HINVAL.VVMA, or for any actions taken in
VS-mode, because M-level software is not expected to need to involve
itself in VS-stage address translation. For virtual machines, it should
be sufficient, and in all likelihood faster as well, to leave VS-stage
address translation alone and merge all other translation stages into
G-stage shadow page tables controlled by `hgatp`. This assumption does
place some constraints on possible future RISC-V extensions that current
machines will be able to emulate efficiently.
====

The hypervisor extension changes the behavior of the Modify Privilege
field, MPRV, of `mstatus`. When MPRV=0, translation and protection
behave as normal. When MPRV=1, explicit memory accesses are translated
and protected, and endianness is applied, as though the current
virtualization mode were set to MPV and the current nominal privilege
mode were set to MPP. <<h-mprv>> enumerates the cases.

[[h-mprv]]
.Effect of MPRV on the translation and protection of explicit memory accesses.
[float="center", align="center", cols="^15,^10,^10,<70", options="header"]
|===
|MPRV
|MPV
|MPP
|Effect

|0 |- |- |Normal access; current privilege mode applies.

|1 |0 |0 |U-level access with HS-level translation and protection only.

|1 |0 |1 |HS-level access with HS-level translation and protection only.

|1 |- |3 |M-level access with no translation.

|1 |1 |0 |VU-level access with two-stage translation and protection. The
HS-level MXR bit makes any executable page readable. `vsstatus`.MXR
makes readable those pages marked executable at the VS translation
stage, but only if readable at the guest-physical translation stage.

|1 |1 |1 |VS-level access with two-stage translation and protection. The
HS-level MXR bit makes any executable page readable. `vsstatus`.MXR
makes readable those pages marked executable at the VS translation
stage, but only if readable at the guest-physical translation stage.
`vsstatus`.SUM applies instead of the HS-level SUM bit.
|===

MPRV does not affect the virtual-machine load/store instructions, HLV,
HLVX, and HSV. The explicit loads and stores of these instructions
always act as though V=1 and the nominal privilege mode were
`hstatus`.SPVP, overriding MPRV.

The `mstatus` register is a superset of the HS-level `sstatus` register
but is not a superset of `vsstatus`.

==== Machine Interrupt Delegation Register (`mideleg`)

When the hypervisor extension is implemented, bits 10, 6, and 2 of
`mideleg` (corresponding to the standard VS-level interrupts) are each
read-only one. Furthermore, if any guest external interrupts are
implemented (GEILEN is nonzero), bit 12 of `mideleg` (corresponding to
supervisor-level guest external interrupts) is also read-only one.
VS-level interrupts and guest external interrupts are always delegated
past M-mode to HS-mode.

For bits of `mideleg` that are zero, the corresponding bits in
`hideleg`, `hip`, and `hie` are read-only zeros.

==== Machine Interrupt Registers (`mip` and `mie`)

The hypervisor extension gives registers `mip` and `mie` additional
active bits for the hypervisor-added interrupts. <<hypervisor-mipreg-standard>> and <<hypervisor-miereg-standard>> show the
standard portions (bits 15:0) of registers `mip` and `mie` when the
hypervisor extension is implemented.

include::images/bytefield/hypv-mipreg-standard.edn[]

include::images/bytefield/hypv-miereg-standard.edn[]

Bits SGEIP, VSEIP, VSTIP, and VSSIP in `mip` are aliases for the same
bits in hypervisor CSR `hip`, while SGEIE, VSEIE, VSTIE, and VSSIE in
`mie` are aliases for the same bits in `hie`.

==== Machine Second Trap Value Register (`mtval2`)

The `mtval2` register is an MXLEN-bit read/write register formatted as
shown in <<mtval2reg>>. When a trap is taken into
M-mode, `mtval2` is written with additional exception-specific
information, alongside `mtval`, to assist software in handling the trap.

include::images/bytefield/mtval2reg.edn[]

When a guest-page-fault trap is taken into M-mode, `mtval2` is written
with either zero or the guest physical address that faulted, shifted
right by 2 bits. For other traps, `mtval2` is set to zero, but a future
standard or extension may redefine `mtval2's` setting for other traps.

If a guest-page fault is due to an implicit memory access during
first-stage (VS-stage) address translation, a guest physical address
written to `mtval2` is that of the implicit memory access that faulted.
Additional information is provided in CSR `mtinst` to disambiguate such
situations.

Otherwise, for misaligned loads and stores that cause guest-page faults,
a nonzero guest physical address in `mtval2` corresponds to the faulting
portion of the access as indicated by the virtual address in `mtval`.
For instruction guest-page faults on systems with variable-length
instructions, a nonzero `mtval2` corresponds to the faulting portion of
the instruction as indicated by the virtual address in `mtval`.

`mtval2` is a *WARL* register that must be able to hold zero and may be
capable of holding only an arbitrary subset of other 2-bit-shifted guest
physical addresses, if any.

==== Machine Trap Instruction Register (`mtinst`)

The `mtinst` register is an MXLEN-bit read/write register formatted as
shown in <<mtinstreg>>. When a trap is taken into
M-mode, `mtinst` is written with a value that, if nonzero, provides
information about the instruction that trapped, to assist software in
handling the trap. The values that may be written to `mtinst` on a trap
are documented in <<tinst-vals>>.

include::images/bytefield/mtinstreg.edn[]

`mtinst` is a *WARL* register that need only be able to hold the values that
the implementation may automatically write to it on a trap.

[[two-stage-translation]]
=== Two-Stage Address Translation

Whenever the current virtualization mode V is 1, two-stage address
translation and protection is in effect. For any virtual memory access,
the original virtual address is converted in the first stage by VS-level
address translation, as controlled by the `vsatp` register, into a
_guest physical address_. The guest physical address is then converted
in the second stage by guest physical address translation, as controlled
by the `hgatp` register, into a supervisor physical address. The two
stages are known also as VS-stage and G-stage translation. Although
there is no option to disable two-stage address translation when V=1,
either stage of translation can be effectively disabled by zeroing the
corresponding `vsatp` or `hgatp` register.

The `vsstatus` field MXR, which makes execute-only pages readable, only
overrides VS-stage page protection. Setting MXR at VS-level does not
override guest-physical page protections. Setting MXR at HS-level,
however, overrides both VS-stage and G-stage execute-only permissions.

When V=1, memory accesses that would normally bypass address translation
are subject to G-stage address translation alone. This includes memory
accesses made in support of VS-stage address translation, such as reads
and writes of VS-level page tables.

Machine-level physical memory protection applies to supervisor physical
addresses and is in effect regardless of virtualization mode.

[[guest-addr-translation]]
==== Guest Physical Address Translation

The mapping of guest physical addresses to supervisor physical addresses
is controlled by CSR `hgatp` (<<hgatp>>).

When the address translation scheme selected by the MODE field of
`hgatp` is Bare, guest physical addresses are equal to supervisor
physical addresses without modification, and no memory protection
applies in the trivial translation of guest physical addresses to
supervisor physical addresses.

When `hgatp`.MODE specifies a translation scheme of Sv32x4, Sv39x4,
Sv48x4, or Sv57x4, G-stage address translation is a variation on the
usual page-based virtual address translation scheme of Sv32, Sv39, Sv48,
or Sv57, respectively. In each case, the size of the incoming address is
widened by 2 bits (to 34, 41, 50, or 59 bits). To accommodate the
2 extra bits, the root page table (only) is expanded by a factor of four
to be 16 KiB instead of the usual 4 KiB. Matching its larger size, the
root page table also must be aligned to a 16 KiB boundary instead of the
usual 4 KiB page boundary. Except as noted, all other aspects of Sv32,
Sv39, Sv48, or Sv57 are adopted unchanged for G-stage translation.
Non-root page tables and all page table entries (PTEs) have the same
formats as documented in <<sv32>>, <<sv39>>, <<sv48>>, and <<sv57>>.

For Sv32x4, an incoming guest physical address is partitioned into a
virtual page number (VPN) and page offset as shown in
<<sv32x4va>>. This partitioning is identical to
that for an Sv32 virtual address as depicted in
<<sv32va>>, except with 2 more bits at the
high end in VPN[1]. (Note that the fields of a partitioned guest
physical address also correspond one-for-one with the structure that
Sv32 assigns to a physical address, depicted in
<<sv32va>>.)

include::images/bytefield/sv32x4va.edn[]

For Sv39x4, an incoming guest physical address is partitioned as shown
in <<sv39x4va>>. This partitioning is identical to that for an Sv39 virtual address as depicted in <<sv39va>>, except with 2 more bits at the
high end in VPN[2]. Address bits 63:41 must all be zeros, or else a
guest-page-fault exception occurs.

include::images/bytefield/sv39x4va.edn[]

For Sv48x4, an incoming guest physical address is partitioned as shown
in <<sv48x4va>>. This partitioning is identical to
that for an Sv48 virtual address as depicted in
<<sv48va>>, except with 2 more bits at the
high end in VPN[3]. Address bits 63:50 must all be zeros, or else a
guest-page-fault exception occurs.

include::images/bytefield/sv48x4va.edn[]

For Sv57x4, an incoming guest physical address is partitioned as shown
in <<sv57x4va>>. This partitioning is identical to
that for an Sv57 virtual address as depicted in
<<sv57va>>, except with 2 more bits at the
high end in VPN[4]. Address bits 63:59 must all be zeros, or else a
guest-page-fault exception occurs.

include::images/bytefield/sv57x4va.edn[]

[NOTE]
====
The page-based G-stage address translation scheme for RV32, Sv32x4, is
defined to support a 34-bit guest physical address so that an RV32
hypervisor need not be limited in its ability to virtualize real 32-bit
RISC-V machines, even those with 33-bit or 34-bit physical addresses.
This may include the possibility of a machine virtualizing itself, if it
happens to use 33-bit or 34-bit physical addresses. Multiplying the size
and alignment of the root page table by a factor of four is the cheapest
way to extend Sv32 to cover a 34-bit address. The possible wastage of
12 KiB for an unnecessarily large root page table is expected to be of
negligible consequence for most (maybe all) real uses.

A consistent ability to virtualize machines having as much as four times
the physical address space as virtual address space is believed to be of
some utility also for RV64. For a machine implementing 39-bit virtual
addresses (Sv39), for example, this allows the hypervisor extension to
support up to a 41-bit guest physical address space without either
necessitating hardware support for 48-bit virtual addresses (Sv48) or
falling back to emulating the larger address space using shadow page
tables.
====

The conversion of an Sv32x4, Sv39x4, Sv48x4, or Sv57x4 guest physical
address is accomplished with the same algorithm used for Sv32, Sv39,
Sv48, or Sv57, as presented in
<<sv32algorithm>>, except that:

* `hgatp` substitutes for the usual `satp`;
* for the translation to begin, the effective privilege mode must be
VS-mode or VU-mode;
* when checking the U bit, the current privilege mode is always taken to
be U-mode; and
* guest-page-fault exceptions are raised instead of regular page-fault
exceptions.

For G-stage address translation, all memory accesses (including those
made to access data structures for VS-stage address translation) are
considered to be user-level accesses, as though executed in U-mode.
Access type permissions—readable, writable, or executable—are checked
during G-stage translation the same as for VS-stage translation. For a
memory access made to support VS-stage address translation (such as to
read/write a VS-level page table), permissions and the need to set A
and/or D bits at the G-stage level are checked as though for an implicit
load or store, not for the original access type. However, any exception
is always reported for the original access type (instruction, load, or
store/AMO).

The G bit in all G-stage PTEs is reserved for future standard use. Until
its use is defined by a standard extension, it should be cleared by
software for forward compatibility, and must be ignored by hardware.

[NOTE]
====
G-stage address translation uses the identical format for PTEs as
regular address translation, even including the U bit, due to the
possibility of sharing some (or all) page tables between G-stage
translation and regular HS-level address translation. Regardless of
whether this usage will ever become common, we chose not to preclude it.
====

==== Guest-Page Faults

Guest-page-fault traps may be delegated from M-mode to HS-mode under the
control of CSR `medeleg`, but cannot be delegated to other privilege
modes. On a guest-page fault, CSR `mtval` or `stval` is written with the
faulting guest virtual address as usual, and `mtval2` or `htval` is
written either with zero or with the faulting guest physical address,
shifted right by 2 bits. CSR `mtinst` or `htinst` may also be written
with information about the faulting instruction or other reason for the
access, as explained in <<tinst-vals>>.

When an instruction fetch or a misaligned memory access straddles a page
boundary, two different address translations are involved. When a
guest-page fault occurs in such a circumstance, the faulting virtual
address written to `mtval`/`stval` is the same as would be required for
a regular page fault. Thus, the faulting virtual address may be a
page-boundary address that is higher than the instruction's original
virtual address, if the byte at that page boundary is among the accessed
bytes.

When a guest-page fault is not due to an implicit memory access for
VS-stage address translation, a nonzero guest physical address written
to `mtval2`/`htval` shall correspond to the exact virtual address
written to `mtval`/`stval`.

[[hyp-mm-fences]]
==== Memory-Management Fences

The behavior of the SFENCE.VMA instruction is affected by the current
virtualization mode V. When V=0, the virtual-address argument is an
HS-level virtual address, and the ASID argument is an HS-level ASID. The
instruction orders stores only to HS-level address-translation
structures with subsequent HS-level address translations.

When V=1, the virtual-address argument to SFENCE.VMA is a guest virtual
address within the current virtual machine, and the ASID argument is a
VS-level ASID within the current virtual machine. The current virtual
machine is identified by the VMID field of CSR `hgatp`, and the
effective ASID can be considered to be the combination of this VMID with
the VS-level ASID. The SFENCE.VMA instruction orders stores only to the
VS-level address-translation structures with subsequent VS-stage address
translations for the same virtual machine, i.e., only when `hgatp`.VMID
is the same as when the SFENCE.VMA executed.

Hypervisor instructions HFENCE.VVMA and HFENCE.GVMA provide additional
memory-management fences to complement SFENCE.VMA. These instructions
are described in <<hfence.vma>>.

<<pmp-vmem>> discusses the intersection between
physical memory protection (PMP) and page-based address translation. It
is noted there that, when PMP settings are modified in a manner that
affects either the physical memory that holds page tables or the
physical memory to which page tables point, M-mode software must
synchronize the PMP settings with the virtual memory system. For
HS-level address translation, this is accomplished by executing in
M-mode an SFENCE.VMA instruction with _rs1_=`x0` and _rs2_=`x0`, after
the PMP CSRs are written. Synchronization with G-stage and VS-stage data
structures is also needed. Executing an HFENCE.GVMA instruction with
_rs1_=`x0` and _rs2_=`x0` suffices to flush all G-stage or VS-stage
address-translation cache entries that have cached PMP settings
corresponding to the final translated supervisor physical address. An
HFENCE.VVMA instruction is not required.

Similarly, if the setting of the PBMTE bit in `menvcfg` is changed, an
HFENCE.GVMA instruction with _rs1_=`x0` and _rs2_=`x0` suffices to synchronize
with respect to the altered interpretation of G-stage and VS-stage PTEs' PBMT
fields.

By contrast, if the PBMTE bit in `henvcfg` is changed, executing an
HFENCE.VVMA with _rs1_=`x0` and _rs2_=`x0` suffices to synchronize with
respect to the altered interpretation of VS-stage PTEs' PBMT fields for the
currently active VMID.

NOTE: No mechanism is provided to atomically change `vsatp` and `hgatp`
together.  Hence, to prevent speculative execution causing one guest's
VS-stage translations to be cached under another guest's VMID, world-switch
code should zero `vsatp`, then swap `hgatp`, then finally write the new
`vsatp` value.  Similarly, if `henvcfg`.PBMTE need be world-switched, it
should be switched after zeroing `vsatp` but before writing the new `vsatp`
value, obviating the need to execute an HFENCE.VVMA instruction.

=== Traps

[[sec:hcauses]]
==== Trap Cause Codes

The hypervisor extension augments the trap cause encoding.
<<hcauses>> lists the possible M-mode and HS-mode
trap cause codes when the hypervisor extension is implemented. Codes are
added for VS-level interrupts (interrupts 2, 6, 10), for
supervisor-level guest external interrupts (interrupt 12), for
virtual-instruction exceptions (exception 22), and for guest-page faults
(exceptions 20, 21, 23). Furthermore, environment calls from VS-mode are
assigned cause 10, whereas those from HS-mode or S-mode use cause 9 as
usual.

[[hcauses]]
.Machine and supervisor cause register (`mcause` and `scause`) values when the hypervisor extension is implemented.
[%autowidth, float="center", align="center", cols=">,>,<", options="header"]
|===
|Interrupt |Exception Code |Description

|1 +
1 +
1 +
1
|0 +
1 +
2 +
3
|_Reserved_ +
Supervisor software interrupt +
Virtual supervisor software interrupt +
Machine software interrupt

|1 +
1 +
1 +
1
|4 +
5 +
6 +
7
|_Reserved_ +
Supervisor timer interrupt +
Virtual supervisor timer interrupt +
Machine timer interrupt

|1 +
1 +
1 +
1
|8 +
9 +
10 +
11
|_Reserved_ +
Supervisor external interrupt +
Virtual supervisor external interrupt +
Machine external interrupt

|1 +
1 +
1 +
1
|12 +
13 +
14-15 +
&#8805;16
|Supervisor guest external interrupt +
_Reserved for counter-overflow interrupt_ +
_Reserved_ +
_Designated for platform use_

|0 +
0 +
0 +
0 +
0 +
0 +
0 +
0 +
0 +
0 +
0 +
0 +
0 +
0 +
0 +
0 +
0 +
0 +
0 +
0 +
0 +
0 +
0 +
0 +
0 +
|0 +
1 +
2 +
3 +
4 +
5 +
6 +
7 +
8 +
9 +
10 +
11 +
12 +
13 +
14 +
15 +
16-19 +
20 +
21 +
22 +
23 +
24-31 +
32-47 +
48-63 +
&#8805;64
|Instruction address misaligned +
Instruction access fault  +
Illegal instruction  +
Breakpoint  +
Load address misaligned +
Load access fault +
Store/AMO address misaligned +
Store/AMO access fault +
Environment call from U-mode or VU-mode +
Environment call from HS-mode +
Environment call from VS-mode +
Environment call from M-mode +
Instruction page fault +
Load page fault +
_Reserved_ +
Store/AMO page fault +
_Reserved_  +
Instruction guest-page fault +
Load guest-page fault +
Virtual instruction +
Store/AMO guest-page fault +
_Designated for custom use_ +
_Reserved_ +
_Designated for custom use_ +
_Reserved_
|===

HS-mode and VS-mode ECALLs use different cause values so they can be
delegated separately.

When V=1, a virtual-instruction exception (code 22) is normally raised
instead of an illegal-instruction exception if the attempted instruction
is _HS-qualified_ but is prevented from executing when V=1 either due to
insufficient privilege or because the instruction is expressly disabled
by a supervisor or hypervisor CSR such as `scounteren` or `hcounteren`.
An instruction is _HS-qualified_ if it would be valid to execute in
HS-mode (for some values of the instruction's register operands),
assuming fields TSR and TVM of CSR `mstatus` are both zero.

A special rule applies for CSR instructions that access 32-bit high-half
CSRs such as `cycleh` and `htimedeltah`. When V=1 and
XLEN=32, an invalid attempt to access a high-half CSR
raises a virtual-instruction
exception instead of an illegal-instruction exception if the same CSR
instruction for the corresponding _low-half_ CSR (e.g.`cycle` or
`htimedelta`) is HS-qualified.

[NOTE]
====
When XLEN>32, an attempt to access a high-half CSR
always raises an illegal-instruction exception.
====

Specifically, a virtual-instruction exception is raised for the
following cases:

* in VS-mode, attempts to access a non-high-half counter CSR when the
corresponding bit in `hcounteren` is 0 and the same bit in `mcounteren`
is 1;
* in VS-mode, if XLEN=32, attempts to access a high-half counter CSR
when the corresponding bit in `hcounteren` is 0 and the same bit in
`mcounteren` is 1;
* in VU-mode, attempts to access a non-high-half counter CSR when the
corresponding bit in either `hcounteren` or `scounteren` is 0 and the
same bit in `mcounteren` is 1;
* in VU-mode, if XLEN=32, attempts to access a high-half counter CSR
when the corresponding bit in either `hcounteren` or `scounteren` is 0
and the same bit in `mcounteren` is 1;
* in VS-mode or VU-mode, attempts to execute a hypervisor instruction
(HLV, HLVX, HSV, or HFENCE);
* in VS-mode or VU-mode, attempts to access an implemented non-high-half
hypervisor CSR or VS CSR when the same access (read/write) would be
allowed in HS-mode, assuming `mstatus`.TVM=0;
* in VS-mode or VU-mode, if XLEN=32, attempts to access an implemented
high-half hypervisor CSR or high-half VS CSR when the same access
(read/write) to the CSR"s low-half partner would be allowed in HS-mode,
assuming `mstatus`.TVM=0;
* in VU-mode, attempts to execute WFI when `mstatus`.TW=0, or to execute
a supervisor instruction (SRET or SFENCE);
* in VU-mode, attempts to access an implemented non-high-half supervisor
CSR when the same access (read/write) would be allowed in HS-mode,
assuming `mstatus`.TVM=0;
* in VU-mode, if XLEN=32, attempts to access an implemented high-half
supervisor CSR when the same access to the CSR's low-half partner would
be allowed in HS-mode, assuming `mstatus`.TVM=0;
* in VS-mode, attempts to execute WFI when `hstatus`.VTW=1 and
`mstatus`.TW=0, unless the instruction completes within an
implementation-specific, bounded time;
* in VS-mode, attempts to execute SRET when `hstatus`.VTSR=1; and
* in VS-mode, attempts to execute an SFENCE.VMA or SINVAL.VMA
instruction or to access `satp`, when `hstatus`.VTVM=1.

Other extensions to the RISC-V Privileged Architecture may add to the
set of circumstances that cause a virtual-instruction exception when
V=1.

On a virtual-instruction trap, `mtval` or `stval` is written the same as
for an illegal-instruction trap.

[NOTE]
====
It is not unusual that hypervisors must emulate the instructions that
raise virtual-instruction exceptions, to support nested hypervisors or
for other reasons. Machine level is expected ordinarily to delegate
virtual-instruction traps directly to HS-level, whereas
illegal-instruction traps are likely to be processed first in M-mode before
being conditionally delegated (by software) to HS-level. Consequently,
virtual-instruction traps are expected typically to be handled faster
than illegal-instruction traps.

When not emulating the trapping instruction, a hypervisor should convert
a virtual-instruction trap into an illegal-instruction exception for the
guest virtual machine.

***

Because TSR and TVM in `mstatus` are intended to impact only S-mode
(HS-mode), they are ignored for determining exceptions in VS-mode.
====

<<<

[[HSyncExcPrio]]
.Synchronous exception priority when the hypervisor extension is implemented.
[%autowidth, float="center", align="center", cols="<,>,<", options="header"]
|===
|Priority |Exc.Code |Description

|_Highest_ |3 |Instruction address breakpoint

| .>|12, 20, 1 |During instruction address translation: +
&#160;&#160;&#160;First encountered page fault, guest-page fault, or access
fault

| .>|1 |With physical address for instruction: +
&#160;&#160;&#160;Instruction access fault

| |2 +
22 +
0 +
8, 9, 10, 11 +
3 +
3
|Illegal instruction +
Virtual instruction +
Instruction address misaligned +
Environment call +
Environment break +
&#160;&#160;&#160;Load/store/AMO address breakpoint

| .>|4,6 |Optionally: +
&#160;&#160;&#160;Load/store/AMO address misaligned

| .>|13, 15, 21, 23, 5, 7 |During address translation for an explicit memory access: +
&#160;&#160;&#160;First encountered page fault, guest-page fault,
or access fault

| .>|5, 7 |With physical address for an explicit memory access: +
&#160;&#160;&#160;Load/store/AMO access fault

.>|_Lowest_ .>|4, 6 |If not higher priority: +
&#160;&#160;&#160;Load/store/AMO address misaligned
|===

If an instruction may raise multiple synchronous exceptions, the
decreasing priority order of <<HSyncExcPrio>>
indicates which exception is taken and reported in `mcause` or `scause`.

==== Trap Entry

When a trap occurs in HS-mode or U-mode, it goes to M-mode, unless
delegated by `medeleg` or `mideleg`, in which case it goes to HS-mode.
When a trap occurs in VS-mode or VU-mode, it goes to M-mode, unless
delegated by `medeleg` or `mideleg`, in which case it goes to HS-mode,
unless further delegated by `hedeleg` or `hideleg`, in which case it
goes to VS-mode.

When a trap is taken into M-mode, virtualization mode V gets set to 0,
and fields MPV and MPP in `mstatus` (or `mstatush`) are set according to
<<h-mpp>>. A trap into M-mode also writes fields GVA,
MPIE, and MIE in `mstatus`/`mstatush` and writes CSRs `mepc`, `mcause`,
`mtval`, `mtval2`, and `mtinst`.

[[h-mpp]]
.Value of `mstatus`/`mstatush` fields MPV and MPP after a trap into M-mode.  Upon trap return, MPV is ignored when MPP=3.
[%autowidth, float="center", align="center", cols="<,^,^", options="header"]
|===
|Previous Mode |MPV |MPP

|U-mode +
HS-mode +
M-mode
|0 +
0 +
0
|0 +
1 +
3

|VU-mode +
VS-mode
|1 +
1
|0 +
1
|===

When a trap is taken into HS-mode, virtualization mode V is set to 0,
and `hstatus`.SPV and `sstatus`.SPP are set according to
<<h-spp>>. If V was 1 before the trap, field SPVP in
`hstatus` is set the same as `sstatus`.SPP; otherwise, SPVP is left
unchanged. A trap into HS-mode also writes field GVA in `hstatus`,
fields SPIE and SIE in `sstatus`, and CSRs `sepc`, `scause`, `stval`,
`htval`, and `htinst`.

[[h-spp]]
.Value of `hstatus` field SPV and `sstatus` field SPP after a trap into HS-mode.
[%autowidth, float="center", align="center", cols="<,^,^", options="header"]
|===
|Previous Mode |SPV |SPP

|U-mode +
HS-mode +
|0 +
0
|0 +
1

|VU-mode +
VS-mode
|1 +
1
|0 +
1
|===

When a trap is taken into VS-mode, `vsstatus`.SPP is set according to
<<h-vspp>>. Register `hstatus` and the HS-level
`sstatus` are not modified, and the virtualization mode V remains 1. A
trap into VS-mode also writes fields SPIE and SIE in `vsstatus` and
writes CSRs `vsepc`, `vscause`, and `vstval`.

[[h-vspp]]
.Value of `vsstatus` field SPP after a trap into VS-mode.
[%autowidth, float="center", align="center", cols="<,^", options="header"]
|===
|Previous Mode |SPP

|VU-mode +
VS-mode
|0 +
1
|===

[[tinst-vals]]
==== Transformed Instruction or Pseudoinstruction for `mtinst` or `htinst`

On any trap into M-mode or HS-mode, one of these values is written
automatically into the appropriate trap instruction CSR, `mtinst` or
`htinst`:

* zero;
* a transformation of the trapping instruction;
* a custom value (allowed only if the trapping instruction is
non-standard); or
* a special pseudoinstruction.

Except when a pseudoinstruction value is required (described later), the
value written to `mtinst` or `htinst` may always be zero, indicating
that the hardware is providing no information in the register for this
particular trap.

[NOTE]
====
The value written to the trap instruction CSR serves two purposes. The
first is to improve the speed of instruction emulation in a trap
handler, partly by allowing the handler to skip loading the trapping
instruction from memory, and partly by obviating some of the work of
decoding and executing the instruction. The second purpose is to supply,
via pseudoinstructions, additional information about guest-page-fault
exceptions caused by implicit memory accesses done for VS-stage address
translation.

A _transformation_ of the trapping instruction is written instead of
simply a copy of the original instruction in order to minimize the
burden for hardware yet still provide to a trap handler the information
needed to emulate the instruction. An implementation may at any time
reduce its effort by substituting zero in place of the transformed
instruction.
====

On an interrupt, the value written to the trap instruction register is
always zero. On a synchronous exception, if a nonzero value is written,
one of the following shall be true about the value:

* Bit 0 is `1`, and replacing bit 1 with `1` makes the value into a
valid encoding of a standard instruction.
+
In this case, the instruction that trapped is the same kind as indicated
by the register value, and the register value is the transformation of
the trapping instruction, as defined later. For example, if bits 1:0 are
binary `11` and the register value is the encoding of a standard LW
(load word) instruction, then the trapping instruction is LW, and the
register value is the transformation of the trapping LW instruction.
* Bit 0 is `1`, and replacing bit 1 with `1` makes the value into an
instruction encoding that is explicitly designated for a custom
instruction (_not_ an unused reserved encoding).
+
This is a _custom value_. The instruction that trapped is a non-standard
instruction. The interpretation of a custom value is not otherwise
specified by this standard.
* The value is one of the special pseudoinstructions defined later, all
of which have bits 1:0 equal to `00`.

These three cases exclude a large number of other possible values, such
as all those having bits 1:0 equal to binary `10`. A future standard or
extension may define additional cases, thus allowing values that are
currently excluded. Software may safely treat an unrecognized value in a
trap instruction register the same as zero.

[NOTE]
====
To be forward-compatible with future revisions of this standard,
software that interprets a nonzero value from `mtinst` or `htinst` must
fully verify that the value conforms to one of the cases listed above.
For instance, for RV64, discovering that bits 6:0 of `mtinst` are
`0000011` and bits 14:12 are `010` is not sufficient to establish that
the first case applies and the trapping instruction is a standard LW
instruction; rather, software must also confirm that bits 63:32 of
`mtinst` are all zeros. A future standard might define new values for
64-bit `mtinst` that are nonzero in bits 63:32 yet may coincidentally
have in bits 31:0 the same bit patterns as standard RV64 instructions.

***

Unlike for standard instructions, there is no requirement that the
instruction encoding of a custom value be of the same ``kind'' as the
instruction that trapped (or even have any correlation with the trapping
instruction).
====

<<tinst-values>> shows the values that may be
automatically written to the trap instruction register for each standard
exception cause. For exceptions that prevent the fetching of an
instruction, only zero or a pseudoinstruction value may be written. A
custom value may be automatically written only if the instruction that
traps is non-standard. A future standard or extension may permit other
values to be written, chosen from the set of allowed values established
earlier.

<<<

[[tinst-values]]
.Values that may be automatically written to the trap instruction register (`mtinst` or `htinst`) on an exception trap.
[float="center", align="center", cols="2,^,^,^,^", options="header"]
|===
<.>|Exception
|Zero
|Transformed +
Standard +
Instruction
^.>|Custom Value
^.>|Pseudo-instruction Value

|Instruction address misaligned |Yes |No |Yes |No

|Instruction access fault +
Illegal instruction +
Breakpoint +
Virtual instruction
|Yes +
Yes +
Yes +
Yes
|No +
No +
No +
No +
|No +
No +
Yes +
Yes
|No +
No +
No +
No

|Load address misaligned +
Load access fault +
Store/AMO address misaligned +
Store/AMO access fault
|Yes +
Yes +
Yes +
Yes
|Yes +
Yes +
Yes +
Yes
|Yes +
Yes +
Yes +
Yes
|No +
No +
No +
No

|Environment call |Yes |No |Yes |No

|Instruction page fault +
Load page fault +
Store/AMO page fault
|Yes +
Yes +
Yes
|No +
Yes +
Yes
|No +
Yes +
Yes
|No +
No +
No

|Instruction guest-page fault +
Load guest-page fault +
Store/AMO guest-page fault
|Yes +
Yes +
Yes
|No +
Yes +
Yes
|No +
Yes +
Yes
|Yes +
Yes +
Yes
|===

As enumerated in the table, a synchronous exception may write to the
trap instruction register a standard transformation of the trapping
instruction only for exceptions that arise from explicit memory accesses
(from loads, stores, and AMO instructions). Accordingly, standard
transformations are currently defined only for these memory-access
instructions. If a synchronous trap occurs for a standard instruction
for which no transformation has been defined, the trap instruction
register shall be written with zero (or, under certain circumstances,
with a special pseudoinstruction value).

For a standard load instruction that is not a compressed instruction and
is one of LB, LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH, the
transformed instruction has the format shown in
<<transformedloadinst>>.

include::images/wavedrom/transformedloadinst.edn[]

For a standard store instruction that is not a compressed instruction
and is one of SB, SH, SW, SD, FSW, FSD, FSQ, or FSH, the transformed
instruction has the format shown in
<<transformedstoreinst>>.

include::images/wavedrom/transformedstoreinst.edn[]

For a standard atomic instruction (load-reserved, store-conditional, or AMO instruction), the transformed instruction has the format shown in <<transformedatomicinst>>.

include::images/wavedrom/transformedatomicinst.edn[]

For a standard virtual-machine load/store instruction (HLV, HLVX, or HSV), the transformed instruction has the format shown in <<transformedvmaccessinst>>.

include::images/wavedrom/transformedvmaccessinst.edn[]

In all the transformed instructions above, the Addr.Offset field that
replaces the instruction’s rs1 field in bits 19:15 is the positive
difference between the faulting virtual address (written to `mtval` or
`stval`) and the original virtual address. This difference can be
nonzero only for a misaligned memory access. Note also that, for basic
loads and stores, the transformations replace the instruction’s
immediate offset fields with zero.

For a standard compressed instruction (16-bit size), the transformed
instruction is found as follows:

. Expand the compressed instruction to its 32-bit equivalent.
. Transform the 32-bit equivalent instruction.
. Replace bit 1 with a `0`.

Bits 1:0 of a transformed standard instruction will be binary `01` if
the trapping instruction is compressed and `11` if not.

[NOTE]
====
In decoding the contents of `mtinst` or `htinst`, once software has
determined that the register contains the encoding of a standard basic
load (LB, LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH) or basic
store (SB, SH, SW, SD, FSW, FSD, FSQ, or FSH), it is not necessary to
confirm also that the immediate offset fields (31:25, and 24:20 or 11:7)
are zeros. The knowledge that the register’s value is the encoding of a
basic load/store is sufficient to prove that the trapping instruction is
of the same kind.

A future version of this standard may add information to the fields that
are currently zeros. However, for backwards compatibility, any such
information will be for performance purposes only and can safely be
ignored.
====

For guest-page faults, the trap instruction register is written with a
special pseudoinstruction value if: (a) the fault is caused by an
implicit memory access for VS-stage address translation, and (b) a
nonzero value (the faulting guest physical address) is written to
`mtval2` or `htval`. If both conditions are met, the value written to
`mtinst` or `htinst` must be taken from
<<pseudoinsts>>; zero is not allowed.

[[pseudoinsts]]
.Special pseudoinstruction values for guest-page faults.  The RV32 values are used when VSXLEN=32, and the RV64 values when VSXLEN=64.
[%autowidth, float="center", align="center", cols="<,<", options="header"]
|===
|Value |Meaning

|`0x00002000` +
`0x00002020`
|32-bit read for VS-stage address translation (RV32) +
32-bit write for VS-stage address translation (RV32)

|`0x00003000` +
`0x00003020`
|64-bit read for VS-stage address translation (RV64) +
64-bit write for VS-stage address translation (RV64)
|===

The defined pseudoinstruction values are designed to correspond closely
with the encodings of basic loads and stores, as illustrated by
<<pseudoinsts-basis>>.

[[pseudoinsts-basis]]
.Standard instructions corresponding to the special psudoinstructions of <<pseudoinsts>>.
[%autowidth, float="center", align="center", cols="<,<", options="header"]
|===
|Encoding |Instruction

|`0x00002003` +
`0x00002023`
|`lw x0,0(x0)` +
`sw x0,0(x0)`

|`0x00003003` +
`0x00003023`
|`ld x0,0(x0)` +
`sd x0,0(x0)`
|===

A _write_ pseudoinstruction (`0x00002020` or `0x00003020`) is used for
the case that the machine is attempting automatically to update bits A
and/or D in VS-level page tables. All other implicit memory accesses for
VS-stage address translation will be reads. If a machine never
automatically updates bits A or D in VS-level page tables (leaving this
to software), the _write_ case will never arise. The fact that such a
page table update must actually be atomic, not just a simple write, is
ignored for the pseudoinstruction.

[NOTE]
====
If the conditions that necessitate a pseudoinstruction value can ever
occur for M-mode, then `mtinst` cannot be entirely read-only zero; and
likewise for HS-mode and `htinst`. However, in that case, the trap
instruction registers may minimally support only values 0 and
`0x00002000` or `0x00003000`, and possibly `0x00002020` or `0x00003020`,
requiring as few as one or two flip-flops in hardware, per register.

***

There is no harm here in ignoring the atomicity requirement for page
table updates, because a hypervisor is not expected in these
circumstances to emulate an implicit memory access that fails. Rather,
the hypervisor is given enough information about the faulting access to
be able to make the memory accessible (e.g. by restoring a missing page
of virtual memory) before resuming execution by retrying the faulting
instruction.
====

==== Trap Return

The MRET instruction is used to return from a trap taken into M-mode.
MRET first determines what the new privilege mode will be according to
the values of MPP and MPV in `mstatus` or `mstatush`, as encoded in
<<h-mpp>>. MRET then in `mstatus`/`mstatush` sets
MPV=0, MPP=0, MIE=MPIE, and MPIE=1. Lastly, MRET sets the privilege mode
as previously determined, and sets `pc`=`mepc`.

The SRET instruction is used to return from a trap taken into HS-mode or
VS-mode. Its behavior depends on the current virtualization mode.

When executed in M-mode or HS-mode (i.e., V=0), SRET first determines
what the new privilege mode will be according to the values in
`hstatus`.SPV and `sstatus`.SPP, as encoded in
<<h-spp>>. SRET then sets `hstatus`.SPV=0, and in
`sstatus` sets SPP=0, SIE=SPIE, and SPIE=1. Lastly, SRET sets the
privilege mode as previously determined, and sets `pc`=`sepc`.

When executed in VS-mode (i.e., V=1), SRET sets the privilege mode
according to <<h-vspp>>, in `vsstatus` sets SPP=0,
SIE=SPIE, and SPIE=1, and lastly sets `pc`=`vsepc`.