[[rv32]]
== RV32I 基本整数指令集，版本 2.1

本章介绍了 RV32I 基本整数指令集。

[TIP]
====
RV32I 旨在成为编译器目标，并支持现代操作系统环境。 此指令集架构还旨在减少最低限度实现所需的硬件。 RV32I 包含 40 条独特的指令，尽管简单实现可能用一个始终陷入的 SYSTEM 硬指令涵盖 ECALL/EBREAK 指令，并可能将 FENCE 指令实现为 NOP，从而将基本指令数减少到总计 38。 RV32I 可以模拟几乎任何其他指令集架构扩展（除 A 扩展外，它需要额外的硬件支持以实现原子性）。

实践中，包括机器模式特权架构在内的硬件实现还需要 6 条 CSR 指令。

基本整数指令集架构的子集可能在教学目的上有用，但基本集已定义，不应有太多动力在真正的硬件实现中使用子集，除了省略对未对齐内存访问的支持并将所有 SYSTEM 指令视为单一陷阱。
====

[NOTE]
====
标准 RISC-V 汇编语言语法记录在《汇编程序员手册》cite:[riscv-asm-manual] 中。
====

[NOTE]
====
RV32I 的大部分评论也适用于 RV64I 基本集。
====

=== 基本整数指令集架构的程序员模型

<<gprs>> 显示了基本整数ISA的非特权状态。 对于 RV32I，32 个 `x` 寄存器每个宽 32 位，即 `XLEN=32`。 寄存器 `x0` 硬接线为所有位均为 0。
通用寄存器 `x1-x31` 存储各种指令解释为布尔值集合或二进制补码整数或无符号二进制整数的值。

还有一个额外的非特权寄存器：程序计数器 `pc` 存放当前指令的地址。

[[gprs]]
.RISC-V 基本非特权整数寄存器状态。
[cols="<,^,>", options="header", width="50%", align="center", grid="rows"]
|===
<|[.small]#XLEN-1#
|
>|[.small]#0#

3+^|[.small]#x0/zero#

3+^|[.small]#x1#

3+^|[.small]#x2#

3+^|[.small]#x3#

3+^|[.small]#x4#

3+^|[.small]#x5#

3+^|[.small]#x6#

3+^|[.small]#x7#

3+^|[.small]#x8#

3+^|[.small]#x9#

3+^|[.small]#x10#

3+^|[.small]#x11#

3+^|[.small]#x12#

3+^|[.small]#x13#

3+^|[.small]#x14#

3+^|[.small]#x15#

3+^|[.small]#x16#

3+^|[.small]#x17#

3+^|[.small]#x18#

3+^|[.small]#x19#

3+^|[.small]#x20#

3+^|[.small]#x21#

3+^|[.small]#x22#

3+^|[.small]#x23#

3+^|[.small]#x24#

3+^|[.small]#x25#

3+^|[.small]#x26#

3+^|[.small]#x27#

3+^|[.small]#x28#

3+^|[.small]#x29#

3+^|[.small]#x30#

3+^|[.small]#x31#

3+^|[.small]#XLEN#

|[.small]#XLEN-1# | >|[.small]#0#

3+^|[.small]#pc#

3+^|[.small]#XLEN#
|===

[NOTE]
====
基本整数指令集架构中没有专用的堆栈指针或子程序返回地址链接寄存器；指令编码允许使用任何 `x` 寄存器来实现这些目的。 但是，标准软件调用约定使用寄存器 `x1` 来存储调用的返回地址，寄存器 `x5` 可用作备用链接寄存器。 标准调用约定使用寄存器 `x2` 作为堆栈指针。

硬件可以选择加速使用 `x1` 或 `x5` 的函数调用和返回。 请参阅 JAL 和 JALR 指令的说明。

可选的压缩 16 位指令格式设计的假设是 `x1` 是返回地址寄存器，`x2` 是堆栈指针。 使用其他约定的软件将正确运行，但可能会使代码大小更大。

可用的架构寄存器数量会对代码大小、性能和能耗产生重大影响。 尽管可以认为 16 个寄存器对于运行编译代码的整数指令集足够，但使用 3 地址格式在 16 位指令中编码完整指令集是不可能的。 虽然可以采用 2 地址格式，但这会增加指令数并降低效率。
我们希望避免中间指令大小（如 Xtensa 的 24 位指令），以简化基本硬件实现，一旦采用 32 位指令大小，就可以很容易地支持 32 个整数寄存器。 更多的整数寄存器也有助于提高高性能代码的性能，这些代码中可能会广泛使用循环展开、软件流水线和缓存切片。

出于这些原因，我们为 RV32I 选择了 32 个整数寄存器的常规大小。 动态寄存器使用往往由几个经常访问的寄存器主导，并且寄存器文件实现可以优化以减少频繁访问寄存器的访问能耗 cite:[jtseng:sbbci]。 可选的压缩 16 位指令格式大多仅访问 8 个寄存器，因此可以提供密集的指令编码，而如果需要，额外的指令集扩展可以支持更大的寄存器空间（平面或层次结构）。

对于资源受限的嵌入式应用，我们定义了 RV32E 子集，其中只有 16 个寄存器
(<<rv32e>>)。
====

=== 基本指令格式

在基本 RV32I ISA 中，有四种核心指令格式 (R/I/S/U)，如 <<base_instr>> 所示。 它们长度均为固定的 32 位。 基本指令集具有 `IALIGN=32`，意味着指令必须在内存中对齐到四字节边界。 如果目标地址没有对齐到 `IALIGN-bit`，则在执行分支或无条件跳转时会生成指令地址未对齐异常。
该异常是在分支或跳转指令上报告的，而不是目标指令。 对于未执行的条件分支，不会生成指令地址未对齐异常。

[NOTE]
====
当添加具有 16 位长度或其他奇数倍 16 位长度的指令扩展时，基本指令集的对齐约束放宽到两字节边界（即 IALIGN=16）。

指令地址未对齐异常在会导致指令未对齐的分支或跳转指令上报告，以帮助调试，并简化 IALIGN=32 的系统的硬件设计，这些是未对齐可能发生的唯一位置。
====

对于保留指令的解码行为未指定。

[NOTE]
====
某些平台可能要求保留用于标准用途的操作码引发非法指令异常。 其他平台可能允许保留的操作码空间用于不符合规范的扩展。
====

RISC-V ISA 在所有格式中保持源（_rs1_ 和 _rs2_）和目标（_rd_）寄存器在同一位置以简化解码。
除 CSR 指令中使用的 5 位立即数 (<<csrinsts>>) 外，即时数始终为符号扩展，并且通常填充到指令中最左可用的位并已分配以减少硬件复杂性。 特别是，所有立即数的符号位始终位于指令的第 31 位以加快符号扩展电路。

include::images/wavedrom/instruction_formats.adoc[]

[[base_instr, Base instruction formats]]
RISC-V 基本指令格式。 每个立即数子字段用正在生成的立即数中的位位置 (imm[x]) 标记，而不是通常在指令的立即字段内的位位置。

[NOTE]
====
解码寄存器说明符通常在实现中的关键路径上，因此选择了指令格式，以保持所有寄存器说明符在所有格式中的相同位置，代价是必须在格式之间移动立即数位（与 RISC-IV aka 共享的属性）。 SPUR cite:[spur-jsscc1989]）。

在实践中，大多数立即数要么很小，要么需要所有 XLEN 位。
我们选择不对称的立即数分割（常规指令为 12 位加上一个特殊的载入上部立即数指令为 20 位）以增加可用于常规指令的操作码空间。

立即数是符号扩展的，因为我们没有发现使用零扩展一些立即数（如在 MIPS ISA 中）的益处，并且希望保持 ISA 尽可能简单。
====

=== 立即数编码变体

基于立即数处理，还有两个指令格式变体（B/J），如 <<baseinstformatsimm>> 中所示。

include::images/wavedrom/immediate_variants.adoc[]

//.RISC-V base instruction formats showing immediate variants.

S 和 B 格式之间的唯一区别在于 B 格式中 12 位立即字段用于编码以 2 的倍数的分支偏移。 与惯常做法不同，未将指令编码的立即数所有位在硬件中左移一位，而是中间位 (imm[10:1]) 和符号位保持在固定位置中，而 S 格式中的最低位 (inst[7]) 在 B 格式中编码为高位。

类似地，U 和 J 格式之间的唯一区别在于 20 位立即数左移 12 位形成 U 立即数，并左移1位形成 J 立即数。 U 和 J 格式立即数中的指令位位置选择最大化与其他格式和彼此的重叠。

<<immtypes>> 显示每种基本指令格式产生的立即数，并标记说明哪个指令位 (inst[_y_]) 产生立即数值的每个位。

include::images/wavedrom/immediate.adoc[]

这些字段用用于构造其值的指令位标记。  符号扩展始终使用 inst[31]。

[NOTE]
====
符号扩展是立即数上最关键的操作之一（特别是对于 XLEN>32），在 RISC-V 中，所有立即数的符号位始终位于指令的第 31 位，以允许符号扩展与指令解码并行进行。

尽管更复杂的实现可能会有独立的加法器用于分支和跳转计算，因此不会从在各种指令中保持立即数位位置不变中获益，我们希望降低最简单实现实现的硬件成本。 通过旋转 B 和 J 立即数的指令编码中的位而不是使用动态硬件多路复用器将立即数乘以 2，我们将指令信号扇出和立即多路复用器成本减少了约 2 倍。 混乱的立即数编码几乎不会增加静态或预编译时间。 对于动态生成指令，有一些小的额外开销，但最常见的短向前分支具有简单的立即数字编码。
====

=== 整数计算指令

大多数整数计算指令操作在整数寄存器文件中持有的 `XLEN` 位值上。 整数计算指令要么以 I 型格式编码为寄存器-立即操作，要么以 R 型格式编码为寄存器-寄存器操作。 寄存器-立即指令和寄存器-寄存器指令的目标寄存器均为 _rd_。 没有整数计算指令会导致算术异常。

[TIP]
====
我们没有在基本指令集中包括用于整数算术操作的溢出检查的特殊指令集支持，因为许多溢出检查可以通过 RISC-V 分支廉价实现。
无符号加法的溢出检查仅在加法后需要一个额外的分支指令：
`add t0, t1, t2; bltu t0, t1, overflow`。

对于符号相同的加法，如果已知一个操作数的符号，溢出检查只需要一个加法后的分支：
`addi t0, t1, +imm; blt t0, t1, overflow`。 这涵盖了带有立即子操作数的加法的常见情况。

对于一般符号相同的加法，除了加法后需要三个额外的指令，利用了这样的观察：只有当另外一个操作数是负数时，和才应该小于其中一个操作数。

[source,text]
....
         add t0, t1, t2
         slti t3, t2, 0
         slt t4, t0, t1
         bne t3, t4, overflow
....

在 RV64I 中，通过比较操作数上的 ADD 和 ADDW 的结果，可以进一步优化 32 位符号相同加法的检查。
====

==== 整数寄存器-立即指令

include::images/wavedrom/integer_computational.adoc[]

//.Integer Computational Instructions

ADDI 将符号扩展的 12 位立即数添加到寄存器 _rs1_。
算术溢出被忽略，结果只是结果的低 XLEN 位。 ADDI _rd, rs1, 0_ 用于实现 MV _rd, rs1_ 汇编伪指令。

如果寄存器 _rs1_ 小于符号扩展的立即数，SLTI（设置小于立即数）将值 1 放在寄存器 _rd_ 中（当两个都被视为有符号数时），否则将 0 写入 _rd_。 SLTIU 类似，但将值视为无符号数进行比较（即立即数首先符号扩展到 XLEN 位，然后视为无符号数）。
注意，如果 _rs1_ 等于零，SLTIU _rd, rs1, 1_ 将 _rd_ 设置为 1，否则将 _rd_ 设置为 0（汇编伪指令 SEQZ _rd, rs_）。

ANDI、ORI、XORI 是逻辑操作，在寄存器 _rs1_ 和符号扩展的 12 位立即数上执行按位与、或、异或运算，并将结果放入 _rd_。 请注意，XORI _rd, rs1, -1_ 对寄存器 _rs1_ 执行按位逻辑反转（汇编伪指令 NOT _rd, rs_）。

include::images/wavedrom/int-comp-slli-srli-srai.adoc[]

//.Integer register-immediate, SLLI, SRLI, SRAI

以常数为单位的移位被编码为 I 型格式的特化。 要移位的操作数位于 _rs1_ 中，移位量编码在 I-立即字段的低 5 位中。 右移类型编码在第 30 位。 SLLI 是逻辑左移（零被移入低位）；SRLI 是逻辑右移（零被移入高位）；SRAI 是算术右移（原来的符号位被复制到空出的高位中）。

include::images/wavedrom/int-comp-lui-aiupc.adoc[]

//.Integer register-immediate, U-immediate

LUI（载入上部立即数）用于构建 32 位常数，使用 U 型格式。 LUI 将 32 位 U-立即数值放入目标寄存器 _rd_，填充最低位 12 为零。

AUIPC（给 `pc` 增加上部立即数）用于构建 `pc` 相对地址，并使用 U 型格式。 AUIPC 从 U-立即数生成 32 位偏移量，填充最低 12 为零，将此偏移量加到 AUIPC 指令的地址，然后将结果放入寄存器 _rd_ 。

[NOTE]
====
`lui` 和 `auipc` 的汇编语法不表示 U-立即数的低 12 位，其始终为零。

AUIPC 指令支持两指令序列来访问 PC 的任意偏移量，无论控制流传输和数据访问。 AUIPC 与 JALR 中的 12 位立即数组合可以将控制转移到任何 32 位 PC 相对地址，而 AUIPC 加上常规加载或存储指令中的 12 位立即数偏移量可以访问任何 32 位 PC 相对数据地址。

通过将 U-立即数设置为 0 来获得当前 PC。 尽管 JAL +4 指令也可用于获取局部 PC（紧接 JAL 的指令），但它可能会在更简单的微架构中导致流水线中断或在更复杂的微架构中污染 BTB 结构。
====

==== 整数寄存器-寄存器操作

RV32I 定义了几种算术 R 型操作。 所有操作读取寄存器 _rs1_ 和 _rs2_ 作为源操作数，并将结果写入寄存 _rd_。 _funct7_ 和 _funct3_ 字段选择操作的类型。

include::images/wavedrom/int_reg-reg.adoc[]

//.Integer register-register

ADD 执行 _rs1_ 和 _rs2_ 的加法。 SUB 执行从 _rs1_ 中减去 _rs2_。 溢出被忽略，并且结果的低 XLEN 位被写入目标 _rd_。 SLT 和 SLTU 分别执行有符号和无符号比较，如果 _rs1_ < _rs2_ 则写入 1 到 _rd_，否则为 0。 注意，如果 _rs2_ 不等于零，SLTU _rd_, _x0_, _rs2_ 将 _rd_ 设置为 1，否则将 _rd_ 设置为零（汇编伪指令 SNEZ _rd, rs_）。 AND、OR 和 XOR 执行按位逻辑运算。

SLL、SRL 和 SRA 通过寄存器 _rs2_ 的低 5 位中的移位量对寄存器 _rs1_ 中的值执行逻辑左移、逻辑右移和算术右移。

==== NOP 指令

include::images/wavedrom/nop.adoc[]

//.NOP instructions

NOP 指令不会改变任何架构上可见的状态，除了推进 `pc` 和增加任何应用的性能计数器。 NOP 被编码为 ADDI _x0, x0, 0_。

[NOTE]
====
NOP 可用于将代码段与微架构上的重要地址边界对齐，或为内联代码修改留下空间。 尽管编码一个 NOP 有很多可能的方式，但我们定义了一个典型的 NOP 编码，以允许微架构优化以及更具可读性的反汇编输出。 其他 NOP 编码可用于 <<rv32i-hints>>。

选择 ADDI 作为 NOP 编码，因为这最可能占用最少的资源来跨不同的系统执行（如果没有在解码中优化掉）。 特别是，该指令只读取一个寄存器。
此外，在超标量设计中，更可能有一个 ADDI 功能单元，因为加法是最常见的操作。 特别是，地址生成功能单元可以使用基本+偏移地址计算所需的相同硬件执行 ADDI，而寄存器-寄存器加法或逻辑/移位操作则需要额外的硬件。
====

=== 控制传输指令

RV32I 提供两种类型的控制传输指令：无条件跳转和条件分支。 RV32I 中的控制传输指令 _没有_ 构架上可见的延迟槽。

如果在跳跃或采取分支的目标上发生指令访问故障或指令页故障异常，则该异常在目标指令上报告，而不是跳跃或分支指令。

==== 无条件跳转

跳跃和链接 (JAL) 指令使用 J 型格式，其中 J 立即数编码为 2 字节的倍数的带符号偏移量。 该偏移量符号扩展并加到跳转指令的地址上形成跳转目标地址。 因此跳转可以定位 ±1 MiB 范围。 JAL 将紧随跳转的指令（'pc'+4）的地址存储到寄存器 _rd_ 中。 标准软件调用约定使用 'x1' 作为返回地址寄存器，并使用 'x5' 作为备用链接寄存器。

[NOTE]
====
备用链接寄存器支持调用微代码例程（例如，用于在压缩代码中保存和恢复寄存器的例程），同时保留常规返回地址寄存器。 选择寄存器 `x5` 作为备用链接寄存器，因为它在标准调用约定中映射到一个临时寄存器，并且其编码只比常规链接寄存器多一个位。
====

普通无条件跳转（汇编伪指令 J）编码为 JAL，_rd_=`x0`。

include::images/wavedrom/ct-unconditional.adoc[]

//.The unconditional-jump instruction, JAL

间接跳转指令 JALR（跳转和链接寄存器）使用 I 型编码。 通过将符号扩展的 12 位 I-立即数添加到寄存器 _rs1_ 来获取目标地址，然后将结果的最低有效位设置为零。 跳转后指令的地址（`pc`+4）被写入寄存器 _rd_。
如果结果不需要，可以使用寄存器 `x0` 作为目标寄存器。

include::images/wavedrom/ct-unconditional-2.adoc[]

//.The indirect unconditional-jump instruction, JALR

[NOTE]
====
所有无条件跳转指令均使用 PC 相对寻址以帮助支持位置无关代码。 JALR 指令定义为能够在 32 位绝对地址范围内的任意位置跳转的两指令序列。 LUI 指令可以首先将目标地址的高 20 位加载到 _rs1_ 中，然后 JALR 可以添加低位。
类似地，AUIPC 然后 JALR 可以在 32 位 `pc` 相对地址范围内的任意位置跳转。

注意，JALR 指令不像条件分支指令那样将 12 位立即数视为 2 字节的倍数。 这样避免了硬件中多一个立即数格式。 实际上，大多数使用 JALR 的情况要么有一个零立即数，要么与 LUI 或 AUIPC 配对，因此范围的轻微减少并不显著。

在计算 JALR 目标地址时清除最低有效位既简化了硬件，又允许使用函数指针的低位来存储辅助信息。 虽然这种情况下可能会略微减少错误检查，但实际上跳转到错误指令地址通常会很快引发异常。

当与基 _rs1_=`x0` 一起使用时，JALR 可用于实现从地址空间的任何位置到最低或最高地址区域的单条指令子程序调用，这可以用来实现快速调用到小型运行时库。 或者，ABI 可专用通用寄存器以指向地址空间中其他位置的库。
====

如果目标地址未对齐到四字节边界，JAL 和 JALR 指令会生成指令地址未对齐异常。

[NOTE]
====
对于支持 16 位对齐指令扩展的机器，例如压缩指令集扩展 C，指令地址未对齐异常是不可能的。
====

返回地址预测栈是高性能指令获取单元的常见功能，但需要准确检测用于过程调用和返回的指令才能有效。
对于 RISC-V，关于指令用法的提示通过使用的寄存器号码隐式编码。 仅当 _rd_ 为 'x1' 或 `x5` 时，JAL 指令应将返回地址推入返回地址栈 (RAS)。 JALR 指令应按 <<rashints>> 中所示推入/弹出一个 RAS。

[[rashints]]
.JALR 指令的寄存器操作数中编码了返回地址栈预测提示。
[%autowidth, float="center", align="center", cols="^,^,^,<", options="header"]
|===
|_rd_ 是 _x1/x5_ |_rs1_ 是 _x1/x5_ |_rd_=_rs1_ |RAS 操作

|无 |无 |-- |无

|无 |是 |-- |弹出

|是 |无 |-- |入栈

|是 |是 |无 |先弹出，再入栈

|是 |是 |是 |入栈
|===

[NOTE]
====
其他一些指令集架构在它们的间接跳转指令中添加了显式提示位，以指导返回地址栈操作。 我们使用与寄存器号码和调用约定绑定的隐式提示来减少用于这些提示的编码空间。

当两个不同的链接寄存器（`x1` 和 `x5`）作为 _rs1_ 和 _rd_ 给出时，RAS 同时出栈和入栈以支持协程。 如果 _rs1_ 和 _rd_ 是相同的链接寄存器（`x1` 或 `x5`），则 RAS 仅推入以启用序列的宏操作融合：
`lui ra, imm20; jalr ra, imm12(ra)` 和 `auipc ra, imm20; jalr ra, imm12(ra)`
====

==== 条件分支

所有分支指令都使用 B 型指令格式。 12 位 B-立即数以 2 字节为单位编码有符号偏移量。 偏移量进行符号扩展后加到分支指令的地址上，以得到目标地址。 条件分支范围为 ±4 KiB。

include::images\/wavedrom\/ct-conditional.adoc[]

//.Conditional branches

分支指令比较两个寄存器。 如果寄存器 _rs1_ 和 _rs2_ 相等或不相等，则 BEQ 和 BNE 分别执行分支。 如果 _rs1_ 小于 _rs2_，则 BLT 和 BLTU 分别使用有符号和无符号比较执行分支。 如果 _rs1_ 大于或等于 _rs2_，则 BGE 和 BGEU 分别使用有符号和无符号比较执行分支。 注意，BGT、BGTU、BLE 和 BLEU 可以通过反转 BLT、BLTU、BGE 和 BGEU 的操作数来合成。

[NOTE]
====
可以通过一个 BLTU 指令检查有符号数组边界，因为任何负索引的比较结果都大于任一非负边界。
====

软件应优化为使顺序代码路径是最常用路径，不常执行的代码路径放在行外。 软件还应假定，至少在第一次遇到时，后向分支将预测为已执行，而前向分支为未执行。 动态预测器应快速学习任何可预测的分支行为。

不同于其他一些架构，RISC-V 跳转（JAL，_rd_=`x0`）指令应始终用于无条件分支，而不是带有始终为真的条件分支指令。 RISC-V 跳转也是 PC 相对的，支持比分支更宽的偏移范围，并且不会污染条件分支预测表。

[TIP]
====
条件分支的设计包含了两寄存器之间的算术比较操作（Pa-RISC、Xtensa 和 MIPS R6也是这样做的），而不是使用条件码（x86、ARM、SPARC、PowerPC），也不是仅将一个寄存器与零进行比较（Alpha、MIPS），或仅检查两个寄存器的相等性（MIPS）。 这一设计的动机在于观察到结合的比较和分支指令适合常规流水线，避免了额外的条件码状态或使用临时寄存器，并减少了静态代码大小和动态指令提取流量。 另一个考虑点是，与零进行比较需要非琐碎的电路延迟（特别是在高级工艺中改用静态逻辑后），因此几乎与算术幅度比较同样昂贵。 融合比较和分支指令的另一个优点是，分支在前端指令流中更早被观察到，因此可以更早预测。 在多个分支可以基于相同条件码执行的情况下，设计中可能存在具有条件码的优势，但我们认为这种情况相对少见。

我们考虑过但未在指令编码中加入静态分支提示。 这些可以减轻动态预测器的压力，但需要更多的指令编码空间和软件分析以获得最佳结果，并且如果生产运行与分析运行不匹配可能导致性能下降。

我们考虑过但未包括条件移动或谓词指令，这些可以有效替代不可预测的短前向分支。 条件移动是两者中较简单的，但难以用于可能导致异常的条件代码（内存访问和浮点操作）。 谓词化给系统增加了额外的标志状态，增加了用于设置和清除标志的指令，以及每个指令的额外编码开销。 条件移动和谓词化指令都增加了乱序微体系结构的复杂性，增加了一个隐含的第三源操作数，因为需要在谓词为假时将目标架构寄存器的原始值复制到重命名的目标物理寄存器中。 此外，在编译时做出的使用谓词代替分支的静态决定，可能导致不在编译器训练集中的输入的性能下降，特别是考虑到不可预测的分支很少，并且随着分支预测技术的改进变得越来越少。

我们注意到存在各种微体系结构技术，可以将不可预测的短前向分支动态转换为内部谓词代码，以避免在分支误预测时清空流水线的代价 cite:[heil-tr1996], cite:[Klauser-1998], cite:[Kim-micro2005]，并已在商用处理器中实现 cite:[ibmpower7]。 最简单的方法仅通过清空分支影射中的指令而非整个提取流水线，或使用宽指令提取或空闲指令提取槽从两个方向提取指令，减少从误预测的短前向分支中恢复的损失。 对乱序内核，复杂一点的技术是在分支影射中的指令上增加内部谓词，内部谓词值由分支指令写入，允许分支和后续指令相对于其他代码投机性执行且乱序执行。
====

如果目标地址未对齐到四字节边界且分支条件评估为真，条件分支指令将生成指令地址未对齐异常。 如果分支条件评估为假，则不会引发指令地址未对齐异常。

[NOTE]
====
在支持扩展的机器上不可能发生指令地址未对齐异常，其中指令按 16 位对齐，例如压缩指令集扩展 C。
====

[[ldst]]
=== 加载和存储指令

RV32I 是一种加载存储架构，只有加载和存储指令访问内存，算术指令只对 CPU 寄存器操作。 RV32I 提供一个按字节寻址的 32 位地址空间。 EEI 将定义地址空间的哪些部分可以用哪些指令合法访问（例如，某些地址可能是只读的，或仅支持字访问）。 即便加载值被丢弃了，目标为 `x0` 的加载仍必须引发任何异常并造成其他副作用。

EEI 将定义内存系统是小端还是大端。 在 RISC-V 中，字节排序是字节地址不变的。

[TIP]
====
在字节顺序不变的系统中，以下属性成立：如果一个字节以某种字节序被存储到某个地址，那么从该地址进行任意字节序的字节大小加载将返回存储的值。

在小端配置中，多字节存储将最低有效寄存器字节写入最低内存字节地址，然后按重要性升序依次存储其他寄存器字节。 加载类似地将较小内存字节地址的内容传输到较不重要的寄存器字节。

在大端配置中，多字节存储将最高有效寄存器字节写入最低内存字节地址，然后按重要性降序依次存储其他寄存器字节。 加载类似地将更大内存字节地址的内容传输到更不重要的寄存器字节。
====

include::images\/wavedrom\/load_store.adoc[]

//.Load and store instructions

加载和存储指令在寄存器和内存之间传输值。 加载以 I 型格式编码，存储为 S 型。
有效地址通过将寄存器 _rs1_ 加到符号扩展的 12 位偏移量得到。 加载将一个值从内存复制到寄存器 _rd_。 存储将寄存器 _rs2_ 的值复制到内存。

LW 指令将 32 位值从内存加载到 _rd_ 中。 LH 从内存加载一个 16 位值，然后符号扩展到 32 位后存储在 _rd_ 中。 LHU 从内存加载一个 16 位值，但之后会进行零扩展到 32 位后存储在 _rd_ 中。 LB 和 LBU 类似地被定义用于 8 位值。 SW、SH 和 SB 指令从寄存器 _rs2_ 的低位将 32 位、16 位和 8 位值分别存储到内存。

无论 EEI，加载和存储的有效地址自然对齐时不应引发地址未对齐异常。 加载和存储的有效地址未自然对齐到引用的数据显示类型（即有效地址不可被访问字节大小整除）时，行为取决于 EEI。

EEI 可以保证完全支持未对齐的加载和存储，因此在执行环境内运行的软件将不会遇到封装或致命的地址未对齐异常。 在这种情况下，未对齐的加载和存储可以在硬件上处理，或通过一个不可见的陷阱进入执行环境实现，或可能根据地址是硬件和不可见陷阱的结合。

EEI 可能不能保证未对齐的加载和存储被隐式处理。 这种情况下，未自然对齐的加载和存储可能成功完成执行或引发异常。 引发的异常可以是地址未对齐异常或访问故障异常。 关于一项可能在未对齐情况下能够完成的内存访问，如果不应模拟未对齐访问，例如访问内存区域有副作用，可以引发访问故障异常而非地址未对齐异常。 当 EEI 不保证未对齐的加载和存储被隐式处理时，EEI 必须定义由于地址未对齐引起的异常是否导致封装陷阱（允许在执行环境内运行的软件处理陷阱）或致命陷阱（终止执行）。

[TIP]
====
在移植遗留代码时偶尔需要未对齐访问，并且在使用任何形式的打包 SIMD 扩展或处理外部打包数据结构时有助于应用性能。 允许 EEI 选择通过常规加载和存储指令支持未对齐访问的理由是简化未对齐硬件支持的添加。 一种方案是在基础 ISA 中禁止未对齐访问，然后为未对齐访问提供某种单独的 ISA 支持，例如帮助软件处理未对齐访问的特殊指令或支持未对齐访问的新硬件寻址模式。 特殊指令难以使用，复杂化 ISA，并且通常添加新的处理器状态（例如，SPARC VIS 对齐地址偏移寄存器）或复杂化对现有处理器状态的访问（例如，MIPS LWL\/LWR 部分寄存器写入）。 另外，对于面向循环的打包 SIMD 代码，操作数未对齐时的额外开销促使软件提供根据操作数对齐情况的多种循环形式，这复杂化了代码生成并增加了循环启动开销。 新的未对齐硬件寻址模式在指令编码中占据相当大的空间或需要非常简化的寻址模式（例如，仅寄存器间接寻址）。
====

即使未对齐加载和存储成功完成，这些访问可能根据实现（例如，通过一个不可见的陷阱实现时）运行得极慢。 此外，自然对齐的加载和存储保证原子执行，而未对齐的加载和存储可能不保证，从而需要额外的同步以确保原子性。

[NOTE]
====
我们不要求未对齐访问具有原子性，以便执行环境实现可以使用一个不可见的机器陷阱和软件处理器来处理部分或所有未对齐访问。 如果提供了硬件未对齐支持，软件可以简单通过使用常规加载和存储指令加以利用。 硬件能够根据运行时地址是否对齐自动优化访问。
====

[[fence]]
=== 内存排序指令

include::images\/wavedrom\/mem_order.adoc[]

//.Memory ordering instructions

FENCE 指令用于对设备 I\/O 和内存访问进行排序，以便其他 RISC-V hart 和外部设备或协处理器能够查看。 设备输入（I）、设备输出（O）、内存读取（R）和内存写入（W）之间的任意组合可以相对于相同的任意组合进行排序。 非正式地说，没有其他 RISC-V hart 或外部设备可以在 FENCE 之前观察任何在 _precedessor_ 集中进行的操作之前的 _successor_ 集中进行的任何操作。
<<memorymodel>> 提供了 RISC-V 内存一致性模型的精确描述。

FENCE 指令还对 hart 所做的内存读取和写入进行排序，这些操作可以通过外部设备所做的内存读取和写入观察到。
然而，FENCE 不对外部设备使用任何其他信令机制进行的事件观察进行排序。

[NOTE]
====
设备可能通过某些外部通信机制观察对内存位置的访问，例如，一个驱动中断信号到中断控制器的内存映射控制寄存器。 此通信不在 FENCE 排序机制的范围内，因此 FENCE 指令不能提供关于何时中断控制器可以看到中断信号变化的保证。 特定设备可能提供额外排序保证以减少软件开销，但这些不在 RISC-V 内存模型的范围内。
====

EEI 将定义可能的 I\/O 操作，特别是当由加载和存储指令访问时，哪些内存地址将被分别视为设备输入和设备输出操作进行排序，而不是内存读取和写入。 例如，内存映射 I\/O 设备通常由无缓存加载和存储访问，这些操作将使用 I 和 O 位而非 R 和 W 位进行排序。 指令集扩展可能也会定义新的 I\/O 指令，这些指令将在 FENCE 中使用 I 和 O 位进行排序。

[[fm]]
[float="center", align="center", cols="^1,^1,<3", options="header"]
.Fence 模式编码
|===
|_fm_ 字段
|助记符
|意义

|0000 |_none_ |普通围栏

|1000 |TSO |使用 `FENCE RW,RW`：排除写到读的排序；否则：_保留供将来使用。_

2+|_other_ |_保留以供将来使用。_
|===

栅栏模式字段 _fm_ 定义了 `FENCE` 的语义。 一个 `FENCE`
使用 _fm_=`0000`，将其前置集合中的所有内存操作
排序在其后置集合中的所有内存操作之前。

`FENCE.TSO` 指令被编码为一个 `FENCE` 指令，
其中 _fm_=`1000`，_前置_=`RW`，_后置_=`RW`。 `FENCE.TSO` 将其前置集合中的所有加载操作
排序在其后置集合中的所有内存操作之前，并且将其前置集合中的所有存储操作
排序在其后置集合中的所有存储操作之前。 这使得 `FENCE.TSO` 的前置集合中的“非-AMO”存储操作
与其后置集合中的“非-AMO”加载操作未排序。

[NOTE]
====
因为 FENCE RW,RW 施加的排序是 FENCE.TSO 施加的排序的超集，所以忽略 _fm_ 字段并将 FENCE.TSO 实现为 FENCE RW,RW 是正确的。
====

`FENCE` 指令中的未使用字段--_rs1_ 和 _rd_--保留用于未来扩展中的更细粒度的围栏。 为了向前兼容，基础实现应忽略这些字段，而标准软件应将这些字段清零。 同样，<<fm>> 中的许多 _fm_ 和 predecessor / successor 集设置也保留供将来使用。
基础实现应将所有此类保留的配置视为 _fm_=0000 的普通栅栏，标准软件应仅使用非保留配置。

[TIP]
====
我们选择了一个放松的内存模型，以允许从简单的机器实现以及可能的未来协处理器或加速器扩展中获得高性能。 我们将 I\/O 排序与内存 R\/W 排序分开，以避免设备驱动程序 hart 中的不必要串行化，并支持替代的非内存路径来控制新增的协处理器或 I\/O 设备。 简洁实现可能还会忽略 _predecessor_ 和 _successor_ 字段，并始终在所有操作上执行保守围栏。
====

=== 环境调用和断点

`SYSTEM` 指令用于访问可能需要特权访问的系统功能，并使用 I 型指令格式编码。 这些可以分为两大类：那些原子地读取-修改-写入控制和状态寄存器（CSR）的指令，以及所有其他可能有特权的指令。 CSR 指令在 <<csrinsts>> 中描述，基础非特权指令在下一节描述。

[TIP]
====
SYSTEM 指令被定义为允许更简单的实现
始终陷入单个软件陷阱处理程序。 更复杂的实现可能会执行更多的每个系统指令在硬件中。
====

include::images/wavedrom/env_call-breakpoint.adoc[]

//.Environment call and breakpoint instructions

这两个指令会导致对支持的执行环境的精确请求陷阱。

`ECALL` 指令用于向执行环境发出服务请求。 `EEI` 将定义服务请求参数如何传递，
但通常这些参数会在整数寄存器文件中的定义位置。

`EBREAK` 指令用于将控制权返回给调试环境。

[NOTE]
====
ECALL 和 EBREAK 先前分别命名为 SCALL 和 SBREAK。 这些指令具有相同的功能和编码，但被重命名以反映它们比调用督导级操作系统或调试器更广泛使用。
====

[TIP]
====
EBREAK 主要设计用于由调试器使用，导致执行停止并返回到调试器中。 EBREAK 还用于标准 gcc 编译器标记不应执行的代码路径。

EBREAK 的另一个用法是支持“半托管”，其中执行环境包括一个可以通过围绕 EBREAK 指令构建的替代系统调用接口提供服务的调试器。
由于 RISC-V 基础 ISA 不提供多个 EBREAK 指令，RISC-V 半托管使用特殊指令序列来区分半托管的 EBREAK 和调试器插入的 EBREAK。

[source,asm]
....
    slli x0, x0, 0x1f   # Entry NOP
    ebreak              # Break to debugger
    srai x0, x0, 7      # NOP encoding the semihosting call number 7
....

注意，这三条指令必须是 32 位宽指令，即，它们不能在 <<compressed>> 描述的压缩 16 位指令中。

位移 NOP 指令仍然被认为可用作 HINTs。

半托管是一种服务调用形式，可以更自然地编码为使用现有 ABI 的 ECALL，但这要求调试器能够截取 ECALLs，这是一种调试标准的新添加。 我们打算转而使用带有标准 ABI 的 ECALLs，在这种情况下，半托管可以与现有标准共享服务 ABI。

我们注意到 ARM 处理器也在较新的设计中转而使用 SVC 而非 BKPT 进行半托管调用。
====

=== HINT 指令

//[#rv32i-hints,HINT Instructions]

RV32I 为 HINT 指令保留了大片编码空间，通常用于向微体系结构传递性能提示。
与 NOP 指令类似，HINT 不会更改任何架构可见状态，除非是推进 `pc` 和任何适用的性能计数器。 实现始终允许忽略编码提示。

大多数 RV32I HINTs 被编码为整数计算指令，_rd_ = x0。 其他 RV32I HINTs 被编码为 FENCE 指令，与空的前继或后继集和 _fm_ = 0。

[NOTE]
====
这些 HINT 编码的选择是为了使简单实现可以完全忽略 HINTs，并改为执行一个不会改变架构状态的常规指令。 例如，如果目标寄存器为 `x0`，ADD 是一个 HINT；五位 _rs1_ 和 _rs2_ 字段编码传递给 HINT 的参数。 然而，一个简单的实现可以简单地执行 HINT 作为 _rs1_ 和 _rs2_ 的 ADD，写入 `x0`，这没有架构可见的效果。

作为另一个例子，带有零 _pred_ 字段和零 _fm_ 字段的 FENCE 指令是一个 HINT；_succ_、_rs1_ 和 _rd_ 字段编码传递给 HINT 的参数。 简单实现可以简单执行 HINT 作为一个 FENCE，在 _succ_ 字段编码的无集的先前内存访问之前对随后的内存访问进行排序。
由于前继和后继集的交集为空，指令不强制内存排序，因此没有架构上可见的效果。
====

<<t-rv32i-hints>> 列出了所有 RV32I HINT 代码点。 91% 的 HINT 空间保留用于标准 HINTs。 HINT 空间的剩余部分指定用于自定义 HINTs：在此子空间中不会定义标准 HINTs。

[TIP]
====
我们预计标准提示将最终包括内存系统空间和时间局部性提示、分支预测提示、线程调度提示、安全标签和模拟/仿真用的仪表标志。
====

// this table might still have some problems--some rows might not have landed properly. It needs to be checked cell-by cell.

[[t-rv32i-hints]]
.RV32I HINT 指令。
[float="center", align="center", cols="<,<,^,<", options="header"]
|===
|指令
|约束
|代码点
|目的

|LUI |_rd_=`x0` |latexmath:[$2^{20}$] .8+<.^m|_指定用于未来标准用途_

|AUIPC |_rd_=`x0` |latexmath:[$2^{20}$]

|ADDI |_rd_=`x0`, 并且 _rs1_≠``x0`` 或 _imm_≠0 |latexmath:[$2^{17}-1$]

|ANDI |_rd_=`x0` |latexmath:[$2^{17}$]

|ORI |_rd_=`x0` |latexmath:[$2^{17}$]

|XORI |_rd_=`x0` |latexmath:[$2^{17}$]

|ADD |_rd_=`x0`, _rs1_≠``x0`` |latexmath:[$2^{10}-32$]

|ADD |_rd_=`x0`, _rs1_=`x0`, _rs2_≠``x2-x5`` |28

|ADD |_rd_=`x0`, _rs1_=`x0`, _rs2_=`x2-x5` |4 |(_rs2_=`x2`) NTL.P1 +\n(_rs2_=`x3`) NTL.PALL +\n(_rs2_=`x4`) NTL.S1 +\n(_rs2_=`x5`) NTL.ALL

|SUB |_rd_=`x0` |latexmath:[$2^{10}$] 11+<.^m|_指定用于未来标准用途_

|AND |_rd_=`x0` |latexmath:[$2^{10}$]

|OR |_rd_=`x0` |latexmath:[$2^{10}$]

|XOR |_rd_=`x0` |latexmath:[$2^{10}$]

|SLL |_rd_=`x0` |latexmath:[$2^{10}$]

|SRL |_rd_=`x0` |latexmath:[$2^{10}$]

|SRA |_rd_=`x0` |latexmath:[$2^{10}$]

|FENCE |_rd_=`x0`, _rs1_≠``x0``, _fm_=0, 并且 _pred_=0 或 _succ_=0 |latexmath:[$2^{10}-63$]

|FENCE |_rd_≠``x0``, _rs1_=`x0`, _fm_=0, 并且 _pred_=0 或 _succ_=0 |latexmath:[$2^{10}-63$]

|FENCE |_rd_=_rs1_=`x0`, _fm_=0, _pred_=0, _succ_≠0 |15

|FENCE |_rd_=_rs1_=`x0`, _fm_=0, _pred_≠W, _succ_=0 |15

|FENCE |_rd_=_rs1_=`x0`, _fm_=0, _pred_=W, _succ_=0 |1 |PAUSE

4+|

|SLTI |_rd_=`x0` |latexmath:[$2^{17}$] .7+<.^m|_为自定义用途指定_

|SLTIU |_rd_=`x0` |latexmath:[$2^{17}$]

|SLLI |_rd_=`x0` |latexmath:[$2^{10}$]

|SRLI |_rd_=`x0` |latexmath:[$2^{10}$]

|SRAI |_rd_=`x0` |latexmath:[$2^{10}$]

|SLT |_rd_=`x0` |latexmath:[$2^{10}$]

|SLTU |_rd_=`x0` |latexmath:[$2^{10}$]
|===